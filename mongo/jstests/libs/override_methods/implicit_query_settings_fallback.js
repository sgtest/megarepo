import {everyWinningPlan, isIdhackOrExpress, isQueryPlan} from "jstests/libs/analyze_plan.js";
import {
    getCollectionName,
    getCommandName,
    getExplainCommand,
    getInnerCommand,
    isInternalDbName,
    isSystemCollectionName
} from "jstests/libs/cmd_object_utils.js";
import {OverrideHelpers} from "jstests/libs/override_methods/override_helpers.js";
import {QuerySettingsIndexHintsTests} from "jstests/libs/query_settings_index_hints_tests.js";
import {QuerySettingsUtils} from "jstests/libs/query_settings_utils.js";

/**
 * Override which applies 'bad' query settings over supported commands in order to test the fallback
 * mechanism. Asserts that the query plans generated by the fallback should be identical to those
 * generated without any query settings.
 */
function runCommandOverride(conn, dbName, cmdName, cmdObj, clientFunction, makeFuncArgs) {
    const assertFallbackPlanMatchesOriginalPlan = () => {
        if (isInternalDbName(dbName)) {
            // Query settings cannot be set over internal databases.
            return;
        }

        const db = conn.getDB(dbName);
        const innerCmd = getInnerCommand(cmdObj);
        if (!QuerySettingsUtils.isSupportedCommand(getCommandName(innerCmd))) {
            return;
        }

        const explainCmd = getExplainCommand(innerCmd);
        const explain = OverrideHelpers.commandMaybeWorked(db.runCommand(explainCmd));
        if (!explain) {
            // Lacking an explain means that the command originally failed, and therefore we can't
            // test the fallback on it.
            return;
        }

        if (!isQueryPlan(explain)) {
            // Some queries rely exclusively on the query layer without any plan being involved.
            return;
        }

        const isIdHackQuery =
            everyWinningPlan(explain, (winningPlan) => isIdhackOrExpress(db, winningPlan));
        if (isIdHackQuery) {
            // Query settings cannot be applied over IDHACK or Express queries.
            return;
        }

        const collectionName = getCollectionName(innerCmd);
        if (!collectionName || isSystemCollectionName(collectionName)) {
            // Can't test the fallback on queries not involving any collections or queries targeting
            // the system collection.
            return;
        }

        const ns = {db: dbName, coll: collectionName};
        const qsutils = new QuerySettingsUtils(db, collectionName);
        const qstests = new QuerySettingsIndexHintsTests(qsutils);
        const representativeQuery = qsutils.makeQueryInstance(innerCmd);
        qstests.assertQuerySettingsFallback(representativeQuery, ns);
    };

    const res = clientFunction.apply(conn, makeFuncArgs(cmdObj));
    if (OverrideHelpers.commandMaybeWorked(res)) {
        // Only run the test if the original command works.
        OverrideHelpers.withPreOverrideRunCommand(assertFallbackPlanMatchesOriginalPlan);
    }
    return res;
}

// Override the default runCommand with our custom version.
OverrideHelpers.overrideRunCommand(runCommandOverride);

// Always apply the override if a test spawns a parallel shell.
OverrideHelpers.prependOverrideInParallelShell(
    "jstests/libs/override_methods/implicit_query_settings_fallback.js");
