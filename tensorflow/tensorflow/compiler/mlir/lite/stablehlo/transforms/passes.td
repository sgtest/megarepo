/* Copyright 2023 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

include "mlir/Pass/PassBase.td"

def ComposeUniformQuantizedTypePass : Pass<"compose-uniform-quantized-type", "ModuleOp"> {
  let summary = "Compose uniform quantized types in StableHLO.";
  let constructor = "mlir::odml::CreateComposeUniformQuantizedTypePass()";
  let description = [{
    Identifies uniform quantization patterns and composes them to uniform
    quantized types. This pass targets a specific set of models that are
    quantized from the framework level, which produces "decomposed"
    quantization patterns due to the limitations of the framework.

    In the long term it is desired that the framework produces uniform
    quantized types directly and deprecate this pass.

    The target patterns should have the following characteristics, with some
    variations depending on the op being quantized.

    * A tensor is quantized using a `func::FuncOp` whose name contains
      "uniform_quantize". The first argument is the tensor to be quantized,
      the second argument is the zero point constant (element type: int) and
      the third argument is the inverse scale constant (element type: float).
    * A tensor is dequantized using a `func::FuncOp` whose name contains
      "uniform_dequantize". The first argument is the tensor to be quantized,
      the second argument is the zero point constant (element type: int) and
      the third argument is the inverse scale constant (element type: float).
    * Inputs to the target quantized op is quantized and the outputs are
      dequantized.
    * All quantization parameters (zero points and scales) are available,
      usually as constants.

    The resulting pattern for a quantized op looks roughly as follows:

    ```
    %0 = stablehlo.constant() : () -> tensor<...x!quant.uniform<i8:f32:3 ...>>
    %1 = stablehlo.uniform_quantize %2 : (tensor<...xf32>) -> tensor<...x!quant.uniform<i8:f32 ...>>
    %3 = stablehlo.my_quantized_op(%1, %0) : (tensor<...x!quant.uniform<i8:f32 ...>>, tensor<...x!quant.uniform<i8:f32:3 ...>>) -> tensor<...x!quant.uniform<i8:f32 ...>>
    %4 = stablehlo.dequantize %3 : (tensor<...x!quant.uniform<i8:f32 ...>>) -> tensor<...xf32>
    ```
  }];
  let dependentDialects = [
    "stablehlo::StablehloDialect",
    "quant::QuantizationDialect",
  ];
}

def UniformQuantizedStablehloToTflPass
    : Pass<"uniform-quantized-stablehlo-to-tfl", "mlir::func::FuncOp"> {
  let summary = "Converts StableHLO ops using uniform quantized types to equivalent TFL ops.";
  let constructor = "mlir::odml::CreateUniformQuantizedStablehloToTflPass()";
  let description = [{
    Converts StableHLO ops that accept or return uniform quantized types to
    equivalent ops in the TFLite dialect.
  }];
  let dependentDialects = [
    "stablehlo::StablehloDialect",
    "quant::QuantizationDialect",
    "mlir::TFL::TFLDialect",
  ];
}
