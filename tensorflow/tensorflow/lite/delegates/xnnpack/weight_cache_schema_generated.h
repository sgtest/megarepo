/* Copyright 2024 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WEIGHTCACHESCHEMA_TFLITE_XNNPACK_CACHE_SCHEMA_H_
#define FLATBUFFERS_GENERATED_WEIGHTCACHESCHEMA_TFLITE_XNNPACK_CACHE_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace tflite {
namespace xnnpack {
namespace cache {
namespace schema {

struct Buffer;
struct BufferBuilder;
struct BufferT;

struct BufferList;
struct BufferListBuilder;
struct BufferListT;

struct BufferT : public ::flatbuffers::NativeTable {
  typedef Buffer TableType;
  uint64_t packing_algorithm_id = 0;
  uint64_t weights_id = 0;
  uint64_t bias_id = 0;
  uint64_t offset = 0;
  uint64_t size = 0;
};

struct Buffer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BufferT NativeTableType;
  typedef BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PACKING_ALGORITHM_ID = 4,
    VT_WEIGHTS_ID = 6,
    VT_BIAS_ID = 8,
    VT_OFFSET = 10,
    VT_SIZE = 12
  };
  uint64_t packing_algorithm_id() const {
    return GetField<uint64_t>(VT_PACKING_ALGORITHM_ID, 0);
  }
  bool mutate_packing_algorithm_id(uint64_t _packing_algorithm_id = 0) {
    return SetField<uint64_t>(VT_PACKING_ALGORITHM_ID, _packing_algorithm_id, 0);
  }
  uint64_t weights_id() const {
    return GetField<uint64_t>(VT_WEIGHTS_ID, 0);
  }
  bool mutate_weights_id(uint64_t _weights_id = 0) {
    return SetField<uint64_t>(VT_WEIGHTS_ID, _weights_id, 0);
  }
  uint64_t bias_id() const {
    return GetField<uint64_t>(VT_BIAS_ID, 0);
  }
  bool mutate_bias_id(uint64_t _bias_id = 0) {
    return SetField<uint64_t>(VT_BIAS_ID, _bias_id, 0);
  }
  /// The buffer data is appended after the flatbuffer to bypass 2GB file size
  /// limitation. The offset is calculated relative to the base offset.
  /// (i.e. beginning of the file + base_offset).
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  bool mutate_offset(uint64_t _offset = 0) {
    return SetField<uint64_t>(VT_OFFSET, _offset, 0);
  }
  /// Size of the buffer in bytes.
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint64_t _size = 0) {
    return SetField<uint64_t>(VT_SIZE, _size, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PACKING_ALGORITHM_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_WEIGHTS_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_BIAS_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET, 8) &&
           VerifyField<uint64_t>(verifier, VT_SIZE, 8) &&
           verifier.EndTable();
  }
  BufferT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BufferT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Buffer> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BufferT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BufferBuilder {
  typedef Buffer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_packing_algorithm_id(uint64_t packing_algorithm_id) {
    fbb_.AddElement<uint64_t>(Buffer::VT_PACKING_ALGORITHM_ID, packing_algorithm_id, 0);
  }
  void add_weights_id(uint64_t weights_id) {
    fbb_.AddElement<uint64_t>(Buffer::VT_WEIGHTS_ID, weights_id, 0);
  }
  void add_bias_id(uint64_t bias_id) {
    fbb_.AddElement<uint64_t>(Buffer::VT_BIAS_ID, bias_id, 0);
  }
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(Buffer::VT_OFFSET, offset, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(Buffer::VT_SIZE, size, 0);
  }
  explicit BufferBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Buffer> CreateBuffer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t packing_algorithm_id = 0,
    uint64_t weights_id = 0,
    uint64_t bias_id = 0,
    uint64_t offset = 0,
    uint64_t size = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_offset(offset);
  builder_.add_bias_id(bias_id);
  builder_.add_weights_id(weights_id);
  builder_.add_packing_algorithm_id(packing_algorithm_id);
  return builder_.Finish();
}

::flatbuffers::Offset<Buffer> CreateBuffer(::flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BufferListT : public ::flatbuffers::NativeTable {
  typedef BufferList TableType;
  std::vector<std::unique_ptr<tflite::xnnpack::cache::schema::BufferT>> buffers{};
  uint64_t base_offset = 0;
  BufferListT() = default;
  BufferListT(const BufferListT &o);
  BufferListT(BufferListT&&) FLATBUFFERS_NOEXCEPT = default;
  BufferListT &operator=(BufferListT o) FLATBUFFERS_NOEXCEPT;
};

struct BufferList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BufferListT NativeTableType;
  typedef BufferListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFERS = 4,
    VT_BASE_OFFSET = 6
  };
  /// A list of buffers.
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>> *buffers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>> *>(VT_BUFFERS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>> *mutable_buffers() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>> *>(VT_BUFFERS);
  }
  /// Defines the base offset for the data in the file. That offset
  /// may be needed to guarantee data alignment.
  uint64_t base_offset() const {
    return GetField<uint64_t>(VT_BASE_OFFSET, 0);
  }
  bool mutate_base_offset(uint64_t _base_offset = 0) {
    return SetField<uint64_t>(VT_BASE_OFFSET, _base_offset, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) &&
           verifier.VerifyVectorOfTables(buffers()) &&
           VerifyField<uint64_t>(verifier, VT_BASE_OFFSET, 8) &&
           verifier.EndTable();
  }
  BufferListT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BufferListT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BufferList> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BufferListT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BufferListBuilder {
  typedef BufferList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_buffers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>>> buffers) {
    fbb_.AddOffset(BufferList::VT_BUFFERS, buffers);
  }
  void add_base_offset(uint64_t base_offset) {
    fbb_.AddElement<uint64_t>(BufferList::VT_BASE_OFFSET, base_offset, 0);
  }
  explicit BufferListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BufferList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BufferList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BufferList> CreateBufferList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>>> buffers = 0,
    uint64_t base_offset = 0) {
  BufferListBuilder builder_(_fbb);
  builder_.add_base_offset(base_offset);
  builder_.add_buffers(buffers);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BufferList> CreateBufferListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>> *buffers = nullptr,
    uint64_t base_offset = 0) {
  auto buffers__ = buffers ? _fbb.CreateVector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>>(*buffers) : 0;
  return tflite::xnnpack::cache::schema::CreateBufferList(
      _fbb,
      buffers__,
      base_offset);
}

::flatbuffers::Offset<BufferList> CreateBufferList(::flatbuffers::FlatBufferBuilder &_fbb, const BufferListT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline BufferT *Buffer::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BufferT>(new BufferT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Buffer::UnPackTo(BufferT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = packing_algorithm_id(); _o->packing_algorithm_id = _e; }
  { auto _e = weights_id(); _o->weights_id = _e; }
  { auto _e = bias_id(); _o->bias_id = _e; }
  { auto _e = offset(); _o->offset = _e; }
  { auto _e = size(); _o->size = _e; }
}

inline ::flatbuffers::Offset<Buffer> Buffer::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BufferT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBuffer(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Buffer> CreateBuffer(::flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BufferT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _packing_algorithm_id = _o->packing_algorithm_id;
  auto _weights_id = _o->weights_id;
  auto _bias_id = _o->bias_id;
  auto _offset = _o->offset;
  auto _size = _o->size;
  return tflite::xnnpack::cache::schema::CreateBuffer(
      _fbb,
      _packing_algorithm_id,
      _weights_id,
      _bias_id,
      _offset,
      _size);
}

inline BufferListT::BufferListT(const BufferListT &o)
      : base_offset(o.base_offset) {
  buffers.reserve(o.buffers.size());
  for (const auto &buffers_ : o.buffers) { buffers.emplace_back((buffers_) ? new tflite::xnnpack::cache::schema::BufferT(*buffers_) : nullptr); }
}

inline BufferListT &BufferListT::operator=(BufferListT o) FLATBUFFERS_NOEXCEPT {
  std::swap(buffers, o.buffers);
  std::swap(base_offset, o.base_offset);
  return *this;
}

inline BufferListT *BufferList::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BufferListT>(new BufferListT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BufferList::UnPackTo(BufferListT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = buffers(); if (_e) { _o->buffers.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->buffers[_i]) { _e->Get(_i)->UnPackTo(_o->buffers[_i].get(), _resolver); } else { _o->buffers[_i] = std::unique_ptr<tflite::xnnpack::cache::schema::BufferT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->buffers.resize(0); } }
  { auto _e = base_offset(); _o->base_offset = _e; }
}

inline ::flatbuffers::Offset<BufferList> BufferList::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BufferListT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBufferList(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BufferList> CreateBufferList(::flatbuffers::FlatBufferBuilder &_fbb, const BufferListT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BufferListT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _buffers = _o->buffers.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>> (_o->buffers.size(), [](size_t i, _VectorArgs *__va) { return CreateBuffer(*__va->__fbb, __va->__o->buffers[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _base_offset = _o->base_offset;
  return tflite::xnnpack::cache::schema::CreateBufferList(
      _fbb,
      _buffers,
      _base_offset);
}

inline const tflite::xnnpack::cache::schema::BufferList *GetBufferList(const void *buf) {
  return ::flatbuffers::GetRoot<tflite::xnnpack::cache::schema::BufferList>(buf);
}

inline const tflite::xnnpack::cache::schema::BufferList *GetSizePrefixedBufferList(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<tflite::xnnpack::cache::schema::BufferList>(buf);
}

inline BufferList *GetMutableBufferList(void *buf) {
  return ::flatbuffers::GetMutableRoot<BufferList>(buf);
}

inline tflite::xnnpack::cache::schema::BufferList *GetMutableSizePrefixedBufferList(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<tflite::xnnpack::cache::schema::BufferList>(buf);
}

inline bool VerifyBufferListBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<tflite::xnnpack::cache::schema::BufferList>(nullptr);
}

inline bool VerifySizePrefixedBufferListBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<tflite::xnnpack::cache::schema::BufferList>(nullptr);
}

inline void FinishBufferListBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<tflite::xnnpack::cache::schema::BufferList> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBufferListBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<tflite::xnnpack::cache::schema::BufferList> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<tflite::xnnpack::cache::schema::BufferListT> UnPackBufferList(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<tflite::xnnpack::cache::schema::BufferListT>(GetBufferList(buf)->UnPack(res));
}

inline std::unique_ptr<tflite::xnnpack::cache::schema::BufferListT> UnPackSizePrefixedBufferList(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<tflite::xnnpack::cache::schema::BufferListT>(GetSizePrefixedBufferList(buf)->UnPack(res));
}

}  // namespace schema
}  // namespace cache
}  // namespace xnnpack
}  // namespace tflite

#endif  // FLATBUFFERS_GENERATED_WEIGHTCACHESCHEMA_TFLITE_XNNPACK_CACHE_SCHEMA_H_
