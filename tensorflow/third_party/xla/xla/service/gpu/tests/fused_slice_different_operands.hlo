// RUN: hlo_to_llvm_ir %s | FileCheck --check-prefixes=CHECK,CHECK-%{PTX} %{IR_SUBST} %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// about what constitutes a good test! The CHECK should be
// minimized and named to reflect the test intent.


// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = call i32 [[CTAIDX]]
// CHECK:         %[[VAL_1:.*]] = call i32 [[TIDX]]
// CHECK-PTX:     %[[VAL_2:.*]] = mul nuw nsw i32 %[[VAL_0]], 128
// CHECK-GCN:     %[[VAL_2:.*]] = mul nuw nsw i32 %[[VAL_0]], 256
// CHECK:         %[[VAL_3:.*]] = add nuw nsw i32 %[[VAL_2]], %[[VAL_1]]
// CHECK:         %[[VAL_4:.*]] = icmp ult i32 %[[VAL_3]], 1024
// CHECK:         call void @llvm.assume(i1 %[[VAL_4]])
// CHECK:         %[[VAL_5:.*]] = add nuw nsw i32 %[[VAL_3]], 0
// CHECK:         %[[VAL_6:.*]] = udiv i32 %[[VAL_5]], 1
// CHECK:         %[[VAL_7:.*]] = icmp ult i32 %[[VAL_3]], 1024
// CHECK:         br i1 %[[VAL_7]], label %[[VAL_8:.*]], label %[[VAL_9:.*]]
// CHECK:       fusion.in_bounds-after:                           ; preds = %[[VAL_10:.*]], %[[VAL_11:.*]]
// CHECK:         ret void
// CHECK:       fusion.in_bounds-true:                            ; preds = %[[VAL_11]]
// CHECK:         %[[VAL_12:.*]] = add i32 %[[VAL_6]], 0
// CHECK:         br label %[[VAL_13:.*]]
// CHECK:       concat_index_from_operand_id0:                    ; preds = %[[VAL_14:.*]]
// CHECK:         %[[VAL_15:.*]] = phi i32 [ 0, %[[VAL_14]] ]
// CHECK:         %[[VAL_16:.*]] = sub nsw i32 %[[VAL_12]], %[[VAL_15]]
// CHECK:         %[[VAL_17:.*]] = getelementptr inbounds [1024 x half], ptr %[[VAL_18:.*]], i32 0, i32 %[[VAL_16]]
// CHECK:         %[[VAL_19:.*]] = load half, ptr %[[VAL_17]], align 2, !invariant.load
// CHECK:         %[[VAL_20:.*]] = getelementptr inbounds [1024 x half], ptr %[[VAL_21:.*]], i32 0, i32 %[[VAL_16]]
// CHECK:         %[[VAL_22:.*]] = load half, ptr %[[VAL_20]], align 2, !invariant.load
// CHECK:         %[[VAL_23:.*]] = fmul half %[[VAL_19]], %[[VAL_22]]
// CHECK:         br label %[[VAL_10]]
// CHECK:       concat_index_from_operand_id1:                    ; preds = %[[VAL_24:.*]]
// CHECK:         %[[VAL_25:.*]] = phi i32 [ 1024, %[[VAL_24]] ]
// CHECK:         %[[VAL_26:.*]] = sub nsw i32 %[[VAL_12]], %[[VAL_25]]
// CHECK:         %[[VAL_27:.*]] = getelementptr inbounds [1023 x half], ptr %[[VAL_28:.*]], i32 0, i32 %[[VAL_26]]
// CHECK:         %[[VAL_29:.*]] = load half, ptr %[[VAL_27]], align 2, !invariant.load
// CHECK:         %[[VAL_30:.*]] = getelementptr inbounds [1023 x half], ptr %[[VAL_31:.*]], i32 0, i32 %[[VAL_26]]
// CHECK:         %[[VAL_32:.*]] = load half, ptr %[[VAL_30]], align 2, !invariant.load
// CHECK:         %[[VAL_33:.*]] = fadd half %[[VAL_29]], %[[VAL_32]]
// CHECK:         br label %[[VAL_10]]
// CHECK:       concatenate.pivot.1024.:                          ; preds = %[[VAL_8]]
// CHECK:         %[[VAL_34:.*]] = icmp ult i32 %[[VAL_12]], 1024
// CHECK:         br i1 %[[VAL_34]], label %[[VAL_14]], label %[[VAL_24]]
// CHECK:       concatenate.pivot.0.:                             ; preds = %[[VAL_13]]
// CHECK:         br label %[[VAL_35:.*]]
// CHECK:       concatenate.pivot.1024.1:                         ; preds = %[[VAL_13]]
// CHECK:         br label %[[VAL_36:.*]]
// CHECK:       concat.1.merge:                                   ; preds = %[[VAL_36]], %[[VAL_35]]
// CHECK:         %[[VAL_37:.*]] = phi half [ %[[VAL_23]], %[[VAL_35]] ], [ %[[VAL_33]], %[[VAL_36]] ]
// CHECK:         %[[VAL_38:.*]] = insertvalue { half, half } undef, half %[[VAL_37]], 0
// CHECK:         %[[VAL_39:.*]] = add i32 %[[VAL_6]], 0
// CHECK:         %[[VAL_40:.*]] = getelementptr inbounds [1024 x half], ptr %[[VAL_18]], i32 0, i32 %[[VAL_39]]
// CHECK:         %[[VAL_41:.*]] = load half, ptr %[[VAL_40]], align 2, !invariant.load
// CHECK:         %[[VAL_42:.*]] = getelementptr inbounds [1024 x half], ptr %[[VAL_21]], i32 0, i32 %[[VAL_39]]
// CHECK:         %[[VAL_43:.*]] = load half, ptr %[[VAL_42]], align 2, !invariant.load
// CHECK:         %[[VAL_44:.*]] = fmul half %[[VAL_41]], %[[VAL_43]]
// CHECK:         %[[VAL_45:.*]] = insertvalue { half, half } %[[VAL_38]], half %[[VAL_44]], 1
// CHECK:         %[[VAL_46:.*]] = extractvalue { half, half } %[[VAL_45]], 0
// CHECK:         %[[VAL_47:.*]] = getelementptr half, ptr %[[VAL_48:.*]], i32 %[[VAL_3]]
// CHECK:         %[[VAL_49:.*]] = getelementptr inbounds half, ptr %[[VAL_47]], i32 0
// CHECK:         store half %[[VAL_46]], ptr %[[VAL_49]], align 2
// CHECK:         %[[VAL_50:.*]] = extractvalue { half, half } %[[VAL_45]], 1
// CHECK:         %[[VAL_51:.*]] = getelementptr half, ptr %[[VAL_52:.*]], i32 %[[VAL_3]]
// CHECK:         %[[VAL_53:.*]] = getelementptr inbounds half, ptr %[[VAL_51]], i32 0
// CHECK:         store half %[[VAL_50]], ptr %[[VAL_53]], align 2
// CHECK:         br label %[[VAL_9]]

HloModule input_fusion_with_a_tuple_of_slices, is_scheduled=true

fused_computation {
  arg.1 = f16[1024]{0} parameter(0)
  arg.2 = f16[1024]{0} parameter(1)
  arg.3 = f16[1023]{0} parameter(2)
  arg.4 = f16[1023]{0} parameter(3)
  mul.1 = f16[1024]{0} multiply(arg.1, arg.2)
  add.1 = f16[1023]{0} add(arg.3, arg.4)
  concat.1 = f16[2047]{0} concatenate(mul.1, add.1), dimensions={0}
  slice.1 = f16[1024]{0} slice(concat.1), slice={[0:1024]}
  slice.2 = f16[1024]{0} slice(mul.1), slice={[0:1024]}
  ROOT tuple.1 = (f16[1024]{0}, f16[1024]{0}) tuple(slice.1, slice.2)
}

ENTRY kernel_entry {
  arg.1 = f16[1024]{0} parameter(0)
  arg.2 = f16[1024]{0} parameter(1)
  arg.3 = f16[1023]{0} parameter(2)
  arg.4 = f16[1023]{0} parameter(3)
  ROOT fusion = (f16[1024]{0}, f16[1024]{0})
      fusion(arg.1, arg.2, arg.3, arg.4), kind=kLoop, calls=fused_computation
}

