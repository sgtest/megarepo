#!/bin/sh

# /bin/sh on Solaris is not a POSIX compatible shell, but /usr/bin/bash is.
if [ `uname -s` = 'SunOS' -a "${POSIX_SHELL}" != "true" ]; then
    POSIX_SHELL="true"
    export POSIX_SHELL
    exec /usr/bin/env bash $0 "$@"
fi
unset POSIX_SHELL # clear it so if we invoke other scripts, they run as bash as well

msg() {
    echo "configure: $*"
}

step_msg() {
    msg
    msg "$1"
    msg
}

warn() {
    echo "configure: WARNING: $1"
}

err() {
    echo "configure: error: $1"
    exit 1
}

run() {
    msg "$@"
    "$@"
}

need_ok() {
    if [ $? -ne 0 ]
    then
        err "$1"
    fi
}

need_cmd() {
    if command -v $1 >/dev/null 2>&1
    then msg "found program '$1'"
    else err "program '$1' is missing, please install it"
    fi
}

make_dir() {
    if [ ! -d $1 ]
    then
        run mkdir -p $1
    fi
}

copy_if_changed() {
    if cmp -s $1 $2
    then
        msg "leaving $2 unchanged"
    else
        run cp -f $1 $2
        chmod u-w $2 # make copied artifact read-only
    fi
}

move_if_changed() {
    if cmp -s $1 $2
    then
        msg "leaving $2 unchanged"
    else
        run mv -f $1 $2
        chmod u-w $2 # make moved artifact read-only
    fi
}

putvar() {
    local T
    eval T=\$$1
    eval TLEN=\${#$1}
    if [ $TLEN -gt 35 ]
    then
        printf "configure: %-20s := %.35s ...\n" $1 "$T"
    else
        printf "configure: %-20s := %s %s\n" $1 "$T" "$2"
    fi
    printf "%-20s := %s\n" $1 "$T" >>config.tmp
}

putpathvar() {
    local T
    eval T=\$$1
    eval TLEN=\${#$1}
    if [ $TLEN -gt 35 ]
    then
        printf "configure: %-20s := %.35s ...\n" $1 "$T"
    else
        printf "configure: %-20s := %s %s\n" $1 "$T" "$2"
    fi
    if [ -z "$T" ]
    then
        printf "%-20s := \n" $1 >>config.tmp
    else
        printf "%-20s := \"%s\"\n" $1 "$T" >>config.tmp
    fi
}

probe() {
    local V=$1
    shift
    local P
    local T
    for P
    do
        T=$(command -v $P 2>&1)
        if [ $? -eq 0 ]
        then
            VER0=$($P --version 2>/dev/null \
                |  grep -o '[vV]\?[0-9][0-9.][a-z0-9.-]*' | head -1 )
            if [ $? -eq 0 -a "x${VER0}" != "x" ]
            then
              VER="($VER0)"
            else
              VER=""
            fi
            break
        else
            VER=""
            T=""
        fi
    done
    eval $V=\$T
    putpathvar $V "$VER"
}

probe_need() {
    probe $*
    local V=$1
    shift
    eval VV=\$$V
    if [ -z "$VV" ]
    then
        err "$V needed, but unable to find any of: $*"
    fi
}

validate_opt () {
    for arg in $CFG_CONFIGURE_ARGS
    do
        isArgValid=0
        for option in $BOOL_OPTIONS
        do
            if test --disable-$option = $arg
            then
                isArgValid=1
            fi
            if test --enable-$option = $arg
            then
                isArgValid=1
            fi
        done
        for option in $VAL_OPTIONS
        do
            if echo "$arg" | grep -q -- "--$option="
            then
                isArgValid=1
            fi
        done
        if [ "$arg" = "--help" ]
        then
            echo
            echo "No more help available for Configure options,"
            echo "check the Wiki or join our IRC channel"
            break
        else
            if test $isArgValid -eq 0
            then
                err "Option '$arg' is not recognized"
            fi
        fi
    done
}

# `valopt OPTION_NAME DEFAULT DOC` extracts a string-valued option
# from command line, using provided default value for the option if
# not present, and saves it to the generated config.mk.
#
# `valopt_nosave` is much the same, except that it does not save the
# result to config.mk (instead the script should use `putvar` itself
# later on to save it).  `valopt_core` is the core upon which the
# other two are built.

valopt_core() {
    VAL_OPTIONS="$VAL_OPTIONS $2"

    local SAVE=$1
    local OP=$2
    local DEFAULT=$3
    shift
    shift
    shift
    local DOC="$*"
    if [ $HELP -eq 0 ]
    then
        local UOP=$(echo $OP | tr '[:lower:]' '[:upper:]' | tr '\-' '\_')
        local V="CFG_${UOP}"
        local V_PROVIDED="${V}_PROVIDED"
        eval $V="$DEFAULT"
        for arg in $CFG_CONFIGURE_ARGS
        do
            if echo "$arg" | grep -q -- "--$OP="
            then
                val=$(echo "$arg" | cut -f2 -d=)
                eval $V=$val
                eval $V_PROVIDED=1
            fi
        done
        if [ "$SAVE" = "save" ]
        then
            putvar $V
        fi
    else
        if [ -z "$DEFAULT" ]
        then
            DEFAULT="<none>"
        fi
        OP="${OP}=[${DEFAULT}]"
        printf "    --%-30s %s\n" "$OP" "$DOC"
    fi
}

valopt_nosave() {
    valopt_core nosave "$@"
}

valopt() {
    valopt_core save "$@"
}

# `opt OPTION_NAME DEFAULT DOC` extracts a boolean-valued option from
# command line, using the provided default value (0/1) for the option
# if not present, and saves it to the generated config.mk.
#
# `opt_nosave` is much the same, except that it does not save the
# result to config.mk (instead the script should use `putvar` itself
# later on to save it).  `opt_core` is the core upon which the other
# two are built.

opt_core() {
    BOOL_OPTIONS="$BOOL_OPTIONS $2"

    local SAVE=$1
    local OP=$2
    local DEFAULT=$3
    shift
    shift
    shift
    local DOC="$*"
    local FLAG=""

    if [ $DEFAULT -eq 0 ]
    then
        FLAG="enable"
        DEFAULT_FLAG="disable"
    else
        FLAG="disable"
        DEFAULT_FLAG="enable"
        DOC="don't $DOC"
    fi

    if [ $HELP -eq 0 ]
    then
        for arg in $CFG_CONFIGURE_ARGS
        do
            if [ "$arg" = "--${FLAG}-${OP}" ]
            then
                OP=$(echo $OP | tr 'a-z-' 'A-Z_')
                FLAG=$(echo $FLAG | tr 'a-z' 'A-Z')
                local V="CFG_${FLAG}_${OP}"
                local V_PROVIDED="CFG_${FLAG}_${OP}_PROVIDED"
                eval $V=1
                eval $V_PROVIDED=1
                if [ "$SAVE" = "save" ]
                then
                   putvar $V
                fi
            elif [ "$arg" = "--${DEFAULT_FLAG}-${OP}" ]
            then
                OP=$(echo $OP | tr 'a-z-' 'A-Z_')
                DEFAULT_FLAG=$(echo $DEFAULT_FLAG | tr 'a-z' 'A-Z')
                local V_PROVIDED="CFG_${DEFAULT_FLAG}_${OP}_PROVIDED"
                eval $V_PROVIDED=1
            fi
        done
    else
        if [ -n "$META" ]
        then
            OP="$OP=<$META>"
        fi
        printf "    --%-30s %s\n" "$FLAG-$OP" "$DOC"
     fi
}

opt_nosave() {
    opt_core nosave "$@"
}

opt() {
    opt_core save "$@"
}

envopt() {
    local NAME=$1
    local V="CFG_${NAME}"
    eval VV=\$$V

    # If configure didn't set a value already, then check environment.
    #
    # (It is recommended that the configure script always check the
    # environment before setting any values to envopt variables; see
    # e.g.  how CFG_CC is handled, where it first checks `-z "$CC"`,
    # and issues msg if it ends up employing that provided value.)
    if [ -z "$VV" ]
    then
        eval $V=\$$NAME
        eval VV=\$$V
    fi

    # If script or environment provided a value, save it.
    if [ -n "$VV" ]
    then
        putvar $V
    fi
}

enable_if_not_disabled() {
    local OP=$1
    local UOP=$(echo $OP | tr '[:lower:]' '[:upper:]' | tr '\-' '\_')
    local ENAB_V="CFG_ENABLE_$UOP"
    local EXPLICITLY_DISABLED="CFG_DISABLE_${UOP}_PROVIDED"
    eval VV=\$$EXPLICITLY_DISABLED
    if [ -z "$VV" ]; then
        eval $ENAB_V=1
    fi
}

to_gnu_triple() {
    case $1 in
        i686-pc-windows-gnu) echo i686-w64-mingw32 ;;
        x86_64-pc-windows-gnu) echo x86_64-w64-mingw32 ;;
        *) echo $1 ;;
    esac
}

# Prints the absolute path of a directory to stdout
abs_path() {
    local _path="$1"
    # Unset CDPATH because it causes havok: it makes the destination unpredictable
    # and triggers 'cd' to print the path to stdout. Route `cd`'s output to /dev/null
    # for good measure.
    (unset CDPATH && cd "$_path" > /dev/null && pwd)
}

HELP=0
for arg; do
    case "$arg" in
        --help) HELP=1;;
    esac
done

msg "looking for configure programs"
need_cmd cmp
need_cmd mkdir
need_cmd printf
need_cmd cut
need_cmd head
need_cmd grep
need_cmd xargs
need_cmd cp
need_cmd find
need_cmd uname
need_cmd date
need_cmd tr
need_cmd sed
need_cmd file
need_cmd make

CFG_SRC_DIR="$(abs_path $(dirname $0))/"
CFG_SRC_DIR_RELATIVE="$(dirname $0)/"
CFG_BUILD_DIR="$(pwd)/"
CFG_SELF="$0"
CFG_CONFIGURE_ARGS="$@"


case "${CFG_SRC_DIR}" in
    *\ * )
        err "The path to the rust source directory contains spaces, which is not supported"
        ;;
    *)
        ;;
esac


OPTIONS=""
if [ "$HELP" -eq 1 ]
then
    echo
    echo "Usage: $CFG_SELF [options]"
    echo
    echo "Options:"
    echo
else
    msg "recreating config.tmp"
    echo '' >config.tmp

    step_msg "processing $CFG_SELF args"
fi

BOOL_OPTIONS=""
VAL_OPTIONS=""

opt debug 0 "debug mode; disables optimization unless \`--enable-optimize\` given"
opt valgrind 0 "run tests with valgrind (memcheck by default)"
opt helgrind 0 "run tests with helgrind instead of memcheck"
opt valgrind-rpass 1 "run rpass-valgrind tests with valgrind"
opt docs     1 "build standard library documentation"
opt compiler-docs     0 "build compiler documentation"
opt optimize-tests 1 "build tests with optimizations"
opt debuginfo-tests 0 "build tests with debugger metadata"
opt quiet-tests 0 "enable quieter output when running tests"
opt libcpp 1 "build llvm with libc++ instead of libstdc++ when using clang"
opt llvm-assertions 0 "build LLVM with assertions"
opt debug-assertions 0 "build with debugging assertions"
opt fast-make 0 "use .gitmodules as timestamp for submodule deps"
opt ccache 0 "invoke gcc/clang via ccache to reuse object files between builds"
opt sccache 0 "invoke gcc/clang via sccache to reuse object files between builds"
opt local-rust 0 "use an installed rustc rather than downloading a snapshot"
opt local-rebuild 0 "assume local-rust matches the current version, for rebuilds; implies local-rust, and is implied if local-rust already matches the current version"
opt llvm-static-stdcpp 0 "statically link to libstdc++ for LLVM"
opt llvm-link-shared 0 "prefer shared linking to LLVM (llvm-config --link-shared)"
opt rpath 1 "build rpaths into rustc itself"
opt stage0-landing-pads 1 "enable landing pads during bootstrap with stage0"
# This is used by the automation to produce single-target nightlies
opt dist-host-only 0 "only install bins for the host architecture"
opt inject-std-version 1 "inject the current compiler version of libstd into programs"
opt llvm-version-check 1 "check if the LLVM version is supported, build anyway"
opt codegen-tests 1 "run the src/test/codegen tests"
opt option-checking 1 "complain about unrecognized options in this configure script"
opt ninja 0 "build LLVM using the Ninja generator (for MSVC, requires building in the correct environment)"
opt locked-deps 0 "force Cargo.lock to be up to date"
opt vendor 0 "enable usage of vendored Rust crates"
opt sanitizers 0 "build the sanitizer runtimes (asan, lsan, msan, tsan)"
opt dist-src 1 "when building tarballs enables building a source tarball"
opt cargo-openssl-static 0 "static openssl in cargo"
opt profiler 0 "build the profiler runtime"

# Optimization and debugging options. These may be overridden by the release channel, etc.
opt_nosave optimize 1 "build optimized rust code"
opt_nosave optimize-cxx 1 "build optimized C++ code"
opt_nosave optimize-llvm 1 "build optimized LLVM"
opt_nosave llvm-assertions 0 "build LLVM with assertions"
opt_nosave debug-assertions 0 "build with debugging assertions"
opt_nosave llvm-release-debuginfo 0 "build LLVM with debugger metadata"
opt_nosave debuginfo 0 "build with debugger metadata"
opt_nosave debuginfo-lines 0 "build with line number debugger metadata"
opt_nosave debuginfo-only-std 0 "build only libstd with debugging information"
opt_nosave debug-jemalloc 0 "build jemalloc with --enable-debug --enable-fill"

valopt localstatedir "/var/lib" "local state directory"
valopt sysconfdir "/etc" "install system configuration files"

valopt datadir "${CFG_PREFIX}/share" "install data"
valopt infodir "${CFG_PREFIX}/share/info" "install additional info"
valopt llvm-root "" "set LLVM root"
valopt python "" "set path to python"
valopt jemalloc-root "" "set directory where libjemalloc_pic.a is located"
valopt build "" "GNUs ./configure syntax LLVM build triple"
valopt android-cross-path "" "Android NDK standalone path (deprecated)"
valopt i686-linux-android-ndk "" "i686-linux-android NDK standalone path"
valopt arm-linux-androideabi-ndk "" "arm-linux-androideabi NDK standalone path"
valopt armv7-linux-androideabi-ndk "" "armv7-linux-androideabi NDK standalone path"
valopt aarch64-linux-android-ndk "" "aarch64-linux-android NDK standalone path"
valopt x86_64-linux-android-ndk "" "x86_64-linux-android NDK standalone path"
valopt nacl-cross-path  "" "NaCl SDK path (Pepper Canary is recommended). Must be absolute!"
valopt musl-root "/usr/local" "MUSL root installation directory (deprecated)"
valopt musl-root-x86_64 "" "x86_64-unknown-linux-musl install directory"
valopt musl-root-i686 "" "i686-unknown-linux-musl install directory"
valopt musl-root-arm "" "arm-unknown-linux-musleabi install directory"
valopt musl-root-armhf "" "arm-unknown-linux-musleabihf install directory"
valopt musl-root-armv7 "" "armv7-unknown-linux-musleabihf install directory"
valopt extra-filename "" "Additional data that is hashed and passed to the -C extra-filename flag"
valopt qemu-armhf-rootfs "" "rootfs in qemu testing, you probably don't want to use this"
valopt qemu-aarch64-rootfs "" "rootfs in qemu testing, you probably don't want to use this"
valopt experimental-targets "" "experimental LLVM targets to build"

if [ -e ${CFG_SRC_DIR}.git ]
then
    valopt release-channel "dev" "the name of the release channel to build"
else
    # If we have no git directory then we are probably a tarball distribution
    # and should default to stable channel - Issue 28322
    probe CFG_GIT          git
    msg "git: no git directory. Changing default release channel to stable"
    valopt release-channel "stable" "the name of the release channel to build"
fi

# Used on systems where "cc" and "ar" are unavailable
valopt default-linker "cc" "the default linker"
valopt default-ar     "ar" "the default ar"

# Many of these are saved below during the "writing configuration" step
# (others are conditionally saved).
opt_nosave manage-submodules 1 "let the build manage the git submodules"
opt_nosave clang 0 "prefer clang to gcc for building the runtime"
opt_nosave jemalloc 1 "build liballoc with jemalloc"
opt full-bootstrap 0 "build three compilers instead of two"
opt extended 0 "build an extended rust tool set"

valopt_nosave prefix "/usr/local" "set installation prefix"
valopt_nosave local-rust-root "/usr/local" "set prefix for local rust binary"
valopt_nosave host "${CFG_BUILD}" "GNUs ./configure syntax LLVM host triples"
valopt_nosave target "${CFG_HOST}" "GNUs ./configure syntax LLVM target triples"
valopt_nosave mandir "${CFG_PREFIX}/share/man" "install man pages in PATH"
valopt_nosave docdir "${CFG_PREFIX}/share/doc/rust" "install documentation in PATH"
valopt_nosave bindir "${CFG_PREFIX}/bin" "install binaries"

# On Windows this determines root of the subtree for target libraries.
# Host runtime libs always go to 'bin'.
valopt libdir "${CFG_PREFIX}/lib" "install libraries"

case "$CFG_LIBDIR" in
    "$CFG_PREFIX"/*) CAT_INC=2;;
    "$CFG_PREFIX"*)  CAT_INC=1;;
    *)
        err "libdir must begin with the prefix. Use --prefix to set it accordingly.";;
esac

CFG_LIBDIR_RELATIVE=`echo ${CFG_LIBDIR} | cut -c$((${#CFG_PREFIX}+${CAT_INC}))-`

if [ $HELP -eq 1 ]
then
    echo
    exit 0
fi

# Validate Options
if [ -z "$CFG_DISABLE_OPTION_CHECKING" ]
then
    step_msg "validating $CFG_SELF args"
    validate_opt
fi

# Validate the release channel, and configure options
case "$CFG_RELEASE_CHANNEL" in
    nightly )
	msg "overriding settings for $CFG_RELEASE_CHANNEL"
        enable_if_not_disabled llvm-assertions
        # FIXME(stage0) re-enable this on the next stage0 now that #35566 is
        # fixed
        case "$CFG_BUILD" in
          *-pc-windows-gnu)
            ;;
          *)
            enable_if_not_disabled debuginfo-lines
            enable_if_not_disabled debuginfo-only-std
            ;;
        esac

	;;
    beta | stable)
	msg "overriding settings for $CFG_RELEASE_CHANNEL"
        case "$CFG_BUILD" in
          *-pc-windows-gnu)
            ;;
          *)
            enable_if_not_disabled debuginfo-lines
            enable_if_not_disabled debuginfo-only-std
            ;;
        esac
	;;
    dev)
	;;
    *)
        err "release channel must be 'dev', 'nightly', 'beta' or 'stable'"
        ;;
esac

# Adjust perf and debug options for debug mode
if [ -n "$CFG_ENABLE_DEBUG" ]; then
    msg "debug mode enabled, setting performance options"
    if [ -z "$CFG_ENABLE_OPTIMIZE_PROVIDED" ]; then
        msg "optimization not explicitly enabled, disabling optimization"
        CFG_DISABLE_OPTIMIZE=1
        CFG_DISABLE_OPTIMIZE_CXX=1
    fi

    # Set following variables to 1 unless setting already provided
    enable_if_not_disabled debug-assertions
    enable_if_not_disabled debug-jemalloc
    enable_if_not_disabled debuginfo
    enable_if_not_disabled llvm-assertions
fi

# OK, now write the debugging options
if [ -n "$CFG_DISABLE_OPTIMIZE" ]; then putvar CFG_DISABLE_OPTIMIZE; fi
if [ -n "$CFG_DISABLE_OPTIMIZE_CXX" ]; then putvar CFG_DISABLE_OPTIMIZE_CXX; fi
if [ -n "$CFG_DISABLE_OPTIMIZE_LLVM" ]; then putvar CFG_DISABLE_OPTIMIZE_LLVM; fi
if [ -n "$CFG_ENABLE_LLVM_ASSERTIONS" ]; then putvar CFG_ENABLE_LLVM_ASSERTIONS; fi
if [ -n "$CFG_ENABLE_DEBUG_ASSERTIONS" ]; then putvar CFG_ENABLE_DEBUG_ASSERTIONS; fi
if [ -n "$CFG_ENABLE_LLVM_RELEASE_DEBUGINFO" ]; then putvar CFG_ENABLE_LLVM_RELEASE_DEBUGINFO; fi
if [ -n "$CFG_ENABLE_DEBUGINFO" ]; then putvar CFG_ENABLE_DEBUGINFO; fi
if [ -n "$CFG_ENABLE_DEBUGINFO_LINES" ]; then putvar CFG_ENABLE_DEBUGINFO_LINES; fi
if [ -n "$CFG_ENABLE_DEBUGINFO_ONLY_STD" ]; then putvar CFG_ENABLE_DEBUGINFO_ONLY_STD; fi
if [ -n "$CFG_ENABLE_DEBUG_JEMALLOC" ]; then putvar CFG_ENABLE_DEBUG_JEMALLOC; fi

step_msg "looking for build programs"

probe_need CFG_CURL curl
if [ -z "$CFG_PYTHON_PROVIDED" ]; then
    probe_need CFG_PYTHON      python2.7 python2 python
fi

python_version=$($CFG_PYTHON -V 2>&1)
if [ $(echo $python_version | grep -c '^Python 2\.7') -ne 1 ]; then
    err "Found $python_version, but Python 2.7 is required"
fi

# the valgrind rpass tests will fail if you don't have a valgrind, but they're
# only disabled if you opt out.
if [ -z "$CFG_VALGRIND" ]
then
    # If the user has explicitly asked for valgrind tests, then fail
    if [ -n "$CFG_ENABLE_VALGRIND" ] && [ -n "$CFG_ENABLE_VALGRIND_PROVIDED" ]
    then
        err "No valgrind present, but valgrind tests explicitly requested"
    else
        CFG_DISABLE_VALGRIND_RPASS=1
        putvar CFG_DISABLE_VALGRIND_RPASS
    fi
fi

# Do some sanity checks if running on buildbot
# (these env vars are set by rust-buildbot)
if [ -n "$RUST_DIST_SERVER" -a -n "$ALLOW_NONZERO_RLIMIT_CORE" ]; then
   # Frequently the llvm submodule directory is broken by the build
   # being killed
   llvm_lock="${CFG_SRC_DIR}/.git/modules/src/llvm/index.lock"
   if [ -e "$llvm_lock" ]; then
       step_msg "removing $llvm_lock"
       rm -f "$llvm_lock"
   fi
fi

BIN_SUF=
if [ "$CFG_OSTYPE" = "pc-windows-gnu" ] || [ "$CFG_OSTYPE" = "pc-windows-msvc" ]
then
    BIN_SUF=.exe
fi

# --enable-local-rebuild implies --enable-local-rust too
if [ -n "$CFG_ENABLE_LOCAL_REBUILD" ]
then
    if [ -z "$CFG_ENABLE_LOCAL_RUST" ]
    then
        CFG_ENABLE_LOCAL_RUST=1
        putvar CFG_ENABLE_LOCAL_RUST
    fi
fi

if [ -n "$CFG_ENABLE_LOCAL_RUST" ]
then
    system_rustc=$(which rustc)
    if [ -f ${CFG_LOCAL_RUST_ROOT}/bin/rustc${BIN_SUF} ]
    then
        : # everything already configured
    elif [ -n "$system_rustc" ]
    then
        # we assume that rustc is in a /bin directory
        CFG_LOCAL_RUST_ROOT=${system_rustc%/bin/rustc}
    else
        err "no local rust to use"
    fi

    CMD="${CFG_LOCAL_RUST_ROOT}/bin/rustc${BIN_SUF}"
    LRV=`LD_LIBRARY_PATH=${CFG_LOCAL_RUST_ROOT}/lib $CMD --version`
    if [ $? -ne 0 ]
    then
        step_msg "failure while running $CMD --version"
        exit 1
    fi
    step_msg "using rustc at: ${CFG_LOCAL_RUST_ROOT} with version: $LRV"
    putvar CFG_LOCAL_RUST_ROOT
fi

# Same with jemalloc.  save the setting here.
if [ -n "$CFG_DISABLE_JEMALLOC" ]
then
    putvar CFG_DISABLE_JEMALLOC
fi

# All safeguards based on $CFG_ENABLE_CLANG should occur before this
# point in the script; after this point, script logic should inspect
# $CFG_USING_CLANG rather than $CFG_ENABLE_CLANG.

# Set CFG_{CC,CXX,CPP,CFLAGS,CXXFLAGS,LDFLAGS}
envopt CC
envopt CXX
envopt CPP
envopt CFLAGS
envopt CXXFLAGS
envopt LDFLAGS

# a little post-processing of various config values
CFG_PREFIX=${CFG_PREFIX%/}
CFG_MANDIR=${CFG_MANDIR%/}
CFG_DOCDIR=${CFG_DOCDIR%/}
CFG_BINDIR=${CFG_BINDIR%/}
CFG_HOST="$(echo $CFG_HOST | tr ',' ' ')"
CFG_TARGET="$(echo $CFG_TARGET | tr ',' ' ')"

# copy build-triples to host-triples so that builds are a subset of hosts
V_TEMP=""
for i in $CFG_BUILD $CFG_HOST;
do
   echo "$V_TEMP" | grep -qF $i || V_TEMP="$V_TEMP${V_TEMP:+ }$i"
done
CFG_HOST=$V_TEMP

# copy host-triples to target-triples so that hosts are a subset of targets
V_TEMP=""
for i in $CFG_HOST $CFG_TARGET;
do
   echo "$V_TEMP" | grep -qF $i || V_TEMP="$V_TEMP${V_TEMP:+ }$i"
done
CFG_TARGET=$V_TEMP

step_msg "writing configuration"

putvar CFG_SRC_DIR
putvar CFG_SRC_DIR_RELATIVE
putvar CFG_BUILD_DIR
putvar CFG_OSTYPE
putvar CFG_CPUTYPE
putvar CFG_CONFIGURE_ARGS
putvar CFG_PREFIX
putvar CFG_HOST
putvar CFG_TARGET
putvar CFG_LIBDIR_RELATIVE
putvar CFG_DISABLE_MANAGE_SUBMODULES
putvar CFG_AARCH64_LINUX_ANDROID_NDK
putvar CFG_ARM_LINUX_ANDROIDEABI_NDK
putvar CFG_ARMV7_LINUX_ANDROIDEABI_NDK
putvar CFG_I686_LINUX_ANDROID_NDK
putvar CFG_X86_64_LINUX_ANDROID_NDK
putvar CFG_NACL_CROSS_PATH
putvar CFG_MANDIR
putvar CFG_DOCDIR
putvar CFG_BINDIR
putvar CFG_USING_LIBCPP

msg
copy_if_changed ${CFG_SRC_DIR}src/bootstrap/mk/Makefile.in ./Makefile
move_if_changed config.tmp config.mk
rm -f config.tmp
touch config.stamp

if [ -z "$CFG_ENABLE_DEBUG" ]; then
    step_msg "configured in release mode. for development consider --enable-debug"
else
    step_msg "complete"
fi

if [ "$CFG_SRC_DIR" = `pwd` ]; then
    X_PY=x.py
else
    X_PY=${CFG_SRC_DIR_RELATIVE}x.py
fi

msg "run \`python ${X_PY} --help\`"
msg
