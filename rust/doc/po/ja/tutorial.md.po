# Japanese translations for Rust package
# Copyright (C) 2013 The Rust Project Developers
# This file is distributed under the same license as the Rust package.
# Automatically generated, 2013.
#
msgid ""
msgstr ""
"Project-Id-Version: Rust 0.8\n"
"POT-Creation-Date: 2013-08-12 02:06+0900\n"
"PO-Revision-Date: 2013-08-08 22:27+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: UTF-8\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Plain text
#: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4
#: doc/tutorial-borrowed-ptr.md:4 doc/tutorial-ffi.md:4
#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4
msgid "# Introduction"
msgstr "# イントロダクション"

#. type: Plain text
#: doc/rust.md:1277 doc/tutorial.md:2176
msgid ""
"In type-parameterized functions, methods of the supertrait may be called on "
"values of subtrait-bound type parameters.  Refering to the previous example "
"of `trait Circle : Shape`:"
msgstr ""
"型パラメータを持つ関数では、サブトレイトの境界型パラメータの値によりスーパー"
"トレイトのメソッドを呼び出すことになります。前の例の `trait Circle : Shape` "
"を参照してください。"

#. type: Plain text
#: doc/rust.md:1286 doc/tutorial.md:2185
#, no-wrap
msgid ""
"~~~\n"
"# trait Shape { fn area(&self) -> f64; }\n"
"# trait Circle : Shape { fn radius(&self) -> f64; }\n"
"fn radius_times_area<T: Circle>(c: T) -> f64 {\n"
"    // `c` is both a Circle and a Shape\n"
"    c.radius() * c.area()\n"
"}\n"
"~~~\n"
msgstr ""
"~~~\n"
"# trait Shape { fn area(&self) -> f64; }\n"
"# trait Circle : Shape { fn radius(&self) -> f64; }\n"
"fn radius_times_area<T: Circle>(c: T) -> f64 {\n"
"    // `c` は Circle でもあり、Shape でもある\n"
"    c.radius() * c.area()\n"
"}\n"
"~~~\n"

#. type: Plain text
#: doc/rust.md:1288 doc/tutorial.md:2187
msgid "Likewise, supertrait methods may also be called on trait objects."
msgstr ""
"同様に、スーパートレイトのメソッドは、トレイトオブジェクトについても呼び出す"
"ことが可能です。"

#. type: Plain text
#: doc/tutorial.md:2
msgid "% The Rust Language Tutorial"
msgstr "% Rust 言語チュートリアル"

#. type: Plain text
#: doc/tutorial.md:13
msgid ""
"Rust is a programming language with a focus on type safety, memory safety, "
"concurrency and performance. It is intended for writing large-scale, high-"
"performance software that is free from several classes of common errors. "
"Rust has a sophisticated memory model that encourages efficient data "
"structures and safe concurrency patterns, forbidding invalid memory accesses "
"that would otherwise cause segmentation faults. It is statically typed and "
"compiled ahead of time."
msgstr ""
"Rust は、型安全性、メモリ安全性、並列性、パフォーマンスを重視したプログラミン"
"グ言語です。大規模でハイパフォーマンスなソフトウェア作成向きの、C++ 等の言語"
"でよくある誤りを犯しにくい言語仕様になっています。Rust の洗練されたメモリモデ"
"ルでは、効率的なデータ構造や安全な並行計算を実現することが可能であり、セグメ"
"ンテーション違反を引き起こす不正なメモリアクセスは起こりえません。Rust は、静"
"的型付けされた、コンパイル型の言語です。"

#. type: Plain text
#: doc/tutorial.md:17
msgid ""
"As a multi-paradigm language, Rust supports writing code in procedural, "
"functional and object-oriented styles. Some of its pleasant high-level "
"features include:"
msgstr ""
"Rust はマルチパラダイム言語であり、手続き型、関数型、オブジェクト指向型のプロ"
"グラミングをサポートします。Rust には、次のような素敵で高レベルな特徴がありま"
"す。"

#. type: Bullet: '* '
#: doc/tutorial.md:30
msgid ""
"**Type inference.** Type annotations on local variable declarations are "
"optional."
msgstr ""
"**型推論:** ローカル変数の宣言では型注釈 (type annotation) を省略できます。"

#. type: Bullet: '* '
#: doc/tutorial.md:30
msgid ""
"**Safe task-based concurrency.** Rust's lightweight tasks do not share "
"memory, instead communicating through messages."
msgstr ""
"**タスクベースの安全な並行計算:** Rust の軽量タスクはタスク間でメモリを共有す"
"るのではなく、メッセージを介して通信します。"

#. type: Bullet: '* '
#: doc/tutorial.md:30
msgid ""
"**Higher-order functions.** Efficient and flexible closures provide "
"iteration and other control structures"
msgstr ""
"**高階関数:** 効率的で柔軟なクロージャにより、イテレーションやその他の制御構"
"造を実現できます。"

#. type: Bullet: '* '
#: doc/tutorial.md:30
msgid ""
"**Pattern matching and algebraic data types.** Pattern matching on Rust's "
"enumeration types (a more powerful version of C's enums, similar to "
"algebraic data types in functional languages) is a compact and expressive "
"way to encode program logic."
msgstr ""
"**パターンマッチと代数的データ型:** Rust の列挙型 (C の列挙型の強化バージョ"
"ン。関数型言語における代数的データ型のようなもの) のパターンマッチにより、プ"
"ログラムの論理を、コンパクトで表現力豊かに記述することができます。"

#. type: Bullet: '* '
#: doc/tutorial.md:30
msgid ""
"**Polymorphism.** Rust has type-parametric functions and types, type classes "
"and OO-style interfaces."
msgstr ""
"**ポリモーフィズム:** Rust には、型パラメータをもつ関数や型、型クラスとオブ"
"ジェクト指向風のインターフェースがあります。"

#. type: Plain text
#: doc/tutorial.md:32
msgid "## Scope"
msgstr "## 本文書の位置づけ"

#. type: Plain text
#: doc/tutorial.md:38
msgid ""
"This is an introductory tutorial for the Rust programming language. It "
"covers the fundamentals of the language, including the syntax, the type "
"system and memory model, generics, and modules. [Additional tutorials](#what-"
"next) cover specific language features in greater depth."
msgstr ""
"この文章は、Rust プログラミング言語のチュートリアルです。構文、型システムとメ"
"モリモデル、ジェネリクス、モジュールなどの言語の基礎となる部分をカバーしてい"
"ます。 いくつかの言語機能の詳細については、 [その他のチュートリアル](#次のス"
"テップは) を参照してください。"

#. type: Plain text
#: doc/tutorial.md:42
msgid ""
"This tutorial assumes that the reader is already familiar with one or more "
"languages in the C family. Understanding of pointers and general memory "
"management techniques will help."
msgstr ""
"本チュートリアルは、読者がすでに 1 つ以上の C 系統言語 に精通していることを前"
"提としています。本書を理解する上で、ポインタやメモリ管理のテクニックに関する"
"知識が役に立つでしょう。"

#. type: Plain text
#: doc/tutorial.md:44
msgid "## Conventions"
msgstr "## 本書の表記について"

#. type: Plain text
#: doc/tutorial.md:47
msgid ""
"Throughout the tutorial, language keywords and identifiers defined in "
"example code are displayed in `code font`."
msgstr ""
"本チュートリアルでは、言語のキーワードや、サンプルコード中で定義される識別子"
"を `code font` のように示します。"

#. type: Plain text
#: doc/tutorial.md:53
msgid ""
"Code snippets are indented, and also shown in a monospaced font. Not all "
"snippets constitute whole programs. For brevity, we'll often show fragments "
"of programs that don't compile on their own. To try them out, you might have "
"to wrap them in `fn main() { ... }`, and make sure they don't contain "
"references to names that aren't actually defined."
msgstr ""
"コードスニペットは、インデントされ、固定幅フォントで表示されます。いくつかの"
"コードスニペットは、プログラムの一部を抜き出したものになっています。説明を簡"
"潔にするため、それだけではコンパイル不可能なプログラムの断片を掲載することが"
"あります。プログラムの動作を試す際には、全体を `fn main() { ... }` で囲んでく"
"ださい。また、プログラム中で未定義の名前を参照している箇所がないか確認してく"
"ださい。"

#. type: Plain text
#: doc/tutorial.md:57
msgid ""
"> ***Warning:*** Rust is a language under ongoing development. Notes > about "
"potential changes to the language, implementation > deficiencies, and other "
"caveats appear offset in blockquotes."
msgstr ""
"> ***警告:*** Rust は開発途上の言語です。将来予定されている言語への変更や、実"
"装上の不備、その他の注意事項など、 blockquote の段落 (この段落もそうです) に"
"注意してください。"

#. type: Plain text
#: doc/tutorial.md:59
msgid "# Getting started"
msgstr "# はじめに"

#. type: Plain text
#: doc/tutorial.md:63
msgid ""
"The Rust compiler currently must be built from a [tarball], unless you are "
"on Windows, in which case using the [installer][win-exe] is recommended."
msgstr ""
"Windows 以外の環境では、今のところ、Rust のコンパイラは [ソースコード]"
"[tarball] からビルドする必要があります。Windows をお使いの場合は、 [インス"
"トーラー][win-exe] の使用をおすすめします。"

#. type: Plain text
#: doc/tutorial.md:69
msgid ""
"Since the Rust compiler is written in Rust, it must be built by a "
"precompiled \"snapshot\" version of itself (made in an earlier state of "
"development). As such, source builds require a connection to the Internet, "
"to fetch snapshots, and an OS that can execute the available snapshot "
"binaries."
msgstr ""
"Rust のコンパイラは Rust で書かれているため、最新版の少し前のソースからコンパ"
"イルされた「スナップショット」版コンパイラでビルドする必要があります。スナッ"
"プショットを利用してビルドするためには、スナップショットをダウンロードするた"
"めのインターネット接続と、スナップショットバイナリを実行できる OS が必要で"
"す。"

#. type: Plain text
#: doc/tutorial.md:71
msgid "Snapshot binaries are currently built and tested on several platforms:"
msgstr ""
"スナップショットバイナリは、現時点では以下のプラットフォーム向けのものがあり"
"ます。"

#. type: Bullet: '* '
#: doc/tutorial.md:75
msgid "Windows (7, Server 2008 R2), x86 only"
msgstr "Windows (7, Server 2008 R2), x86 のみ"

#. type: Bullet: '* '
#: doc/tutorial.md:75
msgid "Linux (various distributions), x86 and x86-64"
msgstr "Linux (各種ディストリビューション), x86 または x86-64"

#. type: Bullet: '* '
#: doc/tutorial.md:75
msgid "OSX 10.6 (\"Snow Leopard\") or greater, x86 and x86-64"
msgstr "OSX 10.6 (\"Snow Leopard\") 以降, x86 または x86-64"

#. type: Plain text
#: doc/tutorial.md:78
msgid ""
"You may find that other platforms work, but these are our \"tier 1\" "
"supported build environments that are most likely to work."
msgstr ""
"スナップショットは他のプラットフォームでも動作するかもしれませんが、\"tier "
"1\" プラットフォームとしてサポートされているのは上記のみです。"

#. type: Plain text
#: doc/tutorial.md:85
msgid ""
"> ***Note:*** Windows users should read the detailed > \"[getting started]"
"[wiki-start]\" notes on the wiki. Even when using > the binary installer, "
"the Windows build requires a MinGW installation, > the precise details of "
"which are not discussed here. Finally, `rustc` may > need to be [referred to "
"as `rustc.exe`][bug-3319]. It's a bummer, we > know."
msgstr ""
"> ***注意:*** Windows ユーザーは wiki の [getting started][wiki-start] の記事"
"を読んでください。 本書では詳細を説明しませんが、インストーラを利用する場合で"
"も、MinGW のインストールなど、追加の手順が必要です。また、コンパイラは "
"`rustc` ではなく、 [`rustc.exe` として呼び出す必要がある][bug-3319] かもしれ"
"ません。このような制限があることはは、本当に残念です。"

#. type: Plain text
#: doc/tutorial.md:88
msgid ""
"[bug-3319]: https://github.com/mozilla/rust/issues/3319 [wiki-start]: "
"https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust"
msgstr ""
"[bug-3319]: https://github.com/mozilla/rust/issues/3319\n"
"[wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-"
"developing-Rust"

#. type: Plain text
#: doc/tutorial.md:91
msgid ""
"To build from source you will also need the following prerequisite packages:"
msgstr "ソースからビルドするためには、以下のパッケージが必要です。"

#. type: Bullet: '* '
#: doc/tutorial.md:97
msgid "g++ 4.4 or clang++ 3.x"
msgstr "g++ 4.4 または clang++ 3.x"

#. type: Bullet: '* '
#: doc/tutorial.md:97
msgid "python 2.6 or later (but not 3.x)"
msgstr "python 2.6 以降 (ただし、 3.x は除く)"

#. type: Bullet: '* '
#: doc/tutorial.md:97
msgid "perl 5.0 or later"
msgstr "perl 5.0 以降"

#. type: Bullet: '* '
#: doc/tutorial.md:97
msgid "gnu make 3.81 or later"
msgstr "gnu make 3.81 以降"

#. type: Bullet: '* '
#: doc/tutorial.md:97
msgid "curl"
msgstr "curl"

#. type: Plain text
#: doc/tutorial.md:100
msgid ""
"If you've fulfilled those prerequisites, something along these lines should "
"work."
msgstr "上記条件を満たしていれば、以下のような手順でビルド可能なはずです。"

#. type: Plain text
#: doc/tutorial.md:108
msgid ""
"~~~~ {.notrust} $ curl -O http://static.rust-lang.org/dist/rust-0.7.tar.gz $ "
"tar -xzf rust-0.7.tar.gz $ cd rust-0.7 $ ./configure $ make && make install "
"~~~~"
msgstr ""
"~~~~ {.notrust}\n"
"$ curl -O http://static.rust-lang.org/dist/rust-0.7.tar.gz\n"
"$ tar -xzf rust-0.7.tar.gz $ cd rust-0.7 $ ./configure\n"
"$ make && make install\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:114
msgid ""
"You may need to use `sudo make install` if you do not normally have "
"permission to modify the destination directory. The install locations can be "
"adjusted by passing a `--prefix` argument to `configure`. Various other "
"options are also supported: pass `--help` for more information on them."
msgstr ""
"インストール先のディレクトリを変更する権限がない場合、 `sudo make install` を"
"実行する必要があるかもしれません。インストール先は `configure` に `--prefix` "
"引数を渡すことで変更できます。`configure` はその他いろいろなオプションをサ"
"ポートしています。詳細については、 `--help` 引数を指定して実行してください。"

#. type: Plain text
#: doc/tutorial.md:120
msgid ""
"When complete, `make install` will place several programs into `/usr/local/"
"bin`: `rustc`, the Rust compiler; `rustdoc`, the API-documentation tool; "
"and `rustpkg`, the Rust package manager."
msgstr ""
"ビルド完了後、`make install` を実行すると、以下のプログラムが `/usr/local/"
"bin` にインストールされます。\n"
"\n"
"* `rustc`: Rust のコンパイラ\n"
"* `rustdoc`: API ドキュメント作成ツール\n"
"* `rustpkg`: Rust のパッケージマネージャ\n"

#. type: Plain text
#: doc/tutorial.md:123
msgid ""
"[tarball]: http://static.rust-lang.org/dist/rust-0.7.tar.gz [win-exe]: "
"http://static.rust-lang.org/dist/rust-0.7-install.exe"
msgstr ""
"[tarball]: http://static.rust-lang.org/dist/rust-0.7.tar.gz\n"
"[win-exe]: http://static.rust-lang.org/dist/rust-0.7-install.exe"

#. type: Plain text
#: doc/tutorial.md:125
msgid "## Compiling your first program"
msgstr "## 最初のプログラム"

#. type: Plain text
#: doc/tutorial.md:128
msgid ""
"Rust program files are, by convention, given the extension `.rs`. Say we "
"have a file `hello.rs` containing this program:"
msgstr ""
"Rust プログラムのファイルの拡張子は、慣例的に `.rs` とされています。以下の内"
"容を持つファイル、`hello.rs` が存在するとします。"

#. type: Plain text
#: doc/tutorial.md:134
#, no-wrap
msgid ""
"~~~~\n"
"fn main() {\n"
"    println(\"hello?\");\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:138
msgid ""
"If the Rust compiler was installed successfully, running `rustc hello.rs` "
"will produce an executable called `hello` (or `hello.exe` on Windows) which, "
"upon running, will likely do exactly what you expect."
msgstr ""
"Rust のコンパイラが正しくインストールされている場合、 `rustc hello.rs` を実行"
"することで、実行ファイル `hello` (Windows の場合 `hello.exe`) を生成すること"
"が可能です。このファイルを実行すれば、予想通りの出力が得られるでしょう。"

#. type: Plain text
#: doc/tutorial.md:143
msgid ""
"The Rust compiler tries to provide useful information when it encounters an "
"error. If you introduce an error into the program (for example, by changing "
"`println` to some nonexistent function), and then compile it, you'll see an "
"error message like this:"
msgstr ""
"コンパイルエラーが発生した場合、Rust コンパイラはエラー解決のための情報を出力"
"します。プログラム中にエラーが含まれる場合 (上記プログラムの `println` を存在"
"しない別の名前に変更した場合など)、コンパイル時に以下のようなエラーメッセージ"
"が出力されます。"

#. type: Plain text
#: doc/tutorial.md:149
#, no-wrap
msgid ""
"~~~~ {.notrust}\n"
"hello.rs:2:4: 2:16 error: unresolved name: print_with_unicorns\n"
"hello.rs:2     print_with_unicorns(\"hello?\");\n"
"               ^~~~~~~~~~~~~~~~~~~~~~~\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:156
msgid ""
"In its simplest form, a Rust program is a `.rs` file with some types and "
"functions defined in it. If it has a `main` function, it can be compiled to "
"an executable. Rust does not allow code that's not a declaration to appear "
"at the top level of the file: all statements must live inside a function.  "
"Rust programs can also be compiled as libraries, and included in other "
"programs."
msgstr ""
"最も単純な Rust プログラムは、いくつかの型や関数が定義された `.rs` ファイルの"
"みからなります。`.rs` ファイルをコンパイルして実行可能ファイルを作成する場"
"合、ファイル中に `main` 関数が含まれている必要があります。Rust プログラムで"
"ファイルのトップレベルに記述可能なのは宣言 (declaration) のみです。ステートメ"
"ント (statement) は、すべて関数内部に記述されます。Rust のプログラムは、他の"
"プログラムから利用するライブラリとしてコンパイルすることも可能です。"

#. type: Plain text
#: doc/tutorial.md:158
msgid "## Using the rust tool"
msgstr "## `rust` コマンドを利用する"

#. type: Plain text
#: doc/tutorial.md:163
msgid ""
"While using `rustc` directly to generate your executables, and then running "
"them manually is a perfectly valid way to test your code, for smaller "
"projects, prototypes, or if you're a beginner, it might be more convenient "
"to use the `rust` tool."
msgstr ""
"作成したプログラムのテストを行うには、`rustc` でコンパイル後、生成されたファ"
"イルを手動で実行する方法だけではなく、 `rust` ツールを利用する方法もありま"
"す。小さなプロジェクトやプロトタイプを作成する場合、もしくはあなたが初心者の"
"場合は、 `rust` ツールによりコンパイルから実行までの一連の流れを簡単に行うこ"
"とができます。"

#. type: Plain text
#: doc/tutorial.md:169
msgid ""
"The `rust` tool provides central access to the other Rust tools, as well as "
"handy shortcuts for directly running source files.  For example, if you have "
"a file `foo.rs` in your current directory, `rust run foo.rs` would attempt "
"to compile it and, if successful, directly run the resulting binary."
msgstr ""
"`rust` ツールには、Rust ツール群を統一的なインターフェースで呼び出す機能だけ"
"でなく、ソースファイルを直接実行する便利なショートカット機能もあります。例え"
"ば、カレントディレクトリにある `foo.rs` を実行しようとする場合、 `rust run "
"foo.rs` を実行することで、コンパイルから、コンパイル成功後に生成されるバイナ"
"リの実行までを自動的に行なってくれます。"

#. type: Plain text
#: doc/tutorial.md:172
msgid ""
"To get a list of all available commands, simply call `rust` without any "
"argument."
msgstr ""
"実行可能なコマンドを調べるためには、引数を与えず `rust` コマンドを実行してく"
"ださい。"

#. type: Plain text
#: doc/tutorial.md:174
msgid "## Editing Rust code"
msgstr "## Rust のコードを編集する"

#. type: Plain text
#: doc/tutorial.md:184
msgid ""
"There are vim highlighting and indentation scripts in the Rust source "
"distribution under `src/etc/vim/`. There is an emacs mode under `src/etc/"
"emacs/` called `rust-mode`, but do read the instructions included in that "
"directory. In particular, if you are running emacs 24, then using emacs's "
"internal package manager to install `rust-mode` is the easiest way to keep "
"it up to date. There is also a package for Sublime Text 2, available both "
"[standalone][sublime] and through [Sublime Package Control][sublime-pkg], "
"and support for Kate under `src/etc/kate`."
msgstr ""
"vim のハイライトとインデント用スクリプトは、Rust のソースツリーの `src/etc/"
"vim` 以下にあります。emacs の Rust 編集用モードの `rust-mode` は、 `src/etc/"
"emacs/` 以下にありますが、当該ディレクトリに配置されているインストール手順に"
"従って操作する必要があります。 emacs 24 以降をご利用の場合、 emacs 組み込みの"
"パッケージマネージャで `rust-mode` をインストールするのが最もお手軽です。"
"Sublime Text 2 用のパッケージは、[スタンドアロン版][sublime] と、[Sublime "
"Package Control][sublime-pkg] 版の2つがあります。Kate 向けパッケージは `src/"
"etc/kate` 以下です。"

#. type: Plain text
#: doc/tutorial.md:188
msgid ""
"There is ctags support via `src/etc/ctags.rust`, but many other tools and "
"editors are not yet supported. If you end up writing a Rust mode for your "
"favorite editor, let us know so that we can link to it."
msgstr ""
"ctags は `src/etc/ctags.rust` を利用することで rust をサポートします。多くの"
"ツールやエディタは rust をサポートしていません。もしあなたがお気に入りのエ"
"ディタ向けのRust モードを作成した場合、リンクを貼りたいのでお知らせください。"

#. type: Plain text
#: doc/tutorial.md:191
msgid ""
"[sublime]: http://github.com/dbp/sublime-rust [sublime-pkg]: http://wbond."
"net/sublime_packages/package_control"
msgstr ""
"[sublime]: http://github.com/dbp/sublime-rust\n"
"[sublime-pkg]: http://wbond.net/sublime_packages/package_control"

#. type: Plain text
#: doc/tutorial.md:193
msgid "# Syntax basics"
msgstr "# 基本的な構文"

#. type: Plain text
#: doc/tutorial.md:201
msgid ""
"Assuming you've programmed in any C-family language (C++, Java, JavaScript, "
"C#, or PHP), Rust will feel familiar. Code is arranged in blocks delineated "
"by curly braces; there are control structures for branching and looping, "
"like the familiar `if` and `while`; function calls are written `myfunc(arg1, "
"arg2)`; operators are written the same and mostly have the same precedence "
"as in C; comments are again like C; module names are separated with double-"
"colon (`::`) as with C++."
msgstr ""
"あなたが C 系統の言語 (C++, Java, JavaScript, C# または PHP) でプログラミング"
"したことがあれば、Rust の構文には馴染みがあるでしょう。コードは波括弧で区切ら"
"れたブロックの中に配置され、分岐やループのための制御構文はお馴染みの `if` と "
"`while` で、関数呼び出しは `myfunc(arg1, arg2)` と書け、演算子は C のものと同"
"じで、優先順位もほとんど同じで、コメントもまた C と同じで、モジュール名のセパ"
"レータは C++ と同様 2つのコロン (`::`) です。"

#. type: Plain text
#: doc/tutorial.md:206
msgid ""
"The main surface difference to be aware of is that the condition at the head "
"of control structures like `if` and `while` does not require parentheses, "
"while their bodies *must* be wrapped in braces. Single-statement, unbraced "
"bodies are not allowed."
msgstr ""
"表記上の違いで注目すべき点は、`if` や `while` などの制御構造の先頭にある条件"
"句を丸括弧で囲う必要がない点と、ボディ部をで波括弧で **囲わなければならない"
"** という点です。ボディ部が単一のステートメントであっても、波括弧を省略するこ"
"とはできません。"

#. type: Plain text
#: doc/tutorial.md:219
#, no-wrap
msgid ""
"~~~~\n"
"# mod universe { pub fn recalibrate() -> bool { true } }\n"
"fn main() {\n"
"    /* A simple loop */\n"
"    loop {\n"
"        // A tricky calculation\n"
"        if universe::recalibrate() {\n"
"            return;\n"
"        }\n"
"    }\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~\n"
"# mod universe { pub fn recalibrate() -> bool { true } }\n"
"fn main() {\n"
"    /* シンプルなループ */\n"
"    loop {\n"
"        // 複雑な計算\n"
"        if universe::recalibrate() {\n"
"            return;\n"
"        }\n"
"    }\n"
"}\n"
"~~~~\n"

#. type: Plain text
#: doc/tutorial.md:223
msgid ""
"The `let` keyword introduces a local variable. Variables are immutable by "
"default. To introduce a local variable that you can re-assign later, use "
"`let mut` instead."
msgstr ""
"`let` キーワードにより、ローカル変数を定義します。変数はデフォルトでは "
"immutable (変更不可) です。再代入可能なローカル変数を定義するためには、`let "
"mut` を用います。"

#. type: Plain text
#: doc/tutorial.md:227
msgid "~~~~ let hi = \"hi\"; let mut count = 0;"
msgstr ""
"~~~~\n"
" let hi = \"hi\";\n"
" let mut count = 0;"

#. type: Plain text
#: doc/tutorial.md:233
#, no-wrap
msgid ""
"while count < 10 {\n"
"    println(fmt!(\"count: %?\", count));\n"
"    count += 1;\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:237
msgid ""
"Although Rust can almost always infer the types of local variables, you can "
"specify a variable's type by following it with a colon, then the type name. "
"Static items, on the other hand, always require a type annotation."
msgstr ""
"Rust は、ほぼすべてのローカル変数の型を推論してくれますが、コロンの後に続けて"
"型名を書くことで、明示的に変数の型を指定することもできます。一方、静的な項目 "
"(static item) には、常に型注釈を指定しなければなりません。"

#. type: Plain text
#: doc/tutorial.md:243
msgid ""
"~~~~ static MONSTER_FACTOR: f64 = 57.8; let monster_size = MONSTER_FACTOR "
"* 10.0; let monster_size: int = 50; ~~~~"
msgstr ""
"~~~~\n"
"static MONSTER_FACTOR: f64 = 57.8;\n"
"let monster_size = MONSTER_FACTOR * 10.0;\n"
"let monster_size: int = 50;\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:252
msgid ""
"Local variables may shadow earlier declarations, as in the previous example: "
"`monster_size` was first declared as a `f64`, and then a second "
"`monster_size` was declared as an `int`. If you were to actually compile "
"this example, though, the compiler would determine that the first "
"`monster_size` is unused and issue a warning (because this situation is "
"likely to indicate a programmer error). For occasions where unused variables "
"are intentional, their names may be prefixed with an underscore to silence "
"the warning, like `let _monster_size = 50;`."
msgstr ""
"ローカル変数は、先行する宣言を隠すことがあります。先の例では、1つ目の "
"`monster_size` は `f64` として宣言され、2つ目の `monster_size` は `int` と"
"して宣言されています。このプログラムをコンパイルした場合、「1つ目の "
"`monster_size` は未使用である」という警告メッセージが出力されます (プログラマ"
"が何らかの誤りを犯している可能性があるため)。未使用変数の存在が意図的なもので"
"あった場合、未使用変数名の先頭にアンダースコアをつけることで、警告を抑制でき"
"ます (`let _monster_size = 50;`)。"

#. type: Plain text
#: doc/tutorial.md:258
msgid ""
"Rust identifiers start with an alphabetic character or an underscore, and "
"after that may contain any sequence of alphabetic characters, numbers, or "
"underscores. The preferred style is to write function, variable, and module "
"names with lowercase letters, using underscores where they help readability, "
"while writing types in camel case."
msgstr ""
"Rust の識別子 (identifier) は、アルファベット、数字、またはアンダースコア "
"(`_`) から構成されますが、先頭の文字は数字以外でなければなりません。関数名、"
"変数名、モジュール名はスネークケース (アルファベットは小文字にし、単語間をア"
"ンダースコアで区切る) にし、型の名前はアッパーキャメルケースにすることが推奨"
"されています。"

#. type: Plain text
#: doc/tutorial.md:263
#, no-wrap
msgid ""
"~~~\n"
"let my_variable = 100;\n"
"type MyType = int;     // primitive types are _not_ camel case\n"
"~~~\n"
msgstr ""
"~~~\n"
"let my_variable = 100;\n"
"type MyType = int;     // プリミティブ型はキャメルケース __ではない__\n"
"~~~\n"

#. type: Plain text
#: doc/tutorial.md:265
msgid "## Expressions and semicolons"
msgstr "## 式とセミコロン"

#. type: Plain text
#: doc/tutorial.md:271
msgid ""
"Though it isn't apparent in all code, there is a fundamental difference "
"between Rust's syntax and predecessors like C.  Many constructs that are "
"statements in C are expressions in Rust, allowing code to be more concise. "
"For example, you might write a piece of code like this:"
msgstr ""
"コードの見た目から明らかではないのですが、Rust の構文と、C 等の先行言語の構文"
"との間の根本的な違いがとして、C ではステートメントとして扱われる多くの構文要"
"素が、Rust では式として扱われるという点があります。Rust のこの特徴により、"
"コードをより簡潔に書くことができるようになります。例えば、C 系言語では以下の"
"ようにコードを書きますが、"

#. type: Plain text
#: doc/tutorial.md:283
#, no-wrap
msgid ""
"~~~~\n"
"# let item = \"salad\";\n"
"let price;\n"
"if item == \"salad\" {\n"
"    price = 3.50;\n"
"} else if item == \"muffin\" {\n"
"    price = 2.25;\n"
"} else {\n"
"    price = 2.00;\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:285
msgid "But, in Rust, you don't have to repeat the name `price`:"
msgstr "Rust では、変数名 `price` を繰り返し書く必要はありません。"

#. type: Plain text
#: doc/tutorial.md:297
#, no-wrap
msgid ""
"~~~~\n"
"# let item = \"salad\";\n"
"let price =\n"
"    if item == \"salad\" {\n"
"        3.50\n"
"    } else if item == \"muffin\" {\n"
"        2.25\n"
"    } else {\n"
"        2.00\n"
"    };\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:303
msgid ""
"Both pieces of code are exactly equivalent: they assign a value to `price` "
"depending on the condition that holds. Note that there are no semicolons in "
"the blocks of the second snippet. This is important: the lack of a semicolon "
"after the last statement in a braced block gives the whole block the value "
"of that last expression."
msgstr ""
"どちらのコードも、全く等価です。`price` には、条件 (この場合は `item` の値) "
"に対応した値が代入されます。2つ目のコード例では、ブロックの中にセミコロンが書"
"かれていないことに注意してください。ブロック内の最後のステートメントの後にセ"
"ミコロンがない場合、**ブロック全体の値 (ブロックを式として評価した際の値) は"
"最後の式の値になります**。"

#. type: Plain text
#: doc/tutorial.md:309
msgid ""
"Put another way, the semicolon in Rust *ignores the value of an "
"expression*.  Thus, if the branches of the `if` had looked like `{ 4; }`, "
"the above example would simply assign `()` (nil or void) to `price`. But "
"without the semicolon, each branch has a different value, and `price` gets "
"the value of the branch that was taken."
msgstr ""
"言い換えると、Rust では、セミコロンにより **式の値が無視されます。** したがっ"
"て、上記の例で `if` のすべての節 (branch) が `{ 4; }` のように書かれていたと"
"したら、`price` には単に `()` (nil または void の意) が代入されます。しかし、"
"式にセミコロンが付けられていない場合、各節はそれぞれ異なる値を持ち、 `price` "
"には節のうち実行されたものの値が代入されます。"

#. type: Plain text
#: doc/tutorial.md:314
msgid ""
"In short, everything that's not a declaration (declarations are `let` for "
"variables; `fn` for functions; and any top-level named items such as [traits]"
"(#traits), [enum types](#enums), and static items) is an expression, "
"including function bodies."
msgstr ""
"まとめると、宣言 (変数の `let`, 関数の `fn`, [トレイト](#トレイト) や [列挙"
"型](#列挙型)、静的な項目などの、トップレベルで名前を持つ項目) でないものは、"
"すべてが式となります。関数のボディ部も式です。"

#. type: Plain text
#: doc/tutorial.md:322
#, no-wrap
msgid ""
"~~~~\n"
"fn is_four(x: int) -> bool {\n"
"   // No need for a return statement. The result of the expression\n"
"   // is used as the return value.\n"
"   x == 4\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~\n"
"fn is_four(x: int) -> bool {\n"
"   // return ステートメントは省略可能。最後の式の値が戻り値となる。\n"
"   x == 4\n"
"}\n"
"~~~~\n"

#. type: Plain text
#: doc/tutorial.md:324
msgid "## Primitive types and literals"
msgstr "## プリミティブ型とリテラル"

#. type: Plain text
#: doc/tutorial.md:331
msgid ""
"There are general signed and unsigned integer types, `int` and `uint`, as "
"well as 8-, 16-, 32-, and 64-bit variants, `i8`, `u16`, etc.  Integers can "
"be written in decimal (`144`), hexadecimal (`0x90`), octal (`0o70`), or binary "
"(`0b10010000`) base. Each integral type has a corresponding literal suffix "
"that can be used to indicate the type of a literal: `i` for `int`, `u` for "
"`uint`, `i8` for the `i8` type."
msgstr ""
"Rust には、他の言語と同様、符号付き整数の `int` と、符号なし整数の `uint` が"
"あります。同様に、8 または 16, 32, 64 ビット幅の `i8`, `u16` などもあります。"
"整数リテラルは、10進数 (`144`)、16進数 (`0x90`)、または2進数 (`0b10010000`) "
"の表記が可能です。整数リテラルの型を表すための、各整数型に対応したサフィック"
"スがあります。例えば、`i` は `int` 型、`u` は `uint` 型、`i8` は `i8` 型に対"
"応します。"

#. type: Plain text
#: doc/tutorial.md:337
msgid ""
"In the absence of an integer literal suffix, Rust will infer the integer "
"type based on type annotations and function signatures in the surrounding "
"program. In the absence of any type information at all, Rust will assume "
"that an unsuffixed integer literal has type `int`."
msgstr ""
"サフィックスが省略されている整数リテラルの型は、周囲にある型アノテーションや"
"関数のシグネチャから推論されます。型について一切情報が得られない場合、サ"
"フィックスなしの整数リテラルは `int` 型だとみなされます。"

#. type: Plain text
#: doc/tutorial.md:344
#, no-wrap
msgid ""
"~~~~\n"
"let a = 1;       // a is an int\n"
"let b = 10i;     // b is an int, due to the 'i' suffix\n"
"let c = 100u;    // c is a uint\n"
"let d = 1000i32; // d is an i32\n"
"~~~~\n"
msgstr ""
"~~~~\n"
"let a = 1;       // a は int\n"
"let b = 10i;     // b は int (サフィックス 'i' がある)\n"
"let c = 100u;    // c は uint\n"
"let d = 1000i32; // d は i32\n"
"~~~~\n"

#. type: Plain text
#: doc/tutorial.md:349
msgid ""
"There are two floating-point types: `f32`, and `f64`. Floating-"
"point numbers are written `0.0`, `1e6`, or `2.1e-4`. Like integers, "
"floating-point literals are inferred to the correct type. Suffixes "
"`f32`, and `f64` can be used to create literals of a specific type."
msgstr ""
"浮動小数型は、 `f32`, `f64` の2種類があります。浮動小数リテラルは "
"`0.0` や、 `1e6`、 `2.1e-4` といった表記が可能です。整数と同じく、サフィック"
"スが省略された浮動小数リテラルは型推論されます。浮動小数のサフィックスは "
"`f32`、`f64` の3種類で、リテラルの末尾につけることで、対応する型の値を作"
"り出すことができます。"

#. type: Plain text
#: doc/tutorial.md:351
msgid "The keywords `true` and `false` produce literals of type `bool`."
msgstr "`true` キーワードと `false` キーワードは、`bool` 型のリテラルです。"

#. type: Plain text
#: doc/tutorial.md:358
msgid ""
"Characters, the `char` type, are four-byte Unicode codepoints, whose "
"literals are written between single quotes, as in `'x'`.  Just like C, Rust "
"understands a number of character escapes, using the backslash character, "
"such as `\\n`, `\\r`, and `\\t`. String literals, written between double "
"quotes, allow the same escape sequences.  More on strings [later](#vectors-"
"and-strings)."
msgstr ""
"文字は `char` 型で表され、4バイトの Unicode コードポイントに対応しています。"
"`'x'` のように、文字をシングルクオートで囲んだものが文字リテラルです。C と同"
"様、 Rust もバックスラッシュを使ったエスケープシーケンス (`\\n`, `\\r`, `"
"\\t`) に対応しています。文字列リテラル (複数の文字をダブルクオートで囲ったも"
"の) も同じエスケープシーケンスに対応しています。詳細は [ベクタと文字列](#ベク"
"タと文字列) の章で述べます。"

#. type: Plain text
#: doc/tutorial.md:360
msgid "The nil type, written `()`, has a single value, also written `()`."
msgstr ""
"nil 型は `()` と表記されます。 nil 型の唯一の値も `()` と表記されます。"

#. type: Plain text
#: doc/tutorial.md:362
msgid "## Operators"
msgstr "## 演算子"

#. type: Plain text
#: doc/tutorial.md:367
msgid ""
"Rust's set of operators contains very few surprises. Arithmetic is done with "
"`*`, `/`, `%`, `+`, and `-` (multiply, quotient, remainder, add, and "
"subtract). `-` is also a unary prefix operator that negates numbers. As in "
"C, the bitwise operators `>>`, `<<`, `&`, `|`, and `^` are also supported."
msgstr ""
"Rust の演算子には、あまり変わったものはありません。算術演算子は `*` (乗算)、 "
"`/` (除算), `%` (剰余), `+` (加算), `-` (減算) です。`-` は数の符号を反転する"
"単行演算子でもあります。C と同様、ビット演算子 `>>`, `<<`, `&`, `|`, `^` もサ"
"ポートされています。"

#. type: Plain text
#: doc/tutorial.md:370
msgid ""
"Note that, if applied to an integer value, `!` flips all the bits (like `~` "
"in C)."
msgstr ""
"整数型に対して `!` 演算子を適用すると、ビット単位での反転操作 (C の `~` と同"
"じ動作) が行われることに注意してください。"

#. type: Plain text
#: doc/tutorial.md:374
msgid ""
"The comparison operators are the traditional `==`, `!=`, `<`, `>`, `<=`, and "
"`>=`. Short-circuiting (lazy) boolean operators are written `&&` (and) and "
"`||` (or)."
msgstr ""
"比較演算子は、従来の言語と同じく、`==`, `!=`, `<`, `>`, `<=`, `>=` です。短絡"
"評価 (遅延評価) されるブール演算子は、 `&&` (and 演算) と `||` (or 演算) があ"
"ります。"

#. type: Plain text
#: doc/tutorial.md:379
msgid ""
"For type casting, Rust uses the binary `as` operator.  It takes an "
"expression on the left side and a type on the right side and will, if a "
"meaningful conversion exists, convert the result of the expression to the "
"given type."
msgstr ""
"Rust では、型のキャストには二項演算子 `as` を使います。`as` 演算子は、左辺に"
"式、右辺に型を取り、意味のある変換が可能な場合に限り、式の評価結果を指定され"
"た型に変換します。"

#. type: Plain text
#: doc/tutorial.md:385
msgid ""
"~~~~ let x: f64 = 4.0; let y: uint = x as uint; assert!(y == 4u); ~~~~"
msgstr ""
"~~~~\n"
"let x: f64 = 4.0;\n"
"let y: uint = x as uint;\n"
"assert!(y == 4u);\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:387
msgid "## Syntax extensions"
msgstr "## 構文拡張"

#. type: Plain text
#: doc/tutorial.md:394
#, no-wrap
msgid ""
"*Syntax extensions* are special forms that are not built into the language,\n"
"but are instead provided by the libraries. To make it clear to the reader when\n"
"a name refers to a syntax extension, the names of all syntax extensions end\n"
"with `!`. The standard library defines a few syntax extensions, the most\n"
"useful of which is `fmt!`, a `sprintf`-style text formatter that you will\n"
"often see in examples.\n"
msgstr "**構文拡張** *(Syntax extensions)* は言語組み込みではなく、ライブラリにより提供される特殊形式 (スペシャルフォーム) です。プログラム中に構文拡張が登場したことを外見上明確にするため、構文拡張の名前には末尾に `!` をつけますなければなりません。標準ライブラリではいくつかの構文拡張が定義されていますが、その中でも最も有用なのは `fmt!` です。`fmt!` は `sprintf`スタイルの書式整形を行うもので、後のコード例の中でも何度か見かけることになるでしょう。\n"

#. type: Plain text
#: doc/tutorial.md:398
msgid ""
"`fmt!` supports most of the directives that [printf][pf] supports, but "
"unlike printf, will give you a compile-time error when the types of the "
"directives don't match the types of the arguments."
msgstr ""
"`fmt!` は、[`printf`][pf] がサポートするほとんどのディレクティブ (フォーマッ"
"ト指定子) をサポートしますが、`printf` とは異なり、ディレクティブと引数の型が"
"一致しない場合はコンパイルエラーとなります。"

#. type: Plain text
#: doc/tutorial.md:401
msgid "~~~~ # let mystery_object = ();"
msgstr ""
"~~~~\n"
"# let mystery_object = ();"

#. type: Plain text
#: doc/tutorial.md:403
msgid "println(fmt!(\"%s is %d\", \"the answer\", 43));"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:407
msgid ""
"// %? will conveniently print any type println(fmt!(\"what is this thing: %?"
"\", mystery_object)); ~~~~"
msgstr ""
"// %? は任意の型を表示できる便利なディレクティブです\n"
"println(fmt!(\"what is this thing: %?\", mystery_object));\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:409
msgid "[pf]: http://en.cppreference.com/w/cpp/io/c/fprintf"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:411
msgid ""
"You can define your own syntax extensions with the macro system. For "
"details, see the [macro tutorial][macros]."
msgstr ""
"マクロシステムを利用すれば、独自に構文拡張を定義することも可能です。詳細は "
"[マクロチュートリアル][macros] を参照してください。"

#. type: Plain text
#: doc/tutorial.md:413
msgid "# Control structures"
msgstr "# 制御構造"

#. type: Plain text
#: doc/tutorial.md:415
msgid "## Conditionals"
msgstr "## 条件式"

#. type: Plain text
#: doc/tutorial.md:419
msgid ""
"We've seen `if` expressions a few times already. To recap, braces are "
"compulsory, an `if` can have an optional `else` clause, and multiple `if`/"
"`else` constructs can be chained together:"
msgstr ""
"`if` 式は既に何度か登場しています。これまでの説明の要点をまとめると、波括弧は"
"省略不可であり、`if` 式には省略可能な `else` 句があり、複数個の `if`/`else` "
"構文は互いに連鎖できる、ということでした。"

#. type: Plain text
#: doc/tutorial.md:429
#, no-wrap
msgid ""
"~~~~\n"
"if false {\n"
"    println(\"that's odd\");\n"
"} else if true {\n"
"    println(\"right\");\n"
"} else {\n"
"    println(\"neither true nor false\");\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:434
msgid ""
"The condition given to an `if` construct *must* be of type `bool` (no "
"implicit conversion happens). If the arms are blocks that have a value, this "
"value must be of the same type for every arm in which control reaches the "
"end of the block:"
msgstr ""
"`if` 構文の条件式は `bool` 型ででなければなりません (暗黙的な型変換は行われま"
"せん)。同一の `if` 構文に属する arm のうち、制御がブロックの末尾まで到達し得"
"るものは、すべて同じ型の値でなければなりません。"

#. type: Plain text
#: doc/tutorial.md:442
#, no-wrap
msgid ""
"~~~~\n"
"fn signum(x: int) -> int {\n"
"    if x < 0 { -1 }\n"
"    else if x > 0 { 1 }\n"
"    else { return 0 }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:444
msgid "## Pattern matching"
msgstr "## パターンマッチ"

#. type: Plain text
#: doc/tutorial.md:450
msgid ""
"Rust's `match` construct is a generalized, cleaned-up version of C's "
"`switch` construct. You provide it with a value and a number of *arms*, each "
"labelled with a pattern, and the code compares the value against each "
"pattern in order until one matches. The matching pattern executes its "
"corresponding arm."
msgstr ""
"Rust の `match` 構文は、C の `switch` 構文を整理・一般化したものです。"
"`match` 構文は、パターンマッチの対象となる値と、いくつかの、 **arm**  (**訳"
"注:** 分岐条件と、条件を満たした場合に実行される式の組のこと。`match` の場合"
"はパターンと式の組) から構成されます。`match` 構文では、指定された値とパター"
"ンの比較をコード内で記述された順番通りに行います。比較の結果、値とパターンが"
"マッチした場合、対応する式が実行されます。マッチしたパターンの後に現れるパ"
"ターンとの比較は行われません。"

#. type: Plain text
#: doc/tutorial.md:460
#, no-wrap
msgid ""
"~~~~\n"
"# let my_number = 1;\n"
"match my_number {\n"
"  0     => println(\"zero\"),\n"
"  1 | 2 => println(\"one or two\"),\n"
"  3..10 => println(\"three to ten\"),\n"
"  _     => println(\"something else\")\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:464
msgid ""
"Unlike in C, there is no \"falling through\" between arms: only one arm "
"executes, and it doesn't have to explicitly `break` out of the construct "
"when it is finished."
msgstr ""
"C とは異なり、Rust では arm 間での「フォールスルー」はないため、1つの arm の"
"みが実行されます。 そのため、 `match` 構文から抜ける箇所を `break` により明示"
"する必要はありません。"

#. type: Plain text
#: doc/tutorial.md:474
msgid ""
"A `match` arm consists of a *pattern*, then an arrow `=>`, followed by an "
"*action* (expression). Literals are valid patterns and match only their own "
"value. A single arm may match multiple different patterns by combining them "
"with the pipe operator (`|`), so long as every pattern binds the same set of "
"variables. Ranges of numeric literal patterns can be expressed with two "
"dots, as in `M..N`. The underscore (`_`) is a wildcard pattern that matches "
"any single value. The asterisk (`*`)  is a different wildcard that can match "
"one or more fields in an `enum` variant."
msgstr ""
"`match` の arm は、 **パターン** および矢印 `=>` と、それらに続く **アクショ"
"ン** (式) から構成されます。リテラルはパターンとして利用可能で、リテラル自身"
"の値のみとマッチするパターンを意味します。複数のパターンをパイプ演算子 (`|`) "
"で結合させることで、複数の異なるパターンにマッチする単一の arm を作ることがで"
"きます。ただし、変数の束縛を行うパターンをパイプ演算子で結合する場合は、すべ"
"てのパータンで束縛する変数の名前・数が一致している必要があります (**訳注:** "
"変数の束縛については、本節の後半で説明します)。指定した範囲に含まれる任意の数"
"値にマッチするパターンは、2つのドットで `M..N` のように表記します。アンダース"
"コア (`_`) は任意の値1つにマッチするワイルドカードパターンです。アスタリスク "
"(`*`) は任意の値をもつ、`enum` バリアントの複数のフィールドにマッチする、ワイ"
"ルドカードです (**訳注** `enum` については、[列挙型](#列挙型) の節で説明しま"
"す)。"

#. type: Plain text
#: doc/tutorial.md:479
msgid ""
"The patterns in a match arm are followed by a fat arrow, `=>`, then an "
"expression to evaluate. Each case is separated by commas. It's often "
"convenient to use a block expression for each case, in which case the commas "
"are optional."
msgstr ""
"`match` の各 arm はカンマ (`,`) は区切ります。 arm のアクションとしてブロック"
"を記述することも可能で、その場合は arm 末尾のカンマを省略することが可能です。"

#. type: Plain text
#: doc/tutorial.md:487
#, no-wrap
msgid ""
"~~~\n"
"# let my_number = 1;\n"
"match my_number {\n"
"  0 => { println(\"zero\") }\n"
"  _ => { println(\"something else\") }\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:492
msgid ""
"`match` constructs must be *exhaustive*: they must have an arm covering "
"every possible case. For example, the typechecker would reject the previous "
"example if the arm with the wildcard pattern was omitted."
msgstr ""
"`match` 構文は **網羅的** でなければなりません。すなわち、`match` 対象の値と"
"同じ型を持つ任意の値に対し、少なくとも 1 つ以上のパターンがマッチするだけの "
"arm を含んでいなければなりません。例えば、上記コード例のワイルドカードパター"
"ンの arm を削除した場合、型検査によりコンパイルエラーとされます。"

#. type: Plain text
#: doc/tutorial.md:496
msgid ""
"A powerful application of pattern matching is *destructuring*: matching in "
"order to bind names to the contents of data types."
msgstr ""
"パターンマッチの応用として、 **destructuring** という強力な機能があります。構"
"造化代入とは、データ型内部の値を名前に束縛 (bind) することです。"

#. type: Plain text
#: doc/tutorial.md:500
msgid ""
"> ***Note:*** The following code makes use of tuples (`(f64, f64)`) "
"which > are explained in section 5.3. For now you can think of tuples as a "
"list of > items."
msgstr ""
"> ***注意:*** 以下のコード例では5.3 節で説明されるタプル (`(f64, f64)`) "
"を使っています。現時点では、タプルは項目のリストのようなものだとみなしてくだ"
"さい。"

#. type: Plain text
#: doc/tutorial.md:513
#, no-wrap
msgid ""
"~~~~\n"
"use std::f64;\n"
"use std::num::atan;\n"
"fn angle(vector: (f64, f64)) -> f64 {\n"
"    let pi = f64::consts::pi;\n"
"    match vector {\n"
"      (0f, y) if y < 0f => 1.5 * pi,\n"
"      (0f, y) => 0.5 * pi,\n"
"      (x, y) => atan(y / x)\n"
"    }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:519
msgid ""
"A variable name in a pattern matches any value, *and* binds that name to the "
"value of the matched value inside of the arm's action. Thus, `(0f, y)` "
"matches any tuple whose first element is zero, and binds `y` to the second "
"element. `(x, y)` matches any two-element tuple, and binds both elements to "
"variables."
msgstr ""
"パターン内に登場する変数は、任意の値にマッチ **するだけでなく**、arm のアク"
"ション内ではマッチした値が変数の名前に束縛されます。従って、 `(0f, y)` は1つ"
"目の要素が 0 である任意のタプルにマッチし、 `y` には2つ目の要素の値が束縛され"
"ます。`(x, y)` は任意の2要素のタプルにマッチし、タプルの各要素がそれぞれの変"
"数に束縛されます。"

#. type: Plain text
#: doc/tutorial.md:526
msgid ""
"Any `match` arm can have a guard clause (written `if EXPR`), called a "
"*pattern guard*, which is an expression of type `bool` that determines, "
"after the pattern is found to match, whether the arm is taken or not. The "
"variables bound by the pattern are in scope in this guard expression. The "
"first arm in the `angle` example shows an example of a pattern guard."
msgstr ""
"`match` の任意の arm は **パターンガード** と呼ばれる、ガード節 (`if EXPR` と"
"書かれる) を持つことができます。パターンガードは、 `bool` 型の値をもつ式で、"
"値にマッチするパターンが見つかった後に評価され、arm が実行されるかどうかを決"
"定します。パターンにより束縛される変数は、ガード式からも参照可能 (ガード式の"
"スコープに含まれる) です。`angle` 関数の例の最初の arm に、パターンガードの使"
"用例が示されています。"

#. type: Plain text
#: doc/tutorial.md:531
msgid ""
"You've already seen simple `let` bindings, but `let` is a little fancier "
"than you've been led to believe. It, too, supports destructuring patterns. "
"For example, you can write this to extract the fields from a tuple, "
"introducing two variables at once: `a` and `b`."
msgstr ""
"`let` は単純な変数束縛だけではなく、パターンによる destructuring をサポートし"
"ています。例えば、タプルからフィールドを抽出し、1度に2つの変数 `a` と `b` を"
"定義することが可能です。"

#. type: Plain text
#: doc/tutorial.md:536
msgid ""
"~~~~ # fn get_tuple_of_two_ints() -> (int, int) { (1, 1) } let (a, b) = "
"get_tuple_of_two_ints(); ~~~~"
msgstr ""
"~~~~\n"
"# fn get_tuple_of_two_ints() -> (int, int) { (1, 1) }\n"
"let (a, b) = get_tuple_of_two_ints();\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:540
msgid ""
"Let bindings only work with _irrefutable_ patterns: that is, patterns that "
"can never fail to match. This excludes `let` from matching literals and most "
"`enum` variants."
msgstr ""
"let による変数定義が可能なのは、パターンが __不可反駁__ (iefutable; 必ず値に"
"マッチする) な場合のみです。この制限により、`let` を用いた destructuring で、"
"リテラルやほとんどの `enum` バリアントをパターンとして用いることはできませ"
"ん。"

#. type: Plain text
#: doc/tutorial.md:542
msgid "## Loops"
msgstr "## ループ"

#. type: Plain text
#: doc/tutorial.md:547
msgid ""
"`while` denotes a loop that iterates as long as its given condition (which "
"must have type `bool`) evaluates to `true`. Inside a loop, the keyword "
"`break` aborts the loop, and `loop` aborts the current iteration and "
"continues with the next."
msgstr ""
"`while` は、与えられた条件 (`bool` 型の値でなければならない) が `true` と評価"
"されている間、繰り返し実行されるループを表します。`break` キーワードは、ルー"
"プの実行を中断させます。`loop` キーワードは、現在実行中の繰り返し (イテレー"
"ション) を中断し、次の繰り返しを実行します。"

#. type: Plain text
#: doc/tutorial.md:554
#, no-wrap
msgid ""
"~~~~\n"
"let mut cake_amount = 8;\n"
"while cake_amount > 0 {\n"
"    cake_amount -= 1;\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:556
msgid ""
"`loop` denotes an infinite loop, and is the preferred way of writing `while "
"true`:"
msgstr ""
"`loop` は無限ループを表します。 `while true` と書く代わりに `loop` と書くこと"
"が推奨されています。"

#. type: Plain text
#: doc/tutorial.md:566
#, no-wrap
msgid ""
"~~~~\n"
"use std::int;\n"
"let mut x = 5;\n"
"loop {\n"
"    x += x - 3;\n"
"    if x % 5 == 0 { break; }\n"
"    println(int::to_str(x));\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:569
msgid ""
"This code prints out a weird sequence of numbers and stops as soon as it "
"finds one that can be divided by five."
msgstr "このコードは 5 で割り切れる数値が現れるまで、数値を出力し続けます。"

#. type: Plain text
#: doc/tutorial.md:571
msgid "# Data structures"
msgstr "# データ構造"

#. type: Plain text
#: doc/tutorial.md:573
msgid "## Structs"
msgstr "## 構造体"

#. type: Plain text
#: doc/tutorial.md:578
msgid ""
"Rust struct types must be declared before they are used using the `struct` "
"syntax: `struct Name { field1: T1, field2: T2 [, ...] }`, where `T1`, "
"`T2`, ... denote types. To construct a struct, use the same syntax, but "
"leave off the `struct`: for example: `Point { x: 1.0, y: 2.0 }`."
msgstr ""
"Rust の構造体 (struct) 型を利用するためには、`struct Name { field1: T1, "
"field2: T2 [, ...] }` (`T1`, `T2`, .. は型を意味する) のように、 `struct` 構"
"文を使った型の宣言が必要です。構造体型の値は、`Point { x: 1.0, y: 2.0 }` のよ"
"うに、構造体宣言から `struct` を取り除いたものと同じ構文で作成します。"

#. type: Plain text
#: doc/tutorial.md:582
msgid ""
"Structs are quite similar to C structs and are even laid out the same way in "
"memory (so you can read from a Rust struct in C, and vice-versa). Use the "
"dot operator to access struct fields, as in `mypoint.x`."
msgstr ""
"Rust の構造体は C の構造体とよく似ており、メモリ上のレイアウトも C と同じで"
"す (そのため、Rust と C で相互に構造体を読み込むことが可能です)。構造体の"
"フィールドにアクセスするには、 `mypoint.x` のように、ドット演算子を用います。"

#. type: Plain text
#: doc/tutorial.md:589
#, no-wrap
msgid ""
"~~~~\n"
"struct Point {\n"
"    x: f64,\n"
"    y: f64\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:593
msgid ""
"Inherited mutability means that any field of a struct may be mutable, if the "
"struct is in a mutable slot (or a field of a struct in a mutable slot, and "
"so forth)."
msgstr ""
"継承ミュータビリティ (inherited mutability) とは、構造体自体がミュータブルな"
"スロットに配置されている場合、構造体のすべてのフィールドもミュータブルになる"
"という性質を意味する言葉です (ミュータブルなスロットに配置された構造体の"
"フィールドに配置された構造体のフィールドもまた、ミュータブルになります) 。"

#. type: Plain text
#: doc/tutorial.md:597
msgid ""
"With a value (say, `mypoint`) of such a type in a mutable location, you can "
"do `mypoint.y += 1.0`. But in an immutable location, such an assignment to a "
"struct without inherited mutability would result in a type error."
msgstr ""
"ある構造体の値 (仮に `mypoint` とします) がミュータブルな場所に配置された場"
"合、 `mypoint.y += 1.0` というような操作を行うことができます。しかし、構造体"
"がイミュータブルな場所に配置された場合、ミュータビリティは継承されないため、"
"このような代入操作は型エラーとなります。"

#. type: Plain text
#: doc/tutorial.md:602
msgid ""
"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = "
"Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };"
msgstr ""
"~~~~ {.xfail-test}\n"
"# struct Point { x: f64, y: f64 }\n"
"let mut mypoint = Point { x: 1.0, y: 1.0 };\n"
"let origin = Point { x: 0.0, y: 0.0 };"

#. type: Plain text
#: doc/tutorial.md:606
msgid ""
"mypoint.y += 1.0; // mypoint is mutable, and its fields as well origin.y += "
"1.0; // ERROR: assigning to immutable field ~~~~"
msgstr ""
"mypoint.y += 1.0;\n"
"// mypoint はミュータブル\n"
"origin.y += 1.0; // ERROR: assigning to immutable field\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:609
msgid ""
"`match` patterns destructure structs. The basic syntax is `Name { fieldname: "
"pattern, ... }`:"
msgstr ""
"`match` のパターンで構造体の destructuring を行うことも可能です。パターン"
"は、 `Name { fieldname: pattern, ... }` という構文を持ちます。"

#. type: Plain text
#: doc/tutorial.md:618
#, no-wrap
msgid ""
"~~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"# let mypoint = Point { x: 0.0, y: 0.0 };\n"
"match mypoint {\n"
"    Point { x: 0.0, y: yy } => { println(yy.to_str());                     }\n"
"    Point { x: xx,  y: yy } => { println(xx.to_str() + \" \" + yy.to_str()); }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:625
msgid ""
"In general, the field names of a struct do not have to appear in the same "
"order they appear in the type. When you are not interested in all the fields "
"of a struct, a struct pattern may end with `, _` (as in `Name { field1, _ }"
"`) to indicate that you're ignoring all other fields.  Additionally, struct "
"fields have a shorthand matching form that simply reuses the field name as "
"the binding name."
msgstr ""
"構造体のフィールド名の並び順は、型定義での並び順と同じにする必要はありませ"
"ん。構造体のパターンマッチで、すべてのフィールドについて考える必要がない場合"
"は、`Name { field1, _ }` のように、末尾に `, _` をつけることで、他のすべての"
"フィールドを無視することができます。"

#. type: Plain text
#: doc/tutorial.md:633
#, no-wrap
msgid ""
"~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"# let mypoint = Point { x: 0.0, y: 0.0 };\n"
"match mypoint {\n"
"    Point { x, _ } => { println(x.to_str()) }\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:635
msgid "## Enums"
msgstr "## 列挙型"

#. type: Plain text
#: doc/tutorial.md:638
msgid ""
"Enums are datatypes that have several alternate representations. For "
"example, consider the type shown earlier:"
msgstr ""
"列挙型 (enum) は、いくつかの代替表現を持つデータ型です。例えば、以下の型につ"
"いて考えます。"

#. type: Plain text
#: doc/tutorial.md:646
#, no-wrap
msgid ""
"~~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"enum Shape {\n"
"    Circle(Point, f64),\n"
"    Rectangle(Point, Point)\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:652
msgid ""
"A value of this type is either a `Circle`, in which case it contains a "
"`Point` struct and a `f64`, or a `Rectangle`, in which case it contains two "
"`Point` structs. The run-time representation of such a value includes an "
"identifier of the actual form that it holds, much like the \"tagged union\" "
"pattern in C, but with better static guarantees."
msgstr ""
"この型の値は、`Point` 構造体と `f64` を含む `Circle` か、2つの `Point` 構造"
"体を含む `Rectangle` のどちらかになります。列挙型の値の実行時表現には、値がど"
"の形式をとっているのか示す識別子が含まれます。この表現方法は C の \"タグ付き"
"共用体\" と非常によく似ていますが、Rust の列挙型はコンパイラにより値の正当性"
"が静的に保証されるという点でより良いものとなっています。"

#. type: Plain text
#: doc/tutorial.md:658
msgid ""
"The above declaration will define a type `Shape` that can refer to such "
"shapes, and two functions, `Circle` and `Rectangle`, which can be used to "
"construct values of the type (taking arguments of the specified types). So "
"`Circle(Point { x: 0f, y: 0f }, 10f)` is the way to create a new circle."
msgstr ""
"上記の宣言は `Shape` 型と `Circle` と `Rectangle` という2つの関数も同時に定義"
"します。これらの関数により、関数名に対応した `Shape` 型の値を構築することがで"
"きます (引数の型も列挙型宣言時に指定されたものをとります)。例えば、"
"`Circle(Point { x: 0f, y: 0f }, 10f)` という記述により、新しい circle を作る"
"ことができます。"

#. type: Plain text
#: doc/tutorial.md:661
msgid ""
"Enum variants need not have parameters. This `enum` declaration, for "
"example, is equivalent to a C enum:"
msgstr ""
"列挙型のバリアントはパラメータを省略することもできます。以下の例の `enum` 宣"
"言は C の列挙型と等価です。"

#. type: Plain text
#: doc/tutorial.md:670
#, no-wrap
msgid ""
"~~~~\n"
"enum Direction {\n"
"    North,\n"
"    East,\n"
"    South,\n"
"    West\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:673
msgid ""
"This declaration defines `North`, `East`, `South`, and `West` as constants, "
"all of which have type `Direction`."
msgstr ""
"この宣言は `Direction` 型の定数 `North`, `East`, `South`, `West` を定義しま"
"す。"

#. type: Plain text
#: doc/tutorial.md:677
msgid ""
"When an enum is C-like (that is, when none of the variants have parameters), "
"it is possible to explicitly set the discriminator values to a constant "
"value:"
msgstr ""
"列挙型が Cライクな (すべてのバリアントがパラメータを持たない) 場合、各定数の"
"識別値 (discriminator value) を明示的に指定することも可能です。"

#. type: Plain text
#: doc/tutorial.md:685
#, no-wrap
msgid ""
"~~~~\n"
"enum Color {\n"
"  Red = 0xff0000,\n"
"  Green = 0x00ff00,\n"
"  Blue = 0x0000ff\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:690
msgid ""
"If an explicit discriminator is not specified for a variant, the value "
"defaults to the value of the previous variant plus one. If the first variant "
"does not have a discriminator, it defaults to 0. For example, the value of "
"`North` is 0, `East` is 1, `South` is 2, and `West` is 3."
msgstr ""
"バリアントの識別値が明に指定されていない場合、1つ前のバリアントの値に1を足し"
"たものが設定されます。また、最初のバリアントの場合は0が設定されます。上記の例"
"で言うと、 `North` は 0、 `East` は 1、 `South` は 2、`West` は3となります。"

#. type: Plain text
#: doc/tutorial.md:693
msgid ""
"When an enum is C-like, you can apply the `as` cast operator to convert it "
"to its discriminator value as an `int`."
msgstr ""
"C ライクな列挙型の値は、キャスト演算子 `as` を適用することで、`int` 型の識別"
"値へ変換することができます。"

#. type: Plain text
#: doc/tutorial.md:697
msgid ""
"For enum types with multiple variants, destructuring is the only way to get "
"at their contents. All variant constructors can be used as patterns, as in "
"this definition of `area`:"
msgstr ""
"複数のバリアントを持つ列挙型で、列挙型値の内部のデータを取得するには、 "
"destructuring を使う必要があります。以下の `area` 関数の例のように、バリアン"
"トのコンストラクタは、パターンとして用いることもできます。"

#. type: Plain text
#: doc/tutorial.md:709
#, no-wrap
msgid ""
"~~~~\n"
"use std::f64;\n"
"# struct Point {x: f64, y: f64}\n"
"# enum Shape { Circle(Point, f64), Rectangle(Point, Point) }\n"
"fn area(sh: Shape) -> f64 {\n"
"    match sh {\n"
"        Circle(_, size) => f64::consts::pi * size * size,\n"
"        Rectangle(Point { x, y }, Point { x: x2, y: y2 }) => (x2 - x) * (y2 - y)\n"
"    }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:714
msgid ""
"You can write a lone `_` to ignore an individual field, and can ignore all "
"fields of a variant like: `Circle(*)`. As in their introduction form, "
"nullary enum patterns are written without parentheses."
msgstr ""
"パターンマッチの際に、特定のフィールドに対するマッチングが不要な場合、無視し"
"たいフィールドの場所に `_` を書くことで、個々のフィールドを無視することができ"
"ます。また、 `Circle(*)` のように書くことで、すべてのフィールドを無視すること"
"も可能です。引数をとらない列挙型のパターンは、定義時の形式と同様、丸括弧の無"
"い形式で記述します。"

#. type: Plain text
#: doc/tutorial.md:727
#, no-wrap
msgid ""
"~~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"# enum Direction { North, East, South, West }\n"
"fn point_from_direction(dir: Direction) -> Point {\n"
"    match dir {\n"
"        North => Point { x:  0f, y:  1f },\n"
"        East  => Point { x:  1f, y:  0f },\n"
"        South => Point { x:  0f, y: -1f },\n"
"        West  => Point { x: -1f, y:  0f }\n"
"    }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:729
msgid "Enum variants may also be structs. For example:"
msgstr "以下の例のように、列挙型バリアントを構造体にすることも可能です。"

#. type: Plain text
#: doc/tutorial.md:747
#, no-wrap
msgid ""
"~~~~\n"
"use std::f64;\n"
"# struct Point { x: f64, y: f64 }\n"
"# fn square(x: f64) -> f64 { x * x }\n"
"enum Shape {\n"
"    Circle { center: Point, radius: f64 },\n"
"    Rectangle { top_left: Point, bottom_right: Point }\n"
"}\n"
"fn area(sh: Shape) -> f64 {\n"
"    match sh {\n"
"        Circle { radius: radius, _ } => f64::consts::pi * square(radius),\n"
"        Rectangle { top_left: top_left, bottom_right: bottom_right } => {\n"
"            (bottom_right.x - top_left.x) * (bottom_right.y - top_left.y)\n"
"        }\n"
"    }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:749
msgid "## Tuples"
msgstr "## タプル"

#. type: Plain text
#: doc/tutorial.md:754
msgid ""
"Tuples in Rust behave exactly like structs, except that their fields do not "
"have names. Thus, you cannot access their fields with dot notation.  Tuples "
"can have any arity except for 0 (though you may consider unit, `()`, as the "
"empty tuple if you like)."
msgstr ""
"Rust のタプルは、フィールドが名前を持たないという点以外は、構造体と同じように"
"振る舞います。フィールド名が存在しないため、ドット記法を使ってタプルのフィー"
"ルドにアクセスすることはできません。タプルは 1 個以上の要素を持つことができま"
"す (必要ならば、ユニット型 `()` を 0 要素のタプルと見なすことはできます。)"

#. type: Plain text
#: doc/tutorial.md:761
#, no-wrap
msgid ""
"~~~~\n"
"let mytup: (int, int, f64) = (10, 20, 30.0);\n"
"match mytup {\n"
"  (a, b, c) => info!(a + b + (c as int))\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:763
msgid "## Tuple structs"
msgstr "## タプル構造体"

#. type: Plain text
#: doc/tutorial.md:768
msgid ""
"Rust also has _tuple structs_, which behave like both structs and tuples, "
"except that, unlike tuples, tuple structs have names (so `Foo(1, 2)` has a "
"different type from `Bar(1, 2)`), and tuple structs' _fields_ do not have "
"names."
msgstr ""
"Rust には __タプル構造体__ と呼ばれる、構造体とタプルの両者の特徴を併せ持つも"
"のが存在します。タプルと異なり、タプル構造体自体は名前を持ちます (従って、"
"`Foo(1, 2)` と `Bar(1, 2)` は異なる型になります。) しかし、タプル構造体の __"
"フィールド__ は名前を持ちません。"

#. type: Plain text
#: doc/tutorial.md:777
#, no-wrap
msgid ""
"For example:\n"
"~~~~\n"
"struct MyTup(int, int, f64);\n"
"let mytup: MyTup = MyTup(10, 20, 30.0);\n"
"match mytup {\n"
"  MyTup(a, b, c) => info!(a + b + (c as int))\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~\n"
"struct MyTup(int, int, f64);\n"
"let mytup: MyTup = MyTup(10, 20, 30.0);\n"
"match mytup {\n"
"  MyTup(a, b, c) => info!(a + b + (c as int))\n"
"}\n"
"~~~~\n"

#. type: Plain text
#: doc/tutorial.md:779
msgid "<a name=\"newtype\"></a>"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:784
msgid ""
"There is a special case for tuple structs with a single field, which are "
"sometimes called \"newtypes\" (after Haskell's \"newtype\" feature). These "
"are used to define new types in such a way that the new name is not just a "
"synonym for an existing type but is rather its own distinct type."
msgstr ""
"タプル構造体がフィールドを 1 つしか持たない場合、 \"newtype\" と呼ばれること"
"があります (Haskell の \"newtype\" 機能に由来しています)。 このようなタプル構"
"造体を使うことで、既存の型の別名 (シノニム) となる新しい型を定義することがで"
"きます。この新しい型は、元にした型とは異なった型として扱われます。"

#. type: Plain text
#: doc/tutorial.md:788
msgid "~~~~ struct GizmoId(int); ~~~~"
msgstr ""
"~~~~\n"
"struct GizmoId(int);\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:791
msgid ""
"For convenience, you can extract the contents of such a struct with the "
"dereference (`*`) unary operator:"
msgstr ""
"便宜上、デリファレンス単項演算子 (`*`) により、タプル構造体の内容を展開するこ"
"とが可能です。"

#. type: Plain text
#: doc/tutorial.md:797
msgid ""
"~~~~ # struct GizmoId(int); let my_gizmo_id: GizmoId = GizmoId(10); let "
"id_int: int = *my_gizmo_id; ~~~~"
msgstr ""
"~~~~\n"
"# struct GizmoId(int);\n"
"let my_gizmo_id: GizmoId = GizmoId(10);\n"
"let id_int: int = *my_gizmo_id;\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:800
msgid ""
"Types like this can be useful to differentiate between data that have the "
"same type but must be used in different ways."
msgstr ""
"このような型は、型は同一でも、それぞれ全く異なる扱い方をしなければならない"
"データを扱う場合に用いると便利です。"

#. type: Plain text
#: doc/tutorial.md:805
msgid "~~~~ struct Inches(int); struct Centimeters(int); ~~~~"
msgstr ""
"~~~~\n"
"struct Inches(int);\n"
"struct Centimeters(int);\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:808
msgid ""
"The above definitions allow for a simple way for programs to avoid confusing "
"numbers that correspond to different units."
msgstr ""
"上記のような単純な定義により、異なる単位を持つ数値を混同することなく扱うこと"
"が可能になります。"

#. type: Plain text
#: doc/tutorial.md:810
msgid "# Functions"
msgstr "# 関数"

#. type: Plain text
#: doc/tutorial.md:818
msgid ""
"We've already seen several function definitions. Like all other static "
"declarations, such as `type`, functions can be declared both at the top "
"level and inside other functions (or in modules, which we'll come back to "
"[later](#modules-and-crates)). The `fn` keyword introduces a function. A "
"function has an argument list, which is a parenthesized list of `expr: type` "
"pairs separated by commas. An arrow `->` separates the argument list and the "
"function's return type."
msgstr ""
"関数定義はこれまでに何度か登場しています。他の静的な宣言 (`type` など)と同様"
"に、関数はトップレベルまたは、他の関数の内部、モジュールの内部で定義すること"
"ができます (モジュールについては、[後述](#モジュールとクレート)します) 。"

#. type: Plain text
#: doc/tutorial.md:824
#, no-wrap
msgid ""
"~~~~\n"
"fn line(a: int, b: int, x: int) -> int {\n"
"    return a * x + b;\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:829
msgid ""
"The `return` keyword immediately returns from the body of a function. It is "
"optionally followed by an expression to return. A function can also return a "
"value by having its top-level block produce an expression."
msgstr ""
"`return` キーワードにより、呼び出し中の関数を即座に復帰させることができます。"
"`return` の後に式を書くことで、呼び出し元へ戻り値として返すことも可能です。ま"
"た、関数トップレベルのブロックを式と解釈した場合の値 (ブロック内最後の式の"
"値) も関数の戻り値になります。"

#. type: Plain text
#: doc/tutorial.md:835
#, no-wrap
msgid ""
"~~~~\n"
"fn line(a: int, b: int, x: int) -> int {\n"
"    a * x + b\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:842
msgid ""
"It's better Rust style to write a return value this way instead of writing "
"an explicit `return`. The utility of `return` comes in when returning early "
"from a function. Functions that do not return a value are said to return "
"nil, `()`, and both the return type and the return value may be omitted from "
"the definition. The following two functions are equivalent."
msgstr ""
"Rust では、明示的に `return` を書くのではなく、上記のような方法で戻り値を返す"
"スタイルが推奨されています。 `return` は、関数を途中で復帰させたい場合に使い"
"ます。値を返さない関数は、 nil `()` を返す関数として取り扱われ、関数の戻り値"
"の型や、戻り値を返す処理を省略することが可能です。以下の2つの関数は等価です。"

#. type: Plain text
#: doc/tutorial.md:845
msgid "~~~~ fn do_nothing_the_hard_way() -> () { return (); }"
msgstr ""
"~~~~\n"
"fn do_nothing_the_hard_way() -> () { return (); }"

#. type: Plain text
#: doc/tutorial.md:848
msgid "fn do_nothing_the_easy_way() { } ~~~~"
msgstr ""
"fn do_nothing_the_easy_way() { }\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:850
msgid ""
"Ending the function with a semicolon like so is equivalent to returning `()`."
msgstr "以下のように、セミコロンで終わる関数は `()` を返す関数と等価です。"

#. type: Plain text
#: doc/tutorial.md:854
msgid ""
"~~~~ fn line(a: int, b: int, x: int) -> int { a * x + b } fn oops(a: int, b: "
"int, x: int) -> ()  { a * x + b; }"
msgstr ""
"~~~~\n"
"fn line(a: int, b: int, x: int) -> int { a * x + b }\n"
"fn oops(a: int, b: int, x: int) -> ()  { a * x + b; }"

#. type: Plain text
#: doc/tutorial.md:858
msgid "assert!(8 == line(5, 3, 1)); assert!(() == oops(5, 3, 1)); ~~~~"
msgstr ""
"assert!(8 == line(5, 3, 1));\n"
"assert!(() == oops(5, 3, 1));\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:862
msgid ""
"As with `match` expressions and `let` bindings, function arguments support "
"pattern destructuring. Like `let`, argument patterns must be irrefutable, as "
"in this example that unpacks the first value from a tuple and returns it."
msgstr ""
"`match` 式や `let` による変数定義のように、関数の引数もパターンによる "
"destructuring をサポートしています。`let` と同様、引数のパターンは 不可反駁 "
"(irrefutable) でなければなりません。以下の例では、タプルの最初の要素を取得"
"し、呼び出し元へ返します。"

#. type: Plain text
#: doc/tutorial.md:866
msgid "~~~ fn first((value, _): (int, f64)) -> int { value } ~~~"
msgstr ""
"~~~\n"
"fn first((value, _): (int, f64)) -> int { value }\n"
"~~~"

#. type: Plain text
#: doc/tutorial.md:868 doc/tutorial-ffi.md:143
msgid "# Destructors"
msgstr "# デストラクタ"

#. type: Plain text
#: doc/tutorial.md:872
msgid ""
"A *destructor* is a function responsible for cleaning up the resources used "
"by an object when it is no longer accessible. Destructors can be defined to "
"handle the release of resources like files, sockets and heap memory."
msgstr ""
"**デストラクタ** はアクセスできなくなったオブジェクトから利用されていたリソー"
"スを解放する役割を持つ関数です。デストラクタはファイルやソケット、ヒープメモ"
"リのようなリソースの解放を処理するために定義することができます。"

#. type: Plain text
#: doc/tutorial.md:876
msgid ""
"Objects are never accessible after their destructor has been called, so "
"there are no dynamic failures from accessing freed resources. When a task "
"fails, the destructors of all objects in the task are called."
msgstr ""
"オブジェクトは、デストラクタが呼び出された後にアクセス不能になります。そのた"
"め、解放済みリソースへアクセスしたことによる動的なエラーは発生しません。タス"
"クの実行に失敗した場合、タスクに属するすべてのオブジェクトのデストラクタが呼"
"び出されます。"

#. type: Plain text
#: doc/tutorial.md:878
msgid ""
"The `~` sigil represents a unique handle for a memory allocation on the heap:"
msgstr ""
"シジル `~` はヒープに獲得されたメモリへのユニークな (唯一の) ハンドルを表しま"
"す。"

#. type: Plain text
#: doc/tutorial.md:886
#, no-wrap
msgid ""
"~~~~\n"
"{\n"
"    // an integer allocated on the heap\n"
"    let y = ~10;\n"
"}\n"
"// the destructor frees the heap memory as soon as `y` goes out of scope\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:890
msgid ""
"Rust includes syntax for heap memory allocation in the language since it's "
"commonly used, but the same semantics can be implemented by a type with a "
"custom destructor."
msgstr ""
"Rust はヒープメモリ獲得のための構文を持っています。これは、ヒープメモリ獲得が"
"よく利用されるというのが理由ですが、同じ動作は独自のデストラクタを持つ型によ"
"り実装することが可能です。"

#. type: Plain text
#: doc/tutorial.md:892
msgid "# Ownership"
msgstr "# 所有権"

#. type: Plain text
#: doc/tutorial.md:897
msgid ""
"Rust formalizes the concept of object ownership to delegate management of an "
"object's lifetime to either a variable or a task-local garbage collector. An "
"object's owner is responsible for managing the lifetime of the object by "
"calling the destructor, and the owner determines whether the object is "
"mutable."
msgstr ""
"Rust は、オブジェクトの寿命の管理を変数またはタスクローカルのガベージコレクタ"
"に委譲するために、オブジェクトの所有権という考え方を取り入れています。オブ"
"ジェクトの所有者はデストラクタを呼び出すことにより、オブジェクトの寿命を管理"
"する責任を負っています。また、所有者はオブジェクトがミュータブルかどうかも判"
"断します。"

#. type: Plain text
#: doc/tutorial.md:903
msgid ""
"Ownership is recursive, so mutability is inherited recursively and a "
"destructor destroys the contained tree of owned objects. Variables are top-"
"level owners and destroy the contained object when they go out of scope. A "
"box managed by the garbage collector starts a new ownership tree, and the "
"destructor is called when it is collected."
msgstr ""
"所有権は再帰的であるため、ミュータビリティは再帰的に継承され、デストラクタは"
"所有しているオブジェクトの含まれているツリーを破壊します。変数はトップレベル"
"の所有者です。変数の存在しているスコープを抜けるタイミングで、変数は所有して"
"いるオブジェクトを破棄します。ガベージコレクタによって管理されるボックスは、"
"新しい所有権ツリーを生成し、ガベージコレクタによりオブジェクトが回収されると"
"きにデストラクタが呼び出されます。"

#. type: Plain text
#: doc/tutorial.md:907
msgid ""
"~~~~ // the struct owns the objects contained in the `x` and `y` fields "
"struct Foo { x: int, y: ~int }"
msgstr ""
"~~~~\n"
"// この構造体はフィールド `x` と `y` に含まれるオブジェクトを所有している\n"
"struct Foo { x: int, y: ~int }"

#. type: Plain text
#: doc/tutorial.md:914
#, no-wrap
msgid ""
"{\n"
"    // `a` is the owner of the struct, and thus the owner of the struct's fields\n"
"    let a = Foo { x: 5, y: ~10 };\n"
"}\n"
"// when `a` goes out of scope, the destructor for the `~int` in the struct's\n"
"// field is called\n"
msgstr ""
"{\n"
"    // `a` は構造体の所有者であり、構造体のフィールドの所有者でもある\n"
"    let a = Foo { x: 5, y: ~10 };\n"
"}\n"
"// `a` の含まれているスコープから抜けるとき、 構造体のフィールドの `~int` のデストラクタが呼ばれる\n"

#. type: Plain text
#: doc/tutorial.md:919
msgid ""
"// `b` is mutable, and the mutability is inherited by the objects it owns "
"let mut b = Foo { x: 5, y: ~10 }; b.x = 10; ~~~~"
msgstr ""
"// `b` はミュータブルなので、所有しているオブジェクトにもミュターブル性が継承"
"される\n"
"let mut b = Foo { x: 5, y: ~10 };\n"
"b.x = 10;\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:925
msgid ""
"If an object doesn't contain garbage-collected boxes, it consists of a "
"single ownership tree and is given the `Owned` trait which allows it to be "
"sent between tasks. Custom destructors can only be implemented directly on "
"types that are `Owned`, but garbage-collected boxes can still *contain* "
"types with custom destructors."
msgstr ""
"オブジェクトにガベージコレクトされるボックスが含まれていない場合、オブジェク"
"トは単一の継承ツリーからの構成され、`Owned` トレイトが付与されます。`Owned` "
"トレイトが付与されたデータは、タスク間を跨いで受け渡すことが可能です。独自の"
"デストラクタは、`Owned` トレイトを満たす型に対して直接実装されなければなりま"
"せんが、ガベージコレクトされるボックスが独自のデストラクタをもつ型を **含む"
"** ことは依然可能です。"

#. type: Plain text
#: doc/tutorial.md:927
msgid "# Boxes"
msgstr "# ボックス"

#. type: Plain text
#: doc/tutorial.md:934
msgid ""
"Many modern languages represent values as pointers to heap memory by "
"default. In contrast, Rust, like C and C++, represents such types directly.  "
"Another way to say this is that aggregate data in Rust are *unboxed*. This "
"means that if you `let x = Point { x: 1f, y: 1f };`, you are creating a "
"struct on the stack. If you then copy it into a data structure, you copy the "
"entire struct, not just a pointer."
msgstr ""
"多くのモダンな言語では、デフォルトで、値はヒープメモリへのポインタとして表さ"
"れます。一方、Rust は C や C++ のように、これらの型を直接取り扱うことができま"
"す。言い換えると、集積データは **ボックス化されていない** ということです。つ"
"まり、`let x = Point { x: 1f, y: 1f };` というコードは、スタック上に構造体を"
"作成することを意味します。この構造体を別のデータ構造の中へコピーする場合、ポ"
"インタのコピーではなく構造体全体をコピーすることになります。"

#. type: Plain text
#: doc/tutorial.md:939
msgid ""
"For small structs like `Point`, this is usually more efficient than "
"allocating memory and indirecting through a pointer. But for big structs, or "
"mutable state, it can be useful to have a single copy on the stack or on the "
"heap, and refer to that through a pointer."
msgstr ""
"`Point` のような小さな構造体の場合、このような動作は、メモリを獲得しポインタ"
"経由でアクセスするよりも一般的には効率的です。しかし、大きな構造体の場合や"
"ミュータブルな状態を持つようなものの場合、スタックまたはヒープ上に単一ののコ"
"ピーをもち、ポインタ経由で参照する方が便利な場合もあります。"

#. type: Plain text
#: doc/tutorial.md:941
msgid "## Owned boxes"
msgstr "## 所有ボックス"

#. type: Plain text
#: doc/tutorial.md:944
msgid ""
"An owned box (`~`) is a uniquely owned allocation on the heap. It inherits "
"the mutability and lifetime of the owner as it would if there was no box:"
msgstr ""
"所有ボックス (Owned box, `~`) は、単一の所有者のみを持つ、ヒープ上に獲得され"
"た領域です。所有ボックスは、ボックスが存在しない場合と同じように、所有者の"
"ミュータビリティと寿命を継承します。"

#. type: Plain text
#: doc/tutorial.md:949
msgid "~~~~ let x = 5; // immutable let mut y = 5; // mutable y += 2;"
msgstr ""
"~~~~\n"
"let x = 5; // イミュータブル\n"
"let mut y = 5; // ミュータブル\n"
"y += 2;"

#. type: Plain text
#: doc/tutorial.md:954
msgid ""
"let x = ~5; // immutable let mut y = ~5; // mutable *y += 2; // the * "
"operator is needed to access the contained value ~~~~"
msgstr ""
"let x = ~5; // イミュータブル\n"
"let mut y = ~5; // ミュータブル\n"
"*y += 2; // ボックスの中身にアクセスするには、 * 演算子が必要\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:959
msgid ""
"The purpose of an owned box is to add a layer of indirection in order to "
"create recursive data structures or cheaply pass around an object larger "
"than a pointer. Since an owned box has a unique owner, it can only be used "
"to represent a tree data structure."
msgstr ""
"所有ボックスの目的は、再帰的なデータ型の作成や、ポインターのサイズより大きい"
"オブジェクトを安価な方法で渡したりするための、関節参照のレイヤを追加すること"
"です。所有ボックスは複数の所有者を持てないため、ツリー構造を持ったデータのみ"
"を表すことが可能です。"

#. type: Plain text
#: doc/tutorial.md:962
msgid ""
"The following struct won't compile, because the lack of indirection would "
"mean it has an infinite size:"
msgstr ""
"以下の構造体はコンパイルできません。構造体が自身を関節参照でない方法で参照し"
"た場合、無限に大きなサイズを持つことになってしまうからです。"

#. type: Plain text
#: doc/tutorial.md:968
#, no-wrap
msgid ""
"~~~~ {.xfail-test}\n"
"struct Foo {\n"
"    child: Option<Foo>\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:972
msgid ""
"> ***Note:*** The `Option` type is an enum that represents an *optional* "
"value.  > It's comparable to a nullable pointer in many other languages, but "
"stores the > contained value unboxed."
msgstr ""
"> ***注意*** `Option` 型は **オプショナルな** (値の有無を選択可能な) 値を表す"
"列挙型です。`Option` 型は他の言語の null 値をとりうるポインタ型に相当します"
"が、格納される値はボックス化されていません。"

#. type: Plain text
#: doc/tutorial.md:976
msgid ""
"Adding indirection with an owned pointer allocates the child outside of the "
"struct on the heap, which makes it a finite size and won't result in a "
"compile-time error:"
msgstr ""
"所有ポインタによる関節参照を導入することで、`child` を構造体の外のヒープ上に"
"獲得することができ、構造体のデータサイズは有限となるため、コンパイルエラーと"
"はなりません。"

#. type: Plain text
#: doc/tutorial.md:982
#, no-wrap
msgid ""
"~~~~\n"
"struct Foo {\n"
"    child: Option<~Foo>\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:984
msgid "## Managed boxes"
msgstr "## マネージドボックス"

#. type: Plain text
#: doc/tutorial.md:992
msgid ""
"A managed box (`@`) is a heap allocation with the lifetime managed by a task-"
"local garbage collector. It will be destroyed at some point after there are "
"no references left to the box, no later than the end of the task. Managed "
"boxes lack an owner, so they start a new ownership tree and don't inherit "
"mutability. They do own the contained object, and mutability is defined by "
"the type of the managed box (`@` or `@mut`). An object containing a managed "
"box is not `Owned`, and can't be sent between tasks."
msgstr ""
"マネージドボックス (`@`) は、タスクローカルなガベージコレクタにより寿命管理さ"
"れる、ヒープ上に獲得された領域です。マネージドボックスは、ボックスへの参照が"
"無くなった後、いずれかの時点で破棄されます。破棄のタイミングがタスク終了後に"
"なることはありません。マネージドボックスは所有者を持たないので、新たな所有権"
"ツリーを開始し、ミュータビリティを継承しません。マネージドボックスは、ボック"
"スに含まれているオブジェクトを所有し、ミュータビリティはマネージドボックスの"
"種別 (`@` または `@mut`) によって決定されます。マネージドボックスに含まれるオ"
"ブジェクトは `Owned` を付与されず、タスク間で受け渡すことはできません。"

#. type: Plain text
#: doc/tutorial.md:995
msgid "~~~~ let a = @5; // immutable"
msgstr ""
"~~~~\n"
"let a = @5; // イミュータブル"

#. type: Plain text
#: doc/tutorial.md:998
msgid "let mut b = @5; // mutable variable, immutable box b = @10;"
msgstr ""
"let mut b = @5; // ミュータブルな変数、イミュータブルなボックス\n"
"b = @10;"

#. type: Plain text
#: doc/tutorial.md:1001
msgid "let c = @mut 5; // immutable variable, mutable box *c = 10;"
msgstr ""
"let c = @mut 5; // イミュータブルな変数、ミュータブルなボックス\n"
"*c = 10;"

#. type: Plain text
#: doc/tutorial.md:1006
msgid ""
"let mut d = @mut 5; // mutable variable, mutable box *d += 5; d = @mut 15; "
"~~~~"
msgstr ""
"let mut d = @mut 5; // ミュータブルな変数、ミュータブルなボックス\n"
"*d += 5;\n"
"d = @mut 15;\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:1011
msgid ""
"A mutable variable and an immutable variable can refer to the same box, "
"given that their types are compatible. Mutability of a box is a property of "
"its type, however, so for example a mutable handle to an immutable box "
"cannot be assigned a reference to a mutable box."
msgstr ""
"ミュータブルな変数とイミュータブルな変数は、それぞれの変数の型が同じであれ"
"ば、同じボックスを参照することが可能です。ただし、ボックスのミュータビリティ"
"は、型自体が持つ属性なので、ミュータブルなボックスの参照を、イミュータブルな"
"ボックスを参照するミュータブルな変数 (handle) へ代入することはできません。"

#. type: Plain text
#: doc/tutorial.md:1015
#, no-wrap
msgid ""
"~~~~\n"
"let a = @1;     // immutable box\n"
"let b = @mut 2; // mutable box\n"
msgstr ""
"~~~~\n"
"let a = @1;     // イミュータブルなボックス\n"
"let b = @mut 2; // ミュータブルなボックス\n"

#. type: Plain text
#: doc/tutorial.md:1018
#, no-wrap
msgid ""
"let mut c : @int;       // declare a variable with type managed immutable int\n"
"let mut d : @mut int;   // and one of type managed mutable int\n"
msgstr ""
"let mut c : @int;       // イミュータブルなマネージド int 型の変数と、\n"
"let mut d : @mut int;   // ミュータブルなマネージド int 型の変数の宣言\n"

#. type: Plain text
#: doc/tutorial.md:1022
#, no-wrap
msgid ""
"c = a;          // box type is the same, okay\n"
"d = b;          // box type is the same, okay\n"
"~~~~\n"
msgstr ""
"c = a;          // ボックスの型は変数の型と同じなので、OK\n"
"d = b;          // ボックスの型は変数の型と同じなので、OK\n"
"~~~~\n"

#. type: Plain text
#: doc/tutorial.md:1027
#, no-wrap
msgid ""
"~~~~ {.xfail-test}\n"
"// but b cannot be assigned to c, or a to d\n"
"c = b;          // error\n"
"~~~~\n"
msgstr ""
"~~~~ {.xfail-test}\n"
"// しかし、 b は c に代入できないし、a は d に代入できない\n"
"c = b;          // エラー\n"
"~~~~\n"

#. type: Plain text
#: doc/tutorial.md:1029
msgid "# Move semantics"
msgstr "# ムーブセマンティクス"

#. type: Plain text
#: doc/tutorial.md:1035
msgid ""
"Rust uses a shallow copy for parameter passing, assignment and returning "
"values from functions. A shallow copy is considered a move of ownership if "
"the ownership tree of the copied value includes an owned box or a type with "
"a custom destructor. After a value has been moved, it can no longer be used "
"from the source location and will not be destroyed there."
msgstr ""
"Rust は関数パラメータの受け渡しや、変数への代入、関数からの戻り値を設定する際"
"に、シャローコピーを使用しています。コピーされる値の所有権ツリーが所有ボック"
"スや独自のデストラクタを持つ型を含んでいる場合、シャローコピーは所有権の移動"
"とみなされます。値の移動が行われた後、元々その値を参照していた箇所からは値を"
"利用することはできなくなり、もとの所有者から値が破壊されることもありません。"

#. type: Plain text
#: doc/tutorial.md:1041
msgid ""
"~~~~ let x = ~5; let y = x.clone(); // y is a newly allocated box let z = "
"x; // no new memory allocated, x can no longer be used ~~~~"
msgstr ""
"~~~~\n"
"let x = ~5;\n"
"let y = x.clone();\n"
"// y は新しく獲得されるボックス\n"
"let z = x; // 新たなメモリの獲得は行われない。x を使うことはできなくなる\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:1044
msgid ""
"Since in owned boxes mutability is a property of the owner, not the box, "
"mutable boxes may become immutable when they are moved, and vice-versa."
msgstr ""
"所有ボックスのミュータビリティは、ボックスではなく所有者のミュータビリティを"
"引き継ぐため、同一のボックスが移動によりミュータブルになったりイミュータブル"
"になったりすることがありえます。"

#. type: Plain text
#: doc/tutorial.md:1051
msgid ""
"~~~~ let r = ~13; let mut s = r; // box becomes mutable *s += 1; let t = "
"s; // box becomes immutable ~~~~"
msgstr ""
"~~~~\n"
"let r = ~13;\n"
"let mut s = r; // ボックスはミュータブルになる\n"
"*s += 1;\n"
"let t = s; // ボックスはイミュータブルになる\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:1053
msgid "# Borrowed pointers"
msgstr "# 借用ポインタ"

#. type: Plain text
#: doc/tutorial.md:1059
msgid ""
"Rust's borrowed pointers are a general purpose reference type. In contrast "
"with owned boxes, where the holder of an owned box is the owner of the "
"pointed-to memory, borrowed pointers never imply ownership. A pointer can be "
"borrowed to any object, and the compiler verifies that it cannot outlive the "
"lifetime of the object."
msgstr ""
"Rust の借用ポインタ (borrowed pointer) は汎用的な参照型です。所有ボックスの場"
"合、ボックスの所有者が参照されているメモリの所有者となるのに対して、借用ポイ"
"ンタを所有することがメモリを所有を意味することはありません。ポインタは任意の"
"オブジェクトから借用することが可能で、参照先のオブジェクトよりもポインタが長"
"生きしないことがコンパイラにより保証されます。"

#. type: Plain text
#: doc/tutorial.md:1061
msgid "As an example, consider a simple struct type, `Point`:"
msgstr "例として、シンプルな構造体型の `Point` について考えます。"

#. type: Plain text
#: doc/tutorial.md:1068
#, no-wrap
msgid ""
"~~~\n"
"struct Point {\n"
"    x: f64,\n"
"    y: f64\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1072
msgid ""
"We can use this simple definition to allocate points in many different ways. "
"For example, in this code, each of these three local variables contains a "
"point, but allocated in a different location:"
msgstr ""
"シンプルな定義ですが、この定義を使って `Point` 型のオブジェクトを様々な方法で"
"割り当てることができます。例えば、このコードの3つのローカル変数は、それぞれ異"
"なった場所に `Point` 型のオブジェクトを割り当てています。"

#. type: Plain text
#: doc/tutorial.md:1079
#, no-wrap
msgid ""
"~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"let on_the_stack : Point  =  Point { x: 3.0, y: 4.0 };\n"
"let managed_box  : @Point = @Point { x: 5.0, y: 1.0 };\n"
"let owned_box    : ~Point = ~Point { x: 7.0, y: 9.0 };\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1089
msgid ""
"Suppose we want to write a procedure that computes the distance between any "
"two points, no matter where they are stored. For example, we might like to "
"compute the distance between `on_the_stack` and `managed_box`, or between "
"`managed_box` and `owned_box`. One option is to define a function that takes "
"two arguments of type point—that is, it takes the points by value. But this "
"will cause the points to be copied when we call the function. For points, "
"this is probably not so bad, but often copies are expensive. So we’d like to "
"define a function that takes the points by pointer. We can use borrowed "
"pointers to do this:"
msgstr ""
"`Point` 型のオブジェクトの割り当て先がどこであったとしても利用可能な、任意の "
"2 点間の距離を計算する処理を書きたいとします。例えば、 `on_the_stack`, "
"`managed_box` 間や `managed_box`, `owned_box` 間の距離を計算する処理です。 1"
"つ目の実装方法として、2つの `Point` 型オブジェクトを引数にとる関数を定義する"
"方法、すなわち、オブジェクトを値で受け渡す方法があります。しかし、この方法で"
"は関数呼び出し時に `Point` オブジェクトのコピーが行われます。`Point` オブジェ"
"クトの場合、このような実装はそれほど悪いものではないでしょうが、コピー処理の"
"コストは高い場合もあります。したがって、`Point` オブジェクトをポインタ渡しす"
"る関数を定義する必要があります。そのために、借用ポインタを利用することが可能"
"です。"

#. type: Plain text
#: doc/tutorial.md:1099
#, no-wrap
msgid ""
"~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"# fn sqrt(f: f64) -> f64 { 0f }\n"
"fn compute_distance(p1: &Point, p2: &Point) -> f64 {\n"
"    let x_d = p1.x - p2.x;\n"
"    let y_d = p1.y - p2.y;\n"
"    sqrt(x_d * x_d + y_d * y_d)\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1101 doc/tutorial-borrowed-ptr.md:72
msgid "Now we can call `compute_distance()` in various ways:"
msgstr ""
"上記の `compute_distance()` 関数は、様々な方法で呼び出すことができます。"

#. type: Plain text
#: doc/tutorial.md:1111
#, no-wrap
msgid ""
"~~~\n"
"# struct Point{ x: f64, y: f64 };\n"
"# let on_the_stack : Point  =  Point { x: 3.0, y: 4.0 };\n"
"# let managed_box  : @Point = @Point { x: 5.0, y: 1.0 };\n"
"# let owned_box    : ~Point = ~Point { x: 7.0, y: 9.0 };\n"
"# fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0f }\n"
"compute_distance(&on_the_stack, managed_box);\n"
"compute_distance(managed_box, owned_box);\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1118
msgid ""
"Here the `&` operator is used to take the address of the variable "
"`on_the_stack`; this is because `on_the_stack` has the type `Point` (that "
"is, a struct value) and we have to take its address to get a value. We also "
"call this _borrowing_ the local variable `on_the_stack`, because we are "
"creating an alias: that is, another route to the same data."
msgstr ""
"ここで `&` 演算子は `on_the_stack` 変数のアドレスを取得するために使われていま"
"す。これは、 `on_the_stack` の型は `Point` (つまり、構造体の値) であり、呼び"
"出した関数から値を取得させるため、構造体のアドレスを渡す必要があるからです。"
"値の別名 (エイリアス)、すなわち、同じデータへアクセスするための別の方法を提供"
"するので、このような操作のことをローカル変数 `on_the_stack` の __借用__ "
"(_borrowing_) と呼びます。"

#. type: Plain text
#: doc/tutorial.md:1124
msgid ""
"In the case of the boxes `managed_box` and `owned_box`, however, no explicit "
"action is necessary. The compiler will automatically convert a box like "
"`@point` or `~point` to a borrowed pointer like `&point`. This is another "
"form of borrowing; in this case, the contents of the managed/owned box are "
"being lent out."
msgstr ""
"ボックスである `managed_box` と `owned_box` の場合は、特に明示的な操作を行う"
"必要はありません。コンパイラは `@point` や `~point` のようなボックスを自動的"
"に `&point` のような借用ポインタへと変換します。これは、別の形態の借用 "
"(borrowing) です。この場合、マネージド/所有ボックスの内容が貸し出されていま"
"す。"

#. type: Plain text
#: doc/tutorial.md:1133
msgid ""
"Whenever a value is borrowed, there are some limitations on what you can do "
"with the original. For example, if the contents of a variable have been lent "
"out, you cannot send that variable to another task, nor will you be "
"permitted to take actions that might cause the borrowed value to be freed or "
"to change its type. This rule should make intuitive sense: you must wait for "
"a borrowed value to be returned (that is, for the borrowed pointer to go out "
"of scope) before you can make full use of it again."
msgstr ""
"値が借用されている間、借用元の値に対して行える操作がいくらか制限されます。例"
"えば、変数の内容が貸し出された場合、その変数を他のタスクに送信することはでき"
"ませんし、借用された値を解放したり、型が変化させるような操作も行うことができ"
"ません。このルールは理にかなったものでしょう。貸し出した値を最大限に活用する "
"(make full use of it) ためには、貸し出した値の返却 (借用ポインタが存在するス"
"コープを抜ける) を待たなければなりません。"

#. type: Plain text
#: doc/tutorial.md:1136
msgid ""
"For a more in-depth explanation of borrowed pointers, read the [borrowed "
"pointer tutorial][borrowtut]."
msgstr ""
"借用ポインタの詳細については、[借用ポインタのチュートリアル][borrowtut]を参照"
"してください。"

#. type: Plain text
#: doc/tutorial.md:1138
msgid "[borrowtut]: tutorial-borrowed-ptr.html"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1140
msgid "## Freezing"
msgstr "## 凍結"

#. type: Plain text
#: doc/tutorial.md:1143
msgid ""
"Borrowing an immutable pointer to an object freezes it and prevents "
"mutation.  `Owned` objects have freezing enforced statically at compile-time."
msgstr ""
"オブジェクトへのイミュータブルな (借用) ポインタを借用した場合、借用されたオ"
"ブジェクトは凍結 (freezing) され、変更することができなくなります。`Owned` ト"
"レイトが付与されたオブジェクトは、コンパイル時の静的解析により、強制的に凍結"
"されます (凍結された値を変更しようとすると、コンパイルエラーとなります)。"

#. type: Plain text
#: doc/tutorial.md:1152
#, no-wrap
msgid ""
"~~~~\n"
"let mut x = 5;\n"
"{\n"
"    let y = &x; // x is now frozen, it cannot be modified\n"
"}\n"
"// x is now unfrozen again\n"
"# x = 3;\n"
"~~~~\n"
msgstr ""
"~~~~\n"
"let mut x = 5;\n"
"{\n"
"    let y = &x; // x は凍結されたので、変更することができない\n"
"}\n"
"// x の凍結状態は解除される\n"
"# x = 3;\n"
"~~~~\n"

#. type: Plain text
#: doc/tutorial.md:1156
msgid ""
"Mutable managed boxes handle freezing dynamically when any of their contents "
"are borrowed, and the task will fail if an attempt to modify them is made "
"while they are frozen:"
msgstr ""
"ミュータブルなマネージドボックスは、その内容のいずれかが借用される際に動的に"
"凍結され、凍結状態の間に内容を変更しようとすると、タスクが失敗します。"

#. type: Plain text
#: doc/tutorial.md:1166
#, no-wrap
msgid ""
"~~~~\n"
"let x = @mut 5;\n"
"let y = x;\n"
"{\n"
"    let z = &*y; // the managed box is now frozen\n"
"    // modifying it through x or y will cause a task failure\n"
"}\n"
"// the box is now unfrozen again\n"
"~~~~\n"
msgstr ""
"~~~~\n"
"let x = @mut 5;\n"
"let y = x;\n"
"{\n"
"    let z = &*y; // マネージドボックスが凍結される\n"
"    // x か y を経由して内容を変更すると、タスクが異常終了する\n"
"}\n"
"// ボックスの凍結状態は解除される\n"
"~~~~\n"

#. type: Plain text
#: doc/tutorial.md:1168
msgid "# Dereferencing pointers"
msgstr "# ポインタのデリファレンス"

#. type: Plain text
#: doc/tutorial.md:1171
msgid ""
"Rust uses the unary star operator (`*`) to access the contents of a box or "
"pointer, similarly to C."
msgstr ""
"Rust では、C と同様、ボックスの内容やポインタの参照先にアクセスするためには単"
"項スター演算子 (`*`) を使います。"

#. type: Plain text
#: doc/tutorial.md:1176
msgid "~~~ let managed = @10; let owned = ~20; let borrowed = &30;"
msgstr ""
"~~~\n"
"let managed = @10;\n"
"let owned = ~20;\n"
"let borrowed = &30;"

#. type: Plain text
#: doc/tutorial.md:1179
msgid "let sum = *managed + *owned + *borrowed; ~~~"
msgstr ""
"let sum = *managed + *owned + *borrowed;\n"
"~~~"

#. type: Plain text
#: doc/tutorial.md:1183
msgid ""
"Dereferenced mutable pointers may appear on the left hand side of "
"assignments. Such an assignment modifies the value that the pointer points "
"to."
msgstr ""
"ミュータブルなポインタをデリファレンスしたものは、代入文の左辺に置くことがで"
"きます。このような代入文は、ポインタが指す値を変更します。"

#. type: Plain text
#: doc/tutorial.md:1187
msgid "~~~ let managed = @mut 10; let mut owned = ~20;"
msgstr ""
"~~~\n"
"let managed = @mut 10;\n"
"let mut owned = ~20;"

#. type: Plain text
#: doc/tutorial.md:1190
msgid "let mut value = 30; let borrowed = &mut value;"
msgstr ""
"let mut value = 30;\n"
"let borrowed = &mut value;"

#. type: Plain text
#: doc/tutorial.md:1195
#, no-wrap
msgid ""
"*managed = *owned + 10;\n"
"*owned = *borrowed + 100;\n"
"*borrowed = *managed + 1000;\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1199
msgid ""
"Pointers have high operator precedence, but lower precedence than the dot "
"operator used for field and method access. This precedence order can "
"sometimes make code awkward and parenthesis-filled."
msgstr ""
"ポインタ演算子の優先順位は高いですが、フィールドやメソッドのアクセスに用いる"
"ドット演算子よりは優先順位は低いです。この優先順位により、コードが不格好で括"
"弧だらけなものになることがあります。"

#. type: Plain text
#: doc/tutorial.md:1209
msgid ""
"~~~ # struct Point { x: f64, y: f64 } # enum Shape { Rectangle(Point, "
"Point) } # impl Shape { fn area(&self) -> int { 0 } } let start = @Point "
"{ x: 10f, y: 20f }; let end = ~Point { x: (*start).x + 100f, y: (*start).y + "
"100f }; let rect = &Rectangle(*start, *end); let area = (*rect).area(); ~~~"
msgstr ""
"~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"# enum Shape { Rectangle(Point, Point) }\n"
"# impl Shape { fn area(&self) -> int { 0 } }\n"
"let start = @Point { x: 10f, y: 20f };\n"
"let end = ~Point { x: (*start).x + 100f, y: (*start).y + 100f };\n"
"let rect = &Rectangle(*start, *end);\n"
"let area = (*rect).area();\n"
"~~~"

#. type: Plain text
#: doc/tutorial.md:1213
msgid ""
"To combat this ugliness the dot operator applies _automatic pointer "
"dereferencing_ to the receiver (the value on the left-hand side of the dot), "
"so in most cases, explicitly dereferencing the receiver is not necessary."
msgstr ""
"コードが醜くなるのを防ぐため、ドット演算子はレシーバ (ドットの左にある値) の "
"__ポインタを自動的にデリファレンス__ します。これにより、ほとんどのケースでは"
"レシーバを明示的にデリファレンスする必要がなくなります。"

#. type: Plain text
#: doc/tutorial.md:1223
msgid ""
"~~~ # struct Point { x: f64, y: f64 } # enum Shape { Rectangle(Point, "
"Point) } # impl Shape { fn area(&self) -> int { 0 } } let start = @Point "
"{ x: 10f, y: 20f }; let end = ~Point { x: start.x + 100f, y: start.y + "
"100f }; let rect = &Rectangle(*start, *end); let area = rect.area(); ~~~"
msgstr ""
"~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"# enum Shape { Rectangle(Point, Point) }\n"
"# impl Shape { fn area(&self) -> int { 0 } }\n"
"let start = @Point { x: 10f, y: 20f };\n"
"let end = ~Point { x: start.x + 100f, y: start.y + 100f };\n"
"let rect = &Rectangle(*start, *end);\n"
"let area = rect.area();\n"
"~~~"

#. type: Plain text
#: doc/tutorial.md:1227
msgid ""
"You can write an expression that dereferences any number of pointers "
"automatically. For example, if you feel inclined, you could write something "
"silly like"
msgstr ""
"1つのドット演算子で何度も自動デリファレンスが行うことができます。例えば、やろ"
"うと思えば以下のような馬鹿げたものを書くこともできます。"

#. type: Plain text
#: doc/tutorial.md:1233
msgid ""
"~~~ # struct Point { x: f64, y: f64 } let point = &@~Point { x: 10f, y: "
"20f }; println(fmt!(\"%f\", point.x)); ~~~"
msgstr ""
"~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"let point = &@~Point { x: 10f, y: 20f };\n"
"println(fmt!(\"%f\", point.x));\n"
"~~~"

#. type: Plain text
#: doc/tutorial.md:1235
msgid "The indexing operator (`[]`) also auto-dereferences."
msgstr "添字演算子 (`[]`) も自動でリファレンスを行います。"

#. type: Plain text
#: doc/tutorial.md:1237
msgid "# Vectors and strings"
msgstr "# ベクタと文字列"

#. type: Plain text
#: doc/tutorial.md:1242
msgid ""
"A vector is a contiguous section of memory containing zero or more values of "
"the same type. Like other types in Rust, vectors can be stored on the stack, "
"the local heap, or the exchange heap. Borrowed pointers to vectors are also "
"called 'slices'."
msgstr ""
"ベクタは同じ型の値が0個以上含まれる、メモリ上の連続した部分のことです。Rust "
"の他の型と同様、ベクタもスタック、ローカルヒープ、交換ヒープ (exchange heap) "
"上に格納することができます。ベクトルの借用ポインタは、「スライス」と呼ばれる"
"場合もあります。"

#. type: Plain text
#: doc/tutorial.md:1252
#, no-wrap
msgid ""
"~~~\n"
"# enum Crayon {\n"
"#     Almond, AntiqueBrass, Apricot,\n"
"#     Aquamarine, Asparagus, AtomicTangerine,\n"
"#     BananaMania, Beaver, Bittersweet,\n"
"#     Black, BlizzardBlue, Blue\n"
"# }\n"
"// A fixed-size stack vector\n"
"let stack_crayons: [Crayon, ..3] = [Almond, AntiqueBrass, Apricot];\n"
msgstr ""
"~~~\n"
"# enum Crayon {\n"
"#     Almond, AntiqueBrass, Apricot,\n"
"#     Aquamarine, Asparagus, AtomicTangerine,\n"
"#     BananaMania, Beaver, Bittersweet,\n"
"#     Black, BlizzardBlue, Blue\n"
"# }\n"
"// スタック上の固定長ベクタ\n"
"let stack_crayons: [Crayon, ..3] = [Almond, AntiqueBrass, Apricot];\n"

#. type: Plain text
#: doc/tutorial.md:1255
msgid ""
"// A borrowed pointer to stack-allocated vector let stack_crayons: &[Crayon] "
"= &[Aquamarine, Asparagus, AtomicTangerine];"
msgstr ""
"// スタックに獲得されたベクタへの借用ポインタ\n"
"let stack_crayons: &[Crayon] = &[Aquamarine, Asparagus, AtomicTangerine];"

#. type: Plain text
#: doc/tutorial.md:1258
msgid ""
"// A local heap (managed) vector of crayons let local_crayons: @[Crayon] = "
"@[BananaMania, Beaver, Bittersweet];"
msgstr ""
"// ローカルヒープ上に獲得された、クレヨンの (マネージド) ベクタ\n"
"let local_crayons: @[Crayon] = @[BananaMania, Beaver, Bittersweet];"

#. type: Plain text
#: doc/tutorial.md:1262
msgid ""
"// An exchange heap (owned) vector of crayons let exchange_crayons: "
"~[Crayon] = ~[Black, BlizzardBlue, Blue]; ~~~"
msgstr ""
"// 交換ヒープに獲得された、クレヨンの (所有) ベクタ\n"
"let exchange_crayons: ~[Crayon] = ~[Black, BlizzardBlue, Blue];\n"
"~~~"

#. type: Plain text
#: doc/tutorial.md:1264
msgid "The `+` operator means concatenation when applied to vector types."
msgstr "`+` 演算子がベクタ型に適用された場合、ベクタの結合を意味します。"

#. type: Plain text
#: doc/tutorial.md:1274
#, no-wrap
msgid ""
"~~~~\n"
"# enum Crayon { Almond, AntiqueBrass, Apricot,\n"
"#               Aquamarine, Asparagus, AtomicTangerine,\n"
"#               BananaMania, Beaver, Bittersweet };\n"
"# impl Clone for Crayon {\n"
"#     fn clone(&self) -> Crayon {\n"
"#         *self\n"
"#     }\n"
"# }\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1277
msgid ""
"let my_crayons = ~[Almond, AntiqueBrass, Apricot]; let your_crayons = "
"~[BananaMania, Beaver, Bittersweet];"
msgstr ""
"let my_crayons = ~[Almond, AntiqueBrass, Apricot];\n"
"let your_crayons = ~[BananaMania, Beaver, Bittersweet];"

#. type: Plain text
#: doc/tutorial.md:1280
msgid ""
"// Add two vectors to create a new one let our_crayons = my_crayons + "
"your_crayons;"
msgstr ""
"// 2 つのベクタを結合して、新しいベクタを作る\n"
"let our_crayons = my_crayons + your_crayons;"

#. type: Plain text
#: doc/tutorial.md:1285
msgid ""
"// .push_all() will append to a vector, provided it lives in a mutable slot "
"let mut my_crayons = my_crayons; my_crayons.push_all(your_crayons); ~~~~"
msgstr ""
"// .push_all() はベクタに要素を追加します。ミュータブルなスロットのベクタに対"
"してのみ有効です\n"
"let mut my_crayons = my_crayons;\n"
"my_crayons.push_all(your_crayons);\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:1290
msgid ""
"> ***Note:*** The above examples of vector addition use owned > vectors. "
"Some operations on slices and stack vectors are > not yet well-supported. "
"Owned vectors are often the most > usable."
msgstr ""
"> ***注意:*** 上記のベクタに要素を追加する例では、所有ベクタを利用していま"
"す。いくつかの操作はスライスやスタックベクタを十分にサポートしていません。所"
"有ベクタが最も便利な場合がしばしばあります。"

#. type: Plain text
#: doc/tutorial.md:1292
msgid "Square brackets denote indexing into a vector:"
msgstr "角括弧はベクタの添字を表します。"

#. type: Plain text
#: doc/tutorial.md:1304
#, no-wrap
msgid ""
"~~~~\n"
"# enum Crayon { Almond, AntiqueBrass, Apricot,\n"
"#               Aquamarine, Asparagus, AtomicTangerine,\n"
"#               BananaMania, Beaver, Bittersweet };\n"
"# fn draw_scene(c: Crayon) { }\n"
"let crayons: [Crayon, ..3] = [BananaMania, Beaver, Bittersweet];\n"
"match crayons[0] {\n"
"    Bittersweet => draw_scene(crayons[0]),\n"
"    _ => ()\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1306
msgid "A vector can be destructured using pattern matching:"
msgstr "ベクタはパターンマッチにより destructuring することができます。"

#. type: Plain text
#: doc/tutorial.md:1316
#, no-wrap
msgid ""
"~~~~\n"
"let numbers: &[int] = &[1, 2, 3];\n"
"let score = match numbers {\n"
"    [] => 0,\n"
"    [a] => a * 10,\n"
"    [a, b] => a * 6 + b * 4,\n"
"    [a, b, c, ..rest] => a * 5 + b * 3 + c * 2 + rest.len() as int\n"
"};\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1320
msgid ""
"The elements of a vector _inherit the mutability of the vector_, and as "
"such, individual elements may not be reassigned when the vector lives in an "
"immutable slot."
msgstr ""
"ベクタの要素は、 __ベクタのミュータビリティを継承するので__、ベクタがイミュー"
"タブルなスロットに格納されている場合は個々の要素を変更する (再代入する) こと"
"はできません。"

#. type: Plain text
#: doc/tutorial.md:1326
#, no-wrap
msgid ""
"~~~ {.xfail-test}\n"
"# enum Crayon { Almond, AntiqueBrass, Apricot,\n"
"#               Aquamarine, Asparagus, AtomicTangerine,\n"
"#               BananaMania, Beaver, Bittersweet };\n"
"let crayons: ~[Crayon] = ~[BananaMania, Beaver, Bittersweet];\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1329
msgid "crayons[0] = Apricot; // ERROR: Can't assign to immutable vector ~~~"
msgstr ""
"crayons[0] = Apricot; // ERROR: Can't assign to immutable vector\n"
"~~~"

#. type: Plain text
#: doc/tutorial.md:1331
msgid "Moving it into a mutable slot makes the elements assignable."
msgstr ""
"ベクタをミュータブルなスロットに移動することで、要素への代入が可能になりま"
"す。"

#. type: Plain text
#: doc/tutorial.md:1337
#, no-wrap
msgid ""
"~~~\n"
"# enum Crayon { Almond, AntiqueBrass, Apricot,\n"
"#               Aquamarine, Asparagus, AtomicTangerine,\n"
"#               BananaMania, Beaver, Bittersweet };\n"
"let crayons: ~[Crayon] = ~[BananaMania, Beaver, Bittersweet];\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1340
msgid ""
"// Put the vector into a mutable slot let mut mutable_crayons = crayons;"
msgstr ""
"// ベクタをミュータブルなスロットに配置する\n"
"let mut mutable_crayons = crayons;"

#. type: Plain text
#: doc/tutorial.md:1344
msgid "// Now it's mutable to the bone mutable_crayons[0] = Apricot; ~~~"
msgstr ""
"// 完全にミュータブルになった\n"
"mutable_crayons[0] = Apricot;\n"
"~~~"

#. type: Plain text
#: doc/tutorial.md:1347
msgid ""
"This is a simple example of Rust's _dual-mode data structures_, also "
"referred to as _freezing and thawing_."
msgstr ""
"これは、__凍結および解凍__ (_freezing and thawing_) と呼ばれる、Rust の __"
"デュアルモードのデータ構造__ についての簡単な例です。"

#. type: Plain text
#: doc/tutorial.md:1355
msgid ""
"Strings are implemented with vectors of `u8`, though they have a distinct "
"type. They support most of the same allocation options as vectors, though "
"the string literal without a storage sigil (for example, `\"foo\"`) is "
"treated differently than a comparable vector (`[foo]`).  Whereas plain "
"vectors are stack-allocated fixed-length vectors, plain strings are borrowed "
"pointers to read-only (static)  memory. All strings are immutable."
msgstr ""
"文字列は `u8` 型のベクタとして実装されていますが、ベクタとは異なる独自の型を"
"持ちます。文字列はベクタと同じくメモリを獲得先を選択できますが、ストレージを"
"表すシジルが付与されていない文字列リテラル (`\"foo\"` など) は対応するベクタ "
"(`[foo]`) と異なった扱いをされます。シジルなしのベクタはスタックに獲得される"
"固定長のベクタですが、シジルなしの文字列は読み込み専用の (静的な) メモリ領域"
"への借用ポインタとなります。すべての文字列はイミュータブルです。"

#. type: Plain text
#: doc/tutorial.md:1359
msgid ""
"~~~ // A plain string is a slice to read-only (static) memory let "
"stack_crayons: &str = \"Almond, AntiqueBrass, Apricot\";"
msgstr ""
"~~~\n"
"// シジルなしの文字列は、読み込み専用な (静的) メモリへのスライス\n"
"let stack_crayons: &str = \"Almond, AntiqueBrass, Apricot\";"

#. type: Plain text
#: doc/tutorial.md:1362
msgid ""
"// The same thing, but with the `&` let stack_crayons: &str = &\"Aquamarine, "
"Asparagus, AtomicTangerine\";"
msgstr ""
"// `&` を付与した場合も、シジルなしと同じ意味\n"
"let stack_crayons: &str = &\"Aquamarine, Asparagus, AtomicTangerine\";"

#. type: Plain text
#: doc/tutorial.md:1365
msgid ""
"// A local heap (managed) string let local_crayons: @str = @\"BananaMania, "
"Beaver, Bittersweet\";"
msgstr ""
"// ローカルヒープ上の (マネージドな) 文字列\n"
"let local_crayons: @str = @\"BananaMania, Beaver, Bittersweet\";"

#. type: Plain text
#: doc/tutorial.md:1369
msgid ""
"// An exchange heap (owned) string let exchange_crayons: ~str = ~\"Black, "
"BlizzardBlue, Blue\"; ~~~"
msgstr ""
"// 交換ヒープ上の (所有) 文字列\n"
"let exchange_crayons: ~str = ~\"Black, BlizzardBlue, Blue\";\n"
"~~~"

#. type: Plain text
#: doc/tutorial.md:1373
msgid ""
"Both vectors and strings support a number of useful [methods](#methods), "
"defined in [`std::vec`] and [`std::str`]. Here are some examples."
msgstr ""
"ベクタと文字列は、[`std::vec`] と [`std::str`] で定義された、多くの有用な [メ"
"ソッド](#methods) を持ちます。以下にいくつか例を挙げます。"

#. type: Plain text
#: doc/tutorial.md:1376
msgid "[`std::vec`]: std/vec.html [`std::str`]: std/str.html"
msgstr ""
"[`std::vec`]: std/vec.html\n"
"[`std::str`]: std/str.html"

#. type: Plain text
#: doc/tutorial.md:1387
#, no-wrap
msgid ""
"~~~\n"
"# enum Crayon {\n"
"#     Almond, AntiqueBrass, Apricot,\n"
"#     Aquamarine, Asparagus, AtomicTangerine,\n"
"#     BananaMania, Beaver, Bittersweet\n"
"# }\n"
"# fn unwrap_crayon(c: Crayon) -> int { 0 }\n"
"# fn eat_crayon_wax(i: int) { }\n"
"# fn store_crayon_in_nasal_cavity(i: uint, c: Crayon) { }\n"
"# fn crayon_to_str(c: Crayon) -> &str { \"\" }\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1389
msgid "let crayons = [Almond, AntiqueBrass, Apricot];"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1393
msgid ""
"// Check the length of the vector assert!(crayons.len() == 3); assert!(!"
"crayons.is_empty());"
msgstr ""
"// ベクタの長さをチェックする\n"
"assert!(crayons.len() == 3);\n"
"assert!(!crayons.is_empty());"

#. type: Plain text
#: doc/tutorial.md:1400
#, no-wrap
msgid ""
"// Iterate over a vector, obtaining a pointer to each element\n"
"// (`for` is explained in the container/iterator tutorial)\n"
"for crayon in crayons.iter() {\n"
"    let delicious_crayon_wax = unwrap_crayon(*crayon);\n"
"    eat_crayon_wax(delicious_crayon_wax);\n"
"}\n"
msgstr ""
"// ベクタの要素をイテレートし、各要素へのポインタを取得する\n"
"// (`for` については、は次の章で説明します)\n"
"for crayon in crayons.iter() {\n"
"    let delicious_crayon_wax = unwrap_crayon(*crayon);\n"
"    eat_crayon_wax(delicious_crayon_wax);\n"
"}\n"

#. type: Plain text
#: doc/tutorial.md:1404
msgid ""
"// Map vector elements let crayon_names = crayons.map(|v| "
"crayon_to_str(*v)); let favorite_crayon_name = crayon_names[0];"
msgstr ""
"// ベクタの要素をマッピング (変換) する\n"
"let crayon_names = crayons.map(|v| crayon_to_str(*v));\n"
"let favorite_crayon_name = crayon_names[0];"

#. type: Plain text
#: doc/tutorial.md:1407
msgid ""
"// Remove whitespace from before and after the string let "
"new_favorite_crayon_name = favorite_crayon_name.trim();"
msgstr ""
"// 文字列の先頭と末尾の空白を除去する\n"
"let new_favorite_crayon_name = favorite_crayon_name.trim();"

#. type: Plain text
#: doc/tutorial.md:1413
#, no-wrap
msgid ""
"if favorite_crayon_name.len() > 5 {\n"
"   // Create a substring\n"
"   println(favorite_crayon_name.slice_chars(0, 5));\n"
"}\n"
"~~~\n"
msgstr ""
"if favorite_crayon_name.len() > 5 {\n"
"   // 部分文字列を作る\n"
"   println(favorite_crayon_name.slice_chars(0, 5));\n"
"}\n"
"~~~\n"

#. type: Plain text
#: doc/tutorial.md:1415
msgid "# Closures"
msgstr "# クロージャ"

#. type: Plain text
#: doc/tutorial.md:1420
msgid ""
"Named functions, like those we've seen so far, may not refer to local "
"variables declared outside the function: they do not close over their "
"environment (sometimes referred to as \"capturing\" variables in their "
"environment). For example, you couldn't write the following:"
msgstr ""
"これまで登場したような名前のある関数は、関数の外で定義されるローカル変数を参"
"照することはできません。ローカル変数は環境を閉じ込める (環境中の変数を「キャ"
"プチャする」と呼ばれることもあります) ことはありません。例えば、以下のような"
"コードを書くことはできません。"

#. type: Plain text
#: doc/tutorial.md:1423
msgid "~~~~ {.ignore} let foo = 10;"
msgstr ""
"~~~~ {.ignore}\n"
"let foo = 10;"

#. type: Plain text
#: doc/tutorial.md:1428
#, no-wrap
msgid ""
"fn bar() -> int {\n"
"   return foo; // `bar` cannot refer to `foo`\n"
"}\n"
"~~~~\n"
msgstr ""
"fn bar() -> int {\n"
"   return foo; // `bar` ば `foo` を参照できない\n"
"}\n"
"~~~~\n"

#. type: Plain text
#: doc/tutorial.md:1431
msgid ""
"Rust also supports _closures_, functions that can access variables in the "
"enclosing scope."
msgstr ""
"Rust は __クロージャ__ という、周囲のスコープの変数にアクセスできる関数をサ"
"ポートしています。"

#. type: Plain text
#: doc/tutorial.md:1434
msgid "~~~~ fn call_closure_with_ten(b: |int|) { b(10); }"
msgstr ""
"~~~~\n"
"fn call_closure_with_ten(b: |int|) { b(10); }"

#. type: Plain text
#: doc/tutorial.md:1437
msgid ""
"let captured_var = 20; let closure = |arg| println(fmt!(\"captured_var=%d, "
"arg=%d\", captured_var, arg));"
msgstr ""
"let captured_var = 20;\n"
"let closure = |arg| println(fmt!(\"captured_var=%d, arg=%d\", captured_var, "
"arg));"

#. type: Plain text
#: doc/tutorial.md:1440
msgid "call_closure_with_ten(closure); ~~~~"
msgstr ""
"call_closure_with_ten(closure);\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:1446
msgid ""
"Closures begin with the argument list between vertical bars and are followed "
"by a single expression. Remember that a block, `{ <expr1>; <expr2>; ... }`, "
"is considered a single expression: it evaluates to the result of the last "
"expression it contains if that expression is not followed by a semicolon, "
"otherwise the block evaluates to `()`."
msgstr ""
"クロージャはバーティカルバー (`|`) で囲まれた引数リストと、それに続く単一の式"
"から構成されます。ブロック `{ <expr1>; <expr2>; ...}` は単一の式とみなされる"
"ことを思い出してください。ブロックに含まれる最後の式に続けてセミコロンがない"
"場合、ブロックの値は最後の式の値となり、そうでなければ `()` となります。"

#. type: Plain text
#: doc/tutorial.md:1451
msgid ""
"The types of the arguments are generally omitted, as is the return type, "
"because the compiler can almost always infer them. In the rare case where "
"the compiler needs assistance, though, the arguments and return types may be "
"annotated."
msgstr ""
"引数の型や戻り値の型は、ほとんどすべての場合においてコンパイラにより推論され"
"るため、通常省略できます。発生するのはまれですが、コンパイラが推論に失敗する"
"場合は、引数と戻り値の型注釈を付けることがあります。"

#. type: Plain text
#: doc/tutorial.md:1455
msgid "~~~~ let square = |x: int| -> uint { (x * x) as uint }; ~~~~"
msgstr ""
"~~~~\n"
"let square = |x: int| -> uint { (x * x) as uint };\n"
"~~~~~~~~\n"

#. type: Plain text
#: doc/tutorial.md:1459
msgid ""
"There are several forms of closure, each with its own role. The most common, "
"called a _stack closure_, has type `||` and can directly access local "
"variables in the enclosing scope."
msgstr ""
"クロージャにはいくつかの形態があり、それぞれに独自の役割があります。最も一般"
"的なのはスタッククロージャと呼ばれるもので、 `||` という型を持ち、外側のロー"
"カル変数に直接アクセスすることができます。"

#. type: Plain text
#: doc/tutorial.md:1464
msgid "~~~~ let mut max = 0; [1, 2, 3].map(|x| if *x > max { max = *x }); ~~~~"
msgstr ""
"~~~~\n"
"let mut max = 0;\n"
"[1, 2, 3].map(|x| if *x > max { max = *x });\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:1473
msgid ""
"Stack closures are very efficient because their environment is allocated on "
"the call stack and refers by pointer to captured locals. To ensure that "
"stack closures never outlive the local variables to which they refer, stack "
"closures are not first-class. That is, they can only be used in argument "
"position; they cannot be stored in data structures or returned from "
"functions. Despite these limitations, stack closures are used pervasively in "
"Rust code."
msgstr ""
"スタッククロージャは、閉じ込める環境はコールスタック上に獲得され、ローカル変"
"数をポインタで参照するため、非常に効率的です。スタッククロージャが参照してい"
"るローカル変数よりも長生きしないことを保証するため、スタッククロージャは第一"
"級の値ではありません。すなわち、スタッククロージャは引数としてしか使うことが"
"できず、データ構造や関数の戻り値となることはありません。この制限にも関わら"
"ず、スタッククロージャは Rust のコードのあちこちに登場します。"

#. type: Plain text
#: doc/tutorial.md:1475
msgid "## Managed closures"
msgstr "## マネージドクロージャ"

#. type: Plain text
#: doc/tutorial.md:1481
msgid ""
"When you need to store a closure in a data structure, a stack closure will "
"not do, since the compiler will refuse to let you store it. For this "
"purpose, Rust provides a type of closure that has an arbitrary lifetime, "
"written `@fn` (boxed closure, analogous to the `@` pointer type described "
"earlier). This type of closure *is* first-class."
msgstr ""
"クロージャをデータ構造に格納する必要がある場合、スタッククロージャを利用する"
"ことは言語仕様上、許可されていませんRust は、このような目的のために任意の寿命"
"を持つクロージャ型、`@fn` (ボックスクロージャ、 前述の `@` ポインタ型と似たよ"
"うなもの) を提供しています。この種のクロージャ **は** 第一級の値です。"

#. type: Plain text
#: doc/tutorial.md:1486
msgid ""
"A managed closure does not directly access its environment, but merely "
"copies out the values that it closes over into a private data structure. "
"This means that it can not assign to these variables, and cannot observe "
"updates to them."
msgstr ""
"マネージドクロージャは環境に直接アクセスすることはできませんが、単に値をコ"
"ピーしてプライベートなデータ構造に閉じ込めます。これは、クロージャは変数に値"
"を代入することや、値の変更を監視することもできません。"

#. type: Plain text
#: doc/tutorial.md:1489
msgid ""
"This code creates a closure that adds a given string to its argument, "
"returns it from a function, and then calls it:"
msgstr ""
"このコードは、与えられた文字列を引数に追加するクロージャを返却する関数と、そ"
"の呼び出しです。"

#. type: Plain text
#: doc/tutorial.md:1495
#, no-wrap
msgid ""
"~~~~\n"
"fn mk_appender(suffix: ~str) -> @fn(~str) -> ~str {\n"
"    // The compiler knows that we intend this closure to be of type @fn\n"
"    return |s| s + suffix;\n"
"}\n"
msgstr ""
"~~~~\n"
"fn mk_appender(suffix: ~str) -> @fn(~str) -> ~str {\n"
"    // コンパイラはこのクロージャが @fn 型であることを推論します\n"
"    return |s| s + suffix;\n"
"}\n"

#. type: Plain text
#: doc/tutorial.md:1501
#, no-wrap
msgid ""
"fn main() {\n"
"    let shout = mk_appender(~\"!\");\n"
"    println(shout(~\"hey ho, let's go\"));\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1503
msgid "## Owned closures"
msgstr "## 所有クロージャ"

#. type: Plain text
#: doc/tutorial.md:1510
msgid ""
"Owned closures, written `proc`, hold on to "
"things that can safely be sent between processes. They copy the values they "
"close over, much like managed closures, but they also own them: that is, no "
"other code can access them. Owned closures are used in concurrent code, "
"particularly for spawning [tasks][tasks]."
msgstr ""
"`~` `proc` で書き表される所有クロージャは安全にプロセス"
"間で送信することができます。所有クローじゃはマネージドクロージャと全く同じよ"
"うに閉じ込める値をコピーしますが、値を所有します。つまり、他のコードは閉じ込"
"められた値にアクセスできなくなります。所有クロージャは並列プログラム、特に "
"[タスク][tasks] 生成で利用されます。"

#. type: Plain text
#: doc/tutorial.md:1512
msgid "## Closure compatibility"
msgstr "## クロージャの互換性"

#. type: Plain text
#: doc/tutorial.md:1519
msgid ""
"Rust closures have a convenient subtyping property: you can pass any kind of "
"closure (as long as the arguments and return types match) to functions that "
"expect a `||`. Thus, when writing a higher-order function that only calls "
"its function argument, and does nothing else with it, you should almost "
"always declare the type of that argument as `||`. That way, callers may "
"pass any kind of closure."
msgstr ""
"Rust のクロージャは型の派生 (subtyping) という便利な性質を持っています。この"
"性質により、`||` 型を期待する関数には (引数と戻り値の型が一致する限り) 任"
"意の種類のクロージャを渡すことができます。したがって、引数で渡された関数につ"
"いては呼び出すだけで他に何もしない高階関数を書くときには、ほぼすべてのケース"
"で引数の型を `||` と宣言するべきです。そうすることで、呼び出し元は任意の種類"
"のクロージャを渡すことができるよになります。"

#. type: Plain text
#: doc/tutorial.md:1527
msgid ""
"~~~~ fn call_twice(f: ||) { f(); f(); } let closure = || { \"I'm a "
"closure, and it doesn't matter what type I am\"; }; fn function() { \"I'm a "
"normal function\"; } call_twice(closure); call_twice(function); ~~~~"
msgstr ""
"~~~~\n"
"fn call_twice(f: ||) { f(); f(); }\n"
"let closure = || { \"I'm a closure, and it doesn't matter what type I am"
"\"; };\n"
"fn function() { \"I'm a normal function\"; }\n"
"call_twice(closure);\n"
"call_twice(function);\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:1531
msgid ""
"> ***Note:*** Both the syntax and the semantics will be changing > in small "
"ways. At the moment they can be unsound in some > scenarios, particularly "
"with non-copyable types."
msgstr ""
"> ***注意*** コードの文法と意味は将来的に変更されるかもしれません。現時点では"
"いくつかの状況、特にコピーできない型が関連するケースにおいて望ましくない振る"
"舞いが起こされる場合があります。"

#. type: Plain text
#: doc/tutorial.md:1533
msgid "## Do syntax"
msgstr "## do 構文"

#. type: Plain text
#: doc/tutorial.md:1536
msgid ""
"The `do` expression provides a way to treat higher-order functions "
"(functions that take closures as arguments) as control structures."
msgstr ""
"`do` 式は高階関数 (クロージャを引数にとる関数) を制御構造のように取り扱う方法"
"を提供します。"

#. type: Plain text
#: doc/tutorial.md:1539
msgid ""
"Consider this function that iterates over a vector of integers, passing in a "
"pointer to each integer in the vector:"
msgstr ""
"要素が整数のベクトルをイテレートし、各整数へのポインタをクロージャへと渡す、"
"以下の関数について考えます。"

#. type: Plain text
#: doc/tutorial.md:1549
#, no-wrap
msgid ""
"~~~~\n"
"fn each(v: &[int], op: |v: &int|) {\n"
"   let mut n = 0;\n"
"   while n < v.len() {\n"
"       op(&v[n]);\n"
"       n += 1;\n"
"   }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1553
msgid ""
"As a caller, if we use a closure to provide the final operator argument, we "
"can write it in a way that has a pleasant, block-like structure."
msgstr ""
"最後の引数にクロージャをとる関数を呼び出す場合、ブロック構造を持つかのように"
"コードを書くことが可能です。"

#. type: Plain text
#: doc/tutorial.md:1561
#, no-wrap
msgid ""
"~~~~\n"
"# fn each(v: &[int], op: |v: &int|) { }\n"
"# fn do_some_work(i: &int) { }\n"
"each([1, 2, 3], |n| {\n"
"    do_some_work(n);\n"
"});\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1564
msgid ""
"This is such a useful pattern that Rust has a special form of function call "
"that can be written more like a built-in control structure:"
msgstr ""
"このような便利なパターンに対応するため、Rust には、言語組み込みの制御構造のよ"
"うな記述が可能な、特別な関数呼び出し形式があります。"

#. type: Plain text
#: doc/tutorial.md:1572
#, no-wrap
msgid ""
"~~~~\n"
"# fn each(v: &[int], op: |v: &int|) { }\n"
"# fn do_some_work(i: &int) { }\n"
"do each([1, 2, 3]) |n| {\n"
"    do_some_work(n);\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1577
msgid ""
"The call is prefixed with the keyword `do` and, instead of writing the final "
"closure inside the argument list, it appears outside of the parentheses, "
"where it looks more like a typical block of code."
msgstr ""
"関数呼び出しの前には `do` キーワードをつけ、引数リストの中に最後のクロージャ"
"引数を書くのではなく、普通のコードブロックのように、丸括弧の外に記述します。"

#. type: Plain text
#: doc/tutorial.md:1582
msgid ""
"`do` is a convenient way to create tasks with the `task::spawn` function.  "
"`spawn` has the signature `spawn(fn: proc())`. In other words, it is a "
"function that takes an owned closure that takes no arguments."
msgstr ""
"`task::spawn` 関数を用いてタスクを生成する場合、 `do` を用いると便利です。"
"`spawn` は、 `spawn(fn: proc())` という方を持っています。言い換えると、"
"`spawn` は「引数をとらない所有クロージャ」を引数としてとる関数ということで"
"す。"

#. type: Plain text
#: doc/tutorial.md:1585 doc/tutorial.md:1597
msgid "~~~~ use std::task::spawn;"
msgstr ""
"~~~~\n"
"use std::task::spawn;"

#. type: Plain text
#: doc/tutorial.md:1590
#, no-wrap
msgid ""
"do spawn() || {\n"
"    debug!(\"I'm a task, whatever\");\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1594
msgid ""
"Look at all those bars and parentheses -- that's two empty argument lists "
"back to back. Since that is so unsightly, empty argument lists may be "
"omitted from `do` expressions."
msgstr ""
"このコードの丸括弧と縦棒に注目してください。立て続けに2の空の引数リストが現れ"
"ているます。これは非常に見苦しいので、`do` 式では空の引数リストを省略すること"
"が可能です。"

#. type: Plain text
#: doc/tutorial.md:1602
#, no-wrap
msgid ""
"do spawn {\n"
"   debug!(\"Kablam!\");\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1605
msgid ""
"If you want to see the output of `debug!` statements, you will need to turn "
"on `debug!` logging.  To enable `debug!` logging, set the RUST_LOG "
"environment variable to the name of your crate, which, for a file named `foo."
"rs`, will be `foo` (e.g., with bash, `export RUST_LOG=foo`)."
msgstr ""
"`debug!` ステートメントの出力を見たい場合、`debug!` によるロギングを有効にす"
"る必要があるでしょう。`debug!` によるロギングを有効にするためには、 RUST_LOG "
"環境変数をクレートの名前に設定する必要があります (例えば、bash の場合、 "
"`export RUST_LOG=foo` を実行する)。 `foo.rs` というファイルの場合、クレート名"
"は `foo` になります。"

#. type: Plain text
#: doc/tutorial.md:1607
msgid "# Methods"
msgstr "# メソッド"

#. type: Plain text
#: doc/tutorial.md:1613
msgid ""
"Methods are like functions except that they always begin with a special "
"argument, called `self`, which has the type of the method's receiver. The "
"`self` argument is like `this` in C++ and many other languages.  Methods are "
"called with dot notation, as in `my_vec.len()`."
msgstr ""
"メソッドは、`self` という、メソッドのレシーバと同じ型の特別な引数を第一引数と"
"してとる関数のようなものです。`self` は、 C++ や他の言語の `this` のようなも"
"のです。メソッドはドット記法を浸かって `my_vec.len()` のように呼び出します。"

#. type: Plain text
#: doc/tutorial.md:1617
msgid ""
"_Implementations_, written with the `impl` keyword, can define methods on "
"most Rust types, including structs and enums.  As an example, let's define a "
"`draw` method on our `Shape` enum."
msgstr ""
"`impl` キーワードを使って記述される __実装__ (_implementation_) により、構造"
"体や列挙型を含むほとんどの Rust の型に対してメソッドを定義することができま"
"す。例のように、 `draw` メソッドを `Shape` 列挙型に定義してみましょう。"

#. type: Plain text
#: doc/tutorial.md:1625
#, no-wrap
msgid ""
"~~~\n"
"# fn draw_circle(p: Point, f: f64) { }\n"
"# fn draw_rectangle(p: Point, p: Point) { }\n"
"struct Point {\n"
"    x: f64,\n"
"    y: f64\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1630
#, no-wrap
msgid ""
"enum Shape {\n"
"    Circle(Point, f64),\n"
"    Rectangle(Point, Point)\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1639
#, no-wrap
msgid ""
"impl Shape {\n"
"    fn draw(&self) {\n"
"        match *self {\n"
"            Circle(p, f) => draw_circle(p, f),\n"
"            Rectangle(p1, p2) => draw_rectangle(p1, p2)\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1643
msgid "let s = Circle(Point { x: 1f, y: 2f }, 3f); s.draw(); ~~~"
msgstr ""
"let s = Circle(Point { x: 1f, y: 2f }, 3f);\n"
"s.draw();\n"
"~~~"

#. type: Plain text
#: doc/tutorial.md:1647
msgid ""
"This defines an _implementation_ for `Shape` containing a single method, "
"`draw`. In most respects the `draw` method is defined like any other "
"function, except for the name `self`."
msgstr ""
"この例では、 `Shape` に1つのメソッド `draw` をもつ __実装__ を定義していま"
"す。`draw` メソッドは、`self` という名前を除くほとんどの面で他の関数と同じよ"
"うに定義されます。"

#. type: Plain text
#: doc/tutorial.md:1652
msgid ""
"The type of `self` is the type on which the method is implemented, or a "
"pointer thereof. As an argument it is written either `self`, `&self`, "
"`@self`, or `~self`.  A caller must in turn have a compatible pointer type "
"to call the method."
msgstr ""
"`self` の型は、メソッドが実装されている型か、それらのポインタである。引数とし"
"ては、 `self`, `&self`, `@self` または `~self` と記述されます。呼び出し側も同"
"様、メソッドを呼び出すための互換性のあるポインタ型をもつ必要があります。"

#. type: Plain text
#: doc/tutorial.md:1667
#, no-wrap
msgid ""
"~~~\n"
"# fn draw_circle(p: Point, f: f64) { }\n"
"# fn draw_rectangle(p: Point, p: Point) { }\n"
"# struct Point { x: f64, y: f64 }\n"
"# enum Shape {\n"
"#     Circle(Point, f64),\n"
"#     Rectangle(Point, Point)\n"
"# }\n"
"impl Shape {\n"
"    fn draw_borrowed(&self) { ... }\n"
"    fn draw_managed(@self) { ... }\n"
"    fn draw_owned(~self) { ... }\n"
"    fn draw_value(self) { ... }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1669
msgid "let s = Circle(Point { x: 1f, y: 2f }, 3f);"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1675
msgid ""
"(@s).draw_managed(); (~s).draw_owned(); (&s).draw_borrowed(); s."
"draw_value(); ~~~"
msgstr ""
"(@s).draw_managed();\n"
"(~s).draw_owned();\n"
"(&s).draw_borrowed();\n"
"s.draw_value();\n"
"~~~"

#. type: Plain text
#: doc/tutorial.md:1679
msgid ""
"Methods typically take a borrowed pointer self type, so the compiler will go "
"to great lengths to convert a callee to a borrowed pointer."
msgstr ""
"多くのメソッドは、借用ポインタの self 型を持つので、コンパイラは呼び出し先を"
"借用ポインタに変換するためあらゆる手段を講じます。"

#. type: Plain text
#: doc/tutorial.md:1697
#, no-wrap
msgid ""
"~~~\n"
"# fn draw_circle(p: Point, f: f64) { }\n"
"# fn draw_rectangle(p: Point, p: Point) { }\n"
"# struct Point { x: f64, y: f64 }\n"
"# enum Shape {\n"
"#     Circle(Point, f64),\n"
"#     Rectangle(Point, Point)\n"
"# }\n"
"# impl Shape {\n"
"#    fn draw_borrowed(&self) { ... }\n"
"#    fn draw_managed(@self) { ... }\n"
"#    fn draw_owned(~self) { ... }\n"
"#    fn draw_value(self) { ... }\n"
"# }\n"
"# let s = Circle(Point { x: 1f, y: 2f }, 3f);\n"
"// As with typical function arguments, managed and owned pointers\n"
"// are automatically converted to borrowed pointers\n"
msgstr ""
"~~~\n"
"# fn draw_circle(p: Point, f: f64) { }\n"
"# fn draw_rectangle(p: Point, p: Point) { }\n"
"# struct Point { x: f64, y: f64 }\n"
"# enum Shape {\n"
"#     Circle(Point, f64),\n"
"#     Rectangle(Point, Point)\n"
"# }\n"
"# impl Shape {\n"
"#    fn draw_borrowed(&self) { ... }\n"
"#    fn draw_managed(@self) { ... }\n"
"#    fn draw_owned(~self) { ... }\n"
"#    fn draw_value(self) { ... }\n"
"# }\n"
"# let s = Circle(Point { x: 1f, y: 2f }, 3f);\n"
"// 関数の引数と同様、マネージドポインタと所有ポインタは、\n"
"// 自動的に借用ポインタに変換される\n"

#. type: Plain text
#: doc/tutorial.md:1700
msgid "(@s).draw_borrowed(); (~s).draw_borrowed();"
msgstr ""
"(@s).draw_borrowed();\n"
"(~s).draw_borrowed();"

#. type: Plain text
#: doc/tutorial.md:1704
msgid ""
"// Unlike typical function arguments, the self value will // automatically "
"be referenced ...  s.draw_borrowed();"
msgstr ""
"// 関数の引数とは異なり、 self の値は自動的にリファレンスされたり、 ...\n"
"s.draw_borrowed();"

#. type: Plain text
#: doc/tutorial.md:1707
msgid "// ... and dereferenced (& &s).draw_borrowed();"
msgstr ""
"// ... デリファレンスされたり、\n"
"(& &s).draw_borrowed();"

#. type: Plain text
#: doc/tutorial.md:1711
msgid "// ... and dereferenced and borrowed (&@~s).draw_borrowed(); ~~~"
msgstr ""
"// ... デリファレンス後借用されたりします\n"
"(&@~s).draw_borrowed();\n"
"~~~"

#. type: Plain text
#: doc/tutorial.md:1715
msgid ""
"Implementations may also define standalone (sometimes called \"static\")  "
"methods. The absence of a `self` parameter distinguishes such methods.  "
"These methods are the preferred way to define constructor functions."
msgstr ""
"実装では、スタンドアロンなメソッド (「静的 (static)」メソッドと呼ばれる場合も"
"あります)を定義することも可能です。引数に `self` をつけない場合、スタンドアロ"
"ンなメソッドとなります。コンストラクタ関数は、スタンドアロンなメソッドとして"
"定義することが推奨されています。"

#. type: Plain text
#: doc/tutorial.md:1722
#, no-wrap
msgid ""
"~~~~ {.xfail-test}\n"
"impl Circle {\n"
"    fn area(&self) -> f64 { ... }\n"
"    fn new(area: f64) -> Circle { ... }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1724
msgid ""
"To call such a method, just prefix it with the type name and a double colon:"
msgstr ""
"メソッド名の前に型名と2つのコロンを付けることで、スタンドアロンメソッドは呼び"
"出せます。"

#. type: Plain text
#: doc/tutorial.md:1733
#, no-wrap
msgid ""
"~~~~\n"
"use std::f64::consts::pi;\n"
"struct Circle { radius: f64 }\n"
"impl Circle {\n"
"    fn new(area: f64) -> Circle { Circle { radius: (area / pi).sqrt() } }\n"
"}\n"
"let c = Circle::new(42.5);\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1735
msgid "# Generics"
msgstr "# ジェネリクス"

#. type: Plain text
#: doc/tutorial.md:1743
msgid ""
"Throughout this tutorial, we've been defining functions that act only on "
"specific data types. With type parameters we can also define functions whose "
"arguments have generic types, and which can be invoked with a variety of "
"types. Consider a generic `map` function, which takes a function `function` "
"and a vector `vector` and returns a new vector consisting of the result of "
"applying `function` to each element of `vector`:"
msgstr ""
"このチュートリアルでは、特定のデータ型のみに対して動作する関数を定義してきま"
"した。型パラメータを用いるとジェネリックな型を引数にとり、様々な型で呼び出す"
"ことの可能な関数を定義できます。関数 `function` とベクタ `vector` を引数にと"
"り、`function` を`vector` の各要素に適用した結果からなる新たなベクタを返す、"
"`map` というジェネリック関数について考えます。"

#. type: Plain text
#: doc/tutorial.md:1753
#, no-wrap
msgid ""
"~~~~\n"
"fn map<T, U>(vector: &[T], function: |v: &T| -> U) -> ~[U] {\n"
"    let mut accumulator = ~[];\n"
"    for element in vector.iter() {\n"
"        accumulator.push(function(element));\n"
"    }\n"
"    return accumulator;\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1758
msgid ""
"When defined with type parameters, as denoted by `<T, U>`, this function can "
"be applied to any type of vector, as long as the type of `function`'s "
"argument and the type of the vector's contents agree with each other."
msgstr ""
"上記例で `<T, U>` と示されているように、型パラメータとともに関数を定義するこ"
"とで、`function` の引数の型と`vectror` の要素の型が一致する場合に限りますが、"
"任意の型のベクタを引数として渡すことが可能になります。"

#. type: Plain text
#: doc/tutorial.md:1768
msgid ""
"Inside a generic function, the names of the type parameters (capitalized by "
"convention) stand for opaque types. All you can do with instances of these "
"types is pass them around: you can't apply any operations to them or pattern-"
"match on them. Note that instances of generic types are often passed by "
"pointer. For example, the parameter `function()` is supplied with a pointer "
"to a value of type `T` and not a value of type `T` itself. This ensures that "
"the function works with the broadest set of types possible, since some types "
"are expensive or illegal to copy and pass by value."
msgstr ""
"ジェネリック関数の内部では、型パラメータの名前 (慣例的に大文字で表されます) "
"は不透明型 (opaque type) を意味します。これらの型のインスタンスに対しては、他"
"の関数に渡すことだけが可能で、演算子を適用したり、パターンマッチすることはで"
"きません。ジェネリック型のインスタンスは、ポインタにより渡されることもあるこ"
"とに注意してください。例えば、 `function()` パラメータが `T` 型自身の値ではな"
"く `T` 型の値へのポインタとして渡されるということです。いくつかの型は、値をコ"
"ピーするコストが高かったり、コピーが禁じられていたりするので、ポインタ渡しに"
"することで、関数の引数としてとることのできる型の範囲が広がります。"

#. type: Plain text
#: doc/tutorial.md:1770
msgid ""
"Generic `type`, `struct`, and `enum` declarations follow the same pattern:"
msgstr ""
"ジェネリックな型、構造体、および列挙型の宣言は、同じパターンに従います。"

#. type: Plain text
#: doc/tutorial.md:1774
msgid "~~~~ use std::hashmap::HashMap; type Set<T> = HashMap<T, ()>;"
msgstr ""
"~~~~\n"
"use std::hashmap::HashMap;\n"
"type Set<T> = HashMap<T, ()>;"

#. type: Plain text
#: doc/tutorial.md:1778
#, no-wrap
msgid ""
"struct Stack<T> {\n"
"    elements: ~[T]\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1784
#, no-wrap
msgid ""
"enum Option<T> {\n"
"    Some(T),\n"
"    None\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1787
msgid ""
"These declarations can be instantiated to valid types like `Set<int>`, "
"`Stack<int>`, and `Option<int>`."
msgstr ""
"これらの宣言により、 `Set<int>` や `Stack<int>`、 `Option<int>` のような正当"
"な型を生成することができます。"

#. type: Plain text
#: doc/tutorial.md:1793
msgid ""
"The last type in that example, `Option`, appears frequently in Rust code.  "
"Because Rust does not have null pointers (except in unsafe code), we need "
"another way to write a function whose result isn't defined on every possible "
"combination of arguments of the appropriate types. The usual way is to write "
"a function that returns `Option<T>` instead of `T`."
msgstr ""
"最後の例の `Option` 型は、Rust のコード中に頻繁に現れます。Rust には null ポ"
"インタが存在しない (unsafe なコードを除く) ため、引数の組み合わせがとりうるす"
"べての値に対し結果が定義されないような関数を記述するための別の方法が必要で"
"す。このような場合には、 `T` 型ではなく `Option<T>` 型を返すよう関数を定義す"
"ることが一般的です。"

#. type: Plain text
#: doc/tutorial.md:1804
#, no-wrap
msgid ""
"~~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"# enum Shape { Circle(Point, f64), Rectangle(Point, Point) }\n"
"fn radius(shape: Shape) -> Option<f64> {\n"
"    match shape {\n"
"        Circle(_, radius) => Some(radius),\n"
"        Rectangle(*)      => None\n"
"    }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1812
msgid ""
"The Rust compiler compiles generic functions very efficiently by "
"*monomorphizing* them. *Monomorphization* is a fancy name for a simple idea: "
"generate a separate copy of each generic function at each call site, a copy "
"that is specialized to the argument types and can thus be optimized "
"specifically for them. In this respect, Rust's generics have similar "
"performance characteristics to C++ templates."
msgstr ""
"Rust のコンパイラは、ジェネリック関数を *monomorphizing* することで効率的にコ"
"ンパイルします。*monomorphization* という名前は大げさに聞こえますが、考え方は"
"単純です。ジェネリック関数のコピーを関数の呼び出し箇所に別々に生成し、引数の"
"型により特殊化された各コピーは、それぞれの特性に応じて最適化が施されます。こ"
"の点において、Rust のジェネリクスは C++ のテンプレートと似たパフォーマンス上"
"の特性を持ちます。"

#. type: Plain text
#: doc/tutorial.md:1814
msgid "## Traits"
msgstr "## トレイト"

#. type: Plain text
#: doc/tutorial.md:1824
msgid ""
"Within a generic function the operations available on generic types are very "
"limited. After all, since the function doesn't know what types it is "
"operating on, it can't safely modify or query their values. This is where "
"_traits_ come into play. Traits are Rust's most powerful tool for writing "
"polymorphic code. Java developers will see them as similar to Java "
"interfaces, and Haskellers will notice their similarities to type classes. "
"Rust's traits are a form of *bounded polymorphism*: a trait is a way of "
"limiting the set of possible types that a type parameter could refer to."
msgstr ""
"ジェネリック関数の内部では、ジェネリック型に対して非常に限られた操作しか行え"
"ません。つまるところ、ジェネリック関数は操作の対象とする型が何なのか知らない"
"ため、対象の値を安全に変更・参照することができません。__トレイト__ (_trait_) "
"の出番です。トレイトは Rust でポリモーフィックなコードを書くための最も強力な"
"ツールです。Java 開発者にとってトレイトは Java のインターフェースのように見え"
"ますし、Haskeller は型クラスとの類似点に気づくでしょう。Rust のトレイトは **"
"有界ポリモーフィズム** (*bounded polymorphism*) の形式をとります。トレイトに"
"より、型パラメータが示す得る型の集合を限定することができます。"

#. type: Plain text
#: doc/tutorial.md:1832
msgid ""
"As motivation, let us consider copying in Rust.  The `clone` method is not "
"defined for all Rust types.  One reason is user-defined destructors: copying "
"a type that has a destructor could result in the destructor running multiple "
"times.  Therefore, types with destructors cannot be copied unless you "
"explicitly implement `Clone` for them."
msgstr ""
"トレイト導入の動機となる例として、Rust でのコピーについて考えます。`clone` メ"
"ソッドはすべての Rust の型に対して定義されていません。定義されていない理由の"
"一つとして、ユーザ定義のデストラクタの存在が挙げられます。デストラクタを持つ"
"型をコピーすることで、デストラクタが複数回実行されるという事態を招いてしまう"
"かもしれません。そのため、明示的に `Clone` を実装していない型を除き、デストラ"
"クタをもつ型をコピーすることはできません。"

#. type: Plain text
#: doc/tutorial.md:1837
msgid ""
"This complicates handling of generic functions.  If you have a type "
"parameter `T`, can you copy values of that type? In Rust, you can't, and if "
"you try to run the following code the compiler will complain."
msgstr ""
"このことはジェネリック関数の扱い方を複雑にします。型パラメータ `T` が存在した"
"として、この型の値をコピーすることができるでしょうか？Rust では、コピーするこ"
"とはできません。以下のコードを実行しようとしてもコンパイラが文句を言うでしょ"
"う。"

#. type: Plain text
#: doc/tutorial.md:1844
#, no-wrap
msgid ""
"~~~~ {.xfail-test}\n"
"// This does not compile\n"
"fn head_bad<T>(v: &[T]) -> T {\n"
"    v[0] // error: copying a non-copyable value\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~ {.xfail-test}\n"
"// このコードはコンパイルできない\n"
"fn head_bad<T>(v: &[T]) -> T {\n"
"    v[0] // error: copying a non-copyable value\n"
"}\n"
"~~~~\n"

#. type: Plain text
#: doc/tutorial.md:1851
msgid ""
"However, we can tell the compiler that the `head` function is only for "
"copyable types: that is, those that implement the `Clone` trait.  In that "
"case, we can explicitly create a second copy of the value we are returning "
"using the `clone` keyword:"
msgstr ""
"`head` 関数はコピー可能な型、つまり `Clone` トレイトを実装している型だけを対"
"象にしていることをコンパイラに教えることはできます。この場合、`clone` メソッ"
"ドを使うことで、値のコピーを明示的に作成し、戻り値として返すことができます。"

#. type: Plain text
#: doc/tutorial.md:1858
#, no-wrap
msgid ""
"~~~~\n"
"// This does\n"
"fn head<T: Clone>(v: &[T]) -> T {\n"
"    v[0].clone()\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~\n"
"// このコードはコンパイルできる\n"
"fn head<T: Clone>(v: &[T]) -> T {\n"
"    v[0].clone()\n"
"}\n"
"~~~~\n"

#. type: Plain text
#: doc/tutorial.md:1866
msgid ""
"This says that we can call `head` on any type `T` as long as that type "
"implements the `Clone` trait.  When instantiating a generic function, you "
"can only instantiate it with types that implement the correct trait, so you "
"could not apply `head` to a type that does not implement `Clone`."
msgstr ""
"このことは、`Clone` トレイトを実装している任意の型 `T` について、 `head` 関数"
"を呼び出すことができることを示しています。ジェネリック関数を実体化する場合、"
"正しいトレイトを実装した型を用いた場合のみ実体化できます。つまり、`Clone` ト"
"レイトを実装していない型に対して `head` を呼び出すことはできません。"

#. type: Plain text
#: doc/tutorial.md:1871
msgid ""
"While most traits can be defined and implemented by user code, two traits "
"are automatically derived and implemented for all applicable types by the "
"compiler, and may not be overridden:"
msgstr ""
"ほとんどのトレイトはユーザコードにより定義・実装できますが、2つのトレイトはコ"
"ンパイラにより自動的に導出され、適用可能なすべての型に対し自動的に実装され、"
"上書きすることはできません。"

#. type: Plain text
#: doc/tutorial.md:1875
#, no-wrap
msgid ""
"* `Send` - Sendable types.\n"
"Types are sendable\n"
"unless they contain managed boxes, managed closures, or borrowed pointers.\n"
msgstr ""
"* `Send` - 送信可能な型。\n"
"マネージドボックスやマネージドクロージャ、借用ポインタを含まない場合、型は送信可能である。"

#. type: Plain text
#: doc/tutorial.md:1880
#, no-wrap
msgid ""
"* `Freeze` - Constant (immutable) types.\n"
"These are types that do not contain anything intrinsically mutable.\n"
"Intrinsically mutable values include `@mut`\n"
"and `Cell` in the standard library.\n"
msgstr ""
"* `Freeze` - 定数 (イミュータブル) 型。\n"
"本質的に変更可能な値を含まない型のことです。本質的に変更可能な値には、`@mut` や標準ライブラリで定義されている `Cell` が含まれます。\n"

#. type: Plain text
#: doc/tutorial.md:1883
msgid ""
"> ***Note:*** These two traits were referred to as 'kinds' in earlier > "
"iterations of the language, and often still are."
msgstr ""
"> ***注意*** これら2つのトレイトは、以前は 「種」 (kind) と呼ばれており、現在"
"でもそう呼ばれる場合があります。"

#. type: Plain text
#: doc/tutorial.md:1889
msgid ""
"Additionally, the `Drop` trait is used to define destructors. This trait "
"defines one method called `drop`, which is automatically called when a value "
"of the type that implements this trait is destroyed, either because the "
"value went out of scope or because the garbage collector reclaimed it."
msgstr ""
"上記に加え、 `Drop` トレイトはデストラクタを定義するために使われます。このト"
"レイトは `drop` というこのトレイトを実装した型が破壊されるタイミング(値がス"
"コープの外に出たタイミングか、ガベージコレクタが回収するタイミング) で呼び出"
"されるメソッドを1つ定義しています。"

#. type: Plain text
#: doc/tutorial.md:1894
#, no-wrap
msgid ""
"~~~\n"
"struct TimeBomb {\n"
"    explosivity: uint\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1903
#, no-wrap
msgid ""
"impl Drop for TimeBomb {\n"
"    fn drop(&self) {\n"
"        for _ in range(0, self.explosivity) {\n"
"            println(\"blam!\");\n"
"        }\n"
"    }\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1906
msgid ""
"It is illegal to call `drop` directly. Only code inserted by the compiler "
"may call it."
msgstr ""
"`drop` を直接呼び出すことはできません。コンパイラにより挿入されたコードのみ"
"が `drop` を呼び出すことができます。"

#. type: Plain text
#: doc/tutorial.md:1908
msgid "## Declaring and implementing traits"
msgstr "## トレイトの宣言と実装"

#. type: Plain text
#: doc/tutorial.md:1914
msgid ""
"A trait consists of a set of methods without bodies, or may be empty, as is "
"the case with `Send` and `Freeze`.  For example, we could declare the trait "
"`Printable` for things that can be printed to the console, with a single "
"method:"
msgstr ""
"トレイトはボディを持たないメソッドの集合から構成されるか、 `Send` や "
"`Freeze` トレイトのように空の場合があります。例えば、コンソールに出力可能なも"
"のを表しメソッドを1つもつ `Printable` トレイトは以下のように宣言できます。"

#. type: Plain text
#: doc/tutorial.md:1920
#, no-wrap
msgid ""
"~~~~\n"
"trait Printable {\n"
"    fn print(&self);\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1925
msgid ""
"Traits may be implemented for specific types with [impls]. An impl that "
"implements a trait includes the name of the trait at the start of the "
"definition, as in the following impls of `Printable` for `int` and `~str`."
msgstr ""
"[impl][impls] により特定の型にトレイトを実装することができます。トレイトを実"
"装する impl は、以下の `Printable` の `int` と `~str` に対する実装のように、"
"定義の先頭にトレイトの名前を含みます。"

#. type: Plain text
#: doc/tutorial.md:1927
msgid "[impls]: #methods"
msgstr "[impls]: #メソッド"

#. type: Plain text
#: doc/tutorial.md:1933
#, no-wrap
msgid ""
"~~~~\n"
"# trait Printable { fn print(&self); }\n"
"impl Printable for int {\n"
"    fn print(&self) { println(fmt!(\"%d\", *self)) }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1937
#, no-wrap
msgid ""
"impl Printable for ~str {\n"
"    fn print(&self) { println(*self) }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1941
msgid "# 1.print(); # (~\"foo\").print(); ~~~~"
msgstr ""
"# 1.print();\n"
"# (~\"foo\").print();\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:1946
msgid ""
"Methods defined in an implementation of a trait may be called just like any "
"other method, using dot notation, as in `1.print()`. Traits may themselves "
"contain type parameters. A trait for generalized sequence types might look "
"like the following:"
msgstr ""
"トレイトの実装により定義されたメソッドは他のメソッドと全く同じように、ドット"
"記法を用いて `1.print()` のように呼び出せます。トレイト自体に型パラメータを持"
"たせることもできます。一般化されたシーケンスを表すトレイトは以下のように定義"
"されるでしょう。"

#. type: Plain text
#: doc/tutorial.md:1951
#, no-wrap
msgid ""
"~~~~\n"
"trait Seq<T> {\n"
"    fn length(&self) -> uint;\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1956
#, no-wrap
msgid ""
"impl<T> Seq<T> for ~[T] {\n"
"    fn length(&self) -> uint { self.len() }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:1963
msgid ""
"The implementation has to explicitly declare the type parameter that it "
"binds, `T`, before using it to specify its trait type. Rust requires this "
"declaration because the `impl` could also, for example, specify an "
"implementation of `Seq<int>`. The trait type (appearing between `impl` and "
"`for`) *refers* to a type, rather than defining one."
msgstr ""
"実装が束縛する型パラメータ `T` は、トレイトの型を指定する前に明示的に宣言しな"
"ければなりません。Rust でこの宣言が必要なのは、 `impl` では例えば `Seq<int>` "
"の実装を指定することも可能だからです。トレイトの型 (`impl` と `for` の間に現"
"れるもの) は、型を定義するのではなく、型を **参照** します。"

#. type: Plain text
#: doc/tutorial.md:1968
msgid ""
"The type parameters bound by a trait are in scope in each of the method "
"declarations. So, re-declaring the type parameter `T` as an explicit type "
"parameter for `len`, in either the trait or the impl, would be a compile-"
"time error."
msgstr ""
"トレイトにより束縛される型パラメータは、各メソッドの宣言のスコープに属しま"
"す。したがって、trait と impl のいずれかで、型パラメータ `T` を `len` で用い"
"る明示的な型パラメータとして再宣言すると、コンパイル時エラーとなります。"

#. type: Plain text
#: doc/tutorial.md:1973
msgid ""
"Within a trait definition, `Self` is a special type that you can think of as "
"a type parameter. An implementation of the trait for any given type `T` "
"replaces the `Self` type parameter with `T`. The following trait describes "
"types that support an equality operation:"
msgstr ""
"トレイトの定義内部では、`Self` は型パラメータとみなすことのできる特別な型とな"
"ります。型 `T` に対するトレイトの実装では `Self` は型パラメータ `T` で置き換"
"えられます。以下のトレイトは等価性演算をサポートする型を意味します。"

#. type: Plain text
#: doc/tutorial.md:1980
#, no-wrap
msgid ""
"~~~~\n"
"// In a trait, `self` refers to the self argument.\n"
"// `Self` refers to the type implementing the trait.\n"
"trait Eq {\n"
"    fn equals(&self, other: &Self) -> bool;\n"
"}\n"
msgstr ""
"~~~~\n"
"// trait の内側では, `self` は self 引数を指します。\n"
"// `Self` はトレイトを実装する型を指します。\n"
"trait Eq {\n"
"    fn equals(&self, other: &Self) -> bool;\n"
"}\n"

#. type: Plain text
#: doc/tutorial.md:1986
#, no-wrap
msgid ""
"// In an impl, `self` refers just to the value of the receiver\n"
"impl Eq for int {\n"
"    fn equals(&self, other: &int) -> bool { *other == *self }\n"
"}\n"
"~~~~\n"
msgstr ""
"// impl の内側では `self` はレシーバの値を指します\n"
"impl Eq for int {\n"
"    fn equals(&self, other: &int) -> bool { *other == *self }\n"
"}\n"
"~~~~\n"

#. type: Plain text
#: doc/tutorial.md:1991
msgid ""
"Notice that in the trait definition, `equals` takes a second parameter of "
"type `Self`.  In contrast, in the `impl`, `equals` takes a second parameter "
"of type `int`, only using `self` as the name of the receiver."
msgstr ""
"トレイトの定義では、`equals` の第二引数の型は `Self` であることに注意してくだ"
"さい。対照的に `impl` では、 `equals` の第二引数の型は `int` で、 `self` はレ"
"シーバの名前としてのみ使用されます。"

#. type: Plain text
#: doc/tutorial.md:1996
msgid ""
"Just as in type implementations, traits can define standalone (static)  "
"methods.  These methods are called by prefixing the method name with the "
"trait name and a double colon.  The compiler uses type inference to decide "
"which implementation to use."
msgstr ""
"型への実装の場合と同様、トレイトもスタンドアロン (静的) メソッドを定義するこ"
"とができます。メソッド名の前にトレイト名とコロン2つをつけることで、これらのメ"
"ソッドを呼び出すことができます。コンパイラはどの実装を利用するか決定するた"
"め、型推論を行います。"

#. type: Plain text
#: doc/tutorial.md:2002
msgid ""
"~~~~ use std::f64::consts::pi; trait Shape { fn new(area: f64) -> "
"Self; } struct Circle { radius: f64 } struct Square { length: f64 }"
msgstr ""
"~~~~\n"
"use std::f64::consts::pi;\n"
"trait Shape { fn new(area: f64) -> Self; }\n"
"struct Circle { radius: f64 }\n"
"struct Square { length: f64 }"

#. type: Plain text
#: doc/tutorial.md:2009
#, no-wrap
msgid ""
"impl Shape for Circle {\n"
"    fn new(area: f64) -> Circle { Circle { radius: (area / pi).sqrt() } }\n"
"}\n"
"impl Shape for Square {\n"
"    fn new(area: f64) -> Square { Square { length: (area).sqrt() } }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:2014
msgid ""
"let area = 42.5; let c: Circle = Shape::new(area); let s: Square = Shape::"
"new(area); ~~~~"
msgstr ""
"let area = 42.5;\n"
"let c: Circle = Shape::new(area);\n"
"let s: Square = Shape::new(area);\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:2016
msgid "## Bounded type parameters and static method dispatch"
msgstr "## 境界型パラメータと静的メソッドディスパッチ"

#. type: Plain text
#: doc/tutorial.md:2021
msgid ""
"Traits give us a language for defining predicates on types, or abstract "
"properties that types can have. We can use this language to define _bounds_ "
"on type parameters, so that we can then operate on generic types."
msgstr ""
"トレイトは型の述語 (predicate) や型がもつことのできる抽象的な属性を定義するた"
"めの言語として利用することができます。この言語を使うこととで型パラメータの __"
"境界__ (_bound_) を定義することができ、ジェネリックな型を操作することが可能に"
"なります。"

#. type: Plain text
#: doc/tutorial.md:2030
#, no-wrap
msgid ""
"~~~~\n"
"# trait Printable { fn print(&self); }\n"
"fn print_all<T: Printable>(printable_things: ~[T]) {\n"
"    for thing in printable_things.iter() {\n"
"        thing.print();\n"
"    }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:2036
msgid ""
"Declaring `T` as conforming to the `Printable` trait (as we earlier did with "
"`Clone`) makes it possible to call methods from that trait on values of type "
"`T` inside the function. It will also cause a compile-time error when anyone "
"tries to call `print_all` on an array whose element type does not have a "
"`Printable` implementation."
msgstr ""
"(先に登場した `Clone` の例のように) `T` が `Printable` トレイトに従うことを宣"
"言することで、関数内部で `T` 型の値に対して `Printable` トレイトのメソッドを"
"呼び出すことが可能になります。また、この宣言により、`Printable` を実装してい"
"ない型を要素とする配列に対して `print_all` 関数を呼びだそうとすると、コンパイ"
"ル時エラーとなります。"

#. type: Plain text
#: doc/tutorial.md:2039
msgid ""
"Type parameters can have multiple bounds by separating them with `+`, as in "
"this version of `print_all` that copies elements."
msgstr ""
"型パラメータは `+` で区切ることで複数の境界を持つことができます。以下の "
"`print_all` は、ベクタの要素をコピーするバージョンです。"

#. type: Plain text
#: doc/tutorial.md:2051
#, no-wrap
msgid ""
"~~~\n"
"# trait Printable { fn print(&self); }\n"
"fn print_all<T: Printable + Clone>(printable_things: ~[T]) {\n"
"    let mut i = 0;\n"
"    while i < printable_things.len() {\n"
"        let copy_of_thing = printable_things[i].clone();\n"
"        copy_of_thing.print();\n"
"        i += 1;\n"
"    }\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:2055
msgid ""
"Method calls to bounded type parameters are _statically dispatched_, "
"imposing no more overhead than normal function invocation, so are the "
"preferred way to use traits polymorphically."
msgstr ""
"境界型パラメータに対するメソッドの呼び出しは __静的にディスパッチ__ "
"(_statically dispatched_) されるため、通常の関数呼び出し以上のオーバーヘッド"
"は発生しません。そのため、ポリモーフィックにトレイトを使う方法としては、境界"
"型パラメータが推奨されます。 "

#. type: Plain text
#: doc/tutorial.md:2057
msgid "This usage of traits is similar to Haskell type classes."
msgstr "トレイトのこのような使い方は、Haskell の型クラスと似ています。"

#. type: Plain text
#: doc/tutorial.md:2059
msgid "## Trait objects and dynamic method dispatch"
msgstr "## トレイトオブジェクトと動的メソッドディスパッチ"

#. type: Plain text
#: doc/tutorial.md:2063
msgid ""
"The above allows us to define functions that polymorphically act on values "
"of a single unknown type that conforms to a given trait.  However, consider "
"this function:"
msgstr ""
"上述の例では、指定されたトレイトに従う、単一の未知の型の値についてポリモー"
"フィックにふるまう関数を定義しました。ここでは、以下の関数について考えます。"

#. type: Plain text
#: doc/tutorial.md:2069
msgid ""
"~~~~ # type Circle = int; type Rectangle = int; # impl Drawable for int { fn "
"draw(&self) {} } # fn new_circle() -> int { 1 } trait Drawable { fn "
"draw(&self); }"
msgstr ""
"~~~~\n"
"# type Circle = int; type Rectangle = int;\n"
"# impl Drawable for int { fn draw(&self) {} }\n"
"# fn new_circle() -> int { 1 }\n"
"trait Drawable { fn draw(&self); }"

#. type: Plain text
#: doc/tutorial.md:2076
#, no-wrap
msgid ""
"fn draw_all<T: Drawable>(shapes: ~[T]) {\n"
"    for shape in shapes.iter() { shape.draw(); }\n"
"}\n"
"# let c: Circle = new_circle();\n"
"# draw_all(~[c]);\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:2082
msgid ""
"You can call that on an array of circles, or an array of rectangles "
"(assuming those have suitable `Drawable` traits defined), but not on an "
"array containing both circles and rectangles. When such behavior is needed, "
"a trait name can alternately be used as a type, called an _object_."
msgstr ""
"円の配列や長方形の配列に対してこの関数を呼び出すことは (円や長方形に対し適切"
"に `Drawable` トレイトが定義されていると仮定すれば) 可能ですが、円や長方形を"
"両方共含む配列に対しては呼び出すことができません。そのような動作が必要な場"
"合、__オブジェクト__  型として、トレイトの名前を代わりに利用することができま"
"す。"

#. type: Plain text
#: doc/tutorial.md:2089
#, no-wrap
msgid ""
"~~~~\n"
"# trait Drawable { fn draw(&self); }\n"
"fn draw_all(shapes: &[@Drawable]) {\n"
"    for shape in shapes.iter() { shape.draw(); }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:2094
msgid ""
"In this example, there is no type parameter. Instead, the `@Drawable` type "
"denotes any managed box value that implements the `Drawable` trait. To "
"construct such a value, you use the `as` operator to cast a value to an "
"object:"
msgstr ""
"この例中には、型パラメータはありません。代わりに、「`Drawable` トレイトを実装"
"した、任意のマネージドボックス値」を表す型  `@Drawable` 型があります。このよ"
"うな値を作成するには、 `as` 演算子を使って値をオブジェクトへキャストします。"

#. type: Plain text
#: doc/tutorial.md:2101
msgid ""
"~~~~ # type Circle = int; type Rectangle = bool; # trait Drawable { fn "
"draw(&self); } # fn new_circle() -> Circle { 1 } # fn new_rectangle() -> "
"Rectangle { true } # fn draw_all(shapes: &[@Drawable]) {}"
msgstr ""
"~~~~\n"
"# type Circle = int; type Rectangle = bool;\n"
"# trait Drawable { fn draw(&self); }\n"
"# fn new_circle() -> Circle { 1 }\n"
"# fn new_rectangle() -> Rectangle { true }\n"
"# fn draw_all(shapes: &[@Drawable]) {}"

#. type: Plain text
#: doc/tutorial.md:2104
msgid ""
"impl Drawable for Circle { fn draw(&self) { ... } } impl Drawable for "
"Rectangle { fn draw(&self) { ... } }"
msgstr ""
"impl Drawable for Circle { fn draw(&self) { ... } }\n"
"impl Drawable for Rectangle { fn draw(&self) { ... } }"

#. type: Plain text
#: doc/tutorial.md:2109
msgid ""
"let c: @Circle = @new_circle(); let r: @Rectangle = @new_rectangle(); "
"draw_all([c as @Drawable, r as @Drawable]); ~~~~"
msgstr ""
"let c: @Circle = @new_circle();\n"
"let r: @Rectangle = @new_rectangle();\n"
"draw_all([c as @Drawable, r as @Drawable]);\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:2117
msgid ""
"We omit the code for `new_circle` and `new_rectangle`; imagine that these "
"just return `Circle`s and `Rectangle`s with a default size. Note that, like "
"strings and vectors, objects have dynamic size and may only be referred to "
"via one of the pointer types.  Other pointer types work as well.  Casts to "
"traits may only be done with compatible pointers so, for example, an "
"`@Circle` may not be cast to an `~Drawable`."
msgstr ""
"`new_circle` と `new_rectangle` のコードは省略されていますが、デフォルトのサ"
"イズをもつ `Circle` と `Rectangle` をただ返すものだと考えてください。文字列や"
"ベクタのように、オブジェクトも動的なサイズを持ち、いずれかのポインタ型を経由"
"してしか参照できないことに注意してください。他のポインタ型でもうまく動作しま"
"す。トレイトへのキャストは互換性のあるポインタの場合しか行えません。例えば、"
"`@Cicle` を `~Drawable` にキャストすることはできません。"

#. type: Plain text
#: doc/tutorial.md:2131
msgid ""
"~~~ # type Circle = int; type Rectangle = int; # trait Drawable { fn "
"draw(&self); } # impl Drawable for int { fn draw(&self) {} } # fn "
"new_circle() -> int { 1 } # fn new_rectangle() -> int { 2 } // A managed "
"object let boxy: @Drawable = @new_circle() as @Drawable; // An owned object "
"let owny: ~Drawable = ~new_circle() as ~Drawable; // A borrowed object let "
"stacky: &Drawable = &new_circle() as &Drawable; ~~~"
msgstr ""
"~~~\n"
"# type Circle = int; type Rectangle = int;\n"
"# trait Drawable { fn draw(&self); }\n"
"# impl Drawable for int { fn draw(&self) {} }\n"
"# fn new_circle() -> int { 1 }\n"
"# fn new_rectangle() -> int { 2 }\n"
"// A managed object\n"
"let boxy: @Drawable = @new_circle() as @Drawable;\n"
"// An owned object\n"
"let owny: ~Drawable = ~new_circle() as ~Drawable;\n"
"// A borrowed object\n"
"let stacky: &Drawable = &new_circle() as &Drawable;\n"
"~~~"

#. type: Plain text
#: doc/tutorial.md:2136
msgid ""
"Method calls to trait types are _dynamically dispatched_. Since the compiler "
"doesn't know specifically which functions to call at compile time, it uses a "
"lookup table (also known as a vtable or dictionary) to select the method to "
"call at runtime."
msgstr ""
"トレイト型のメソッド呼び出しは __動的にディスパッチ__ (_dynamically "
"dispatched_) されます。どの関数を呼び出すべきかコンパイル時にはわからないた"
"め、ルックアップテーブル (vtable や dictionary としても知られている) を用い"
"て、呼び出すメソッドの選択を実行時に行います。"

#. type: Plain text
#: doc/tutorial.md:2138
msgid "This usage of traits is similar to Java interfaces."
msgstr "トレイトのこのような使い方は、Java のインターフェースと似ています。"

#. type: Plain text
#: doc/tutorial.md:2140
msgid "## Trait inheritance"
msgstr "## トレイトの継承"

#. type: Plain text
#: doc/tutorial.md:2145
msgid ""
"We can write a trait declaration that _inherits_ from other traits, called "
"_supertraits_.  Types that implement a trait must also implement its "
"supertraits.  For example, we can define a `Circle` trait that inherits from "
"`Shape`."
msgstr ""
"__スーパートレイト__ と呼ばれる他のトレイトから __継承した__ トレイトを宣言す"
"ることができます。継承されたトレイトを実装する型は、スーパートレイトも実装し"
"なければなりません。例えば、 `Circle` トレイトを `Shape` トレイトを継承したも"
"のとして定義できます。"

#. type: Plain text
#: doc/tutorial.md:2150
msgid ""
"~~~~ trait Shape { fn area(&self) -> f64; } trait Circle : Shape { fn "
"radius(&self) -> f64; } ~~~~"
msgstr ""
"~~~~\n"
"trait Shape { fn area(&self) -> f64; }\n"
"trait Circle : Shape { fn radius(&self) -> f64; }\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:2152
msgid ""
"Now, we can implement `Circle` on a type only if we also implement `Shape`."
msgstr "`Circle` トレイトの実装は、 `Shape` を実装した型についてのみ行えます。"

#. type: Plain text
#: doc/tutorial.md:2167
#, no-wrap
msgid ""
"~~~~\n"
"use std::f64::consts::pi;\n"
"# trait Shape { fn area(&self) -> f64; }\n"
"# trait Circle : Shape { fn radius(&self) -> f64; }\n"
"# struct Point { x: f64, y: f64 }\n"
"# fn square(x: f64) -> f64 { x * x }\n"
"struct CircleStruct { center: Point, radius: f64 }\n"
"impl Circle for CircleStruct {\n"
"    fn radius(&self) -> f64 { (self.area() / pi).sqrt() }\n"
"}\n"
"impl Shape for CircleStruct {\n"
"    fn area(&self) -> f64 { pi * square(self.radius) }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:2172
msgid ""
"Notice that methods of `Circle` can call methods on `Shape`, as our `radius` "
"implementation calls the `area` method.  This is a silly way to compute the "
"radius of a circle (since we could just return the `radius` field), but you "
"get the idea."
msgstr ""
"`radius` の実装から `area` メソッドを呼び出せるように、`Circle` のメソッドは "
"`Shape` のメソッドを呼び出せることに注意してください。(単純に `radius` フィー"
"ルドの値を返すことができるにも関わらず) 円の半径を面積から計算するのは馬鹿げ"
"ていますが、メソッド呼び出しの考え方は分かったでしょう。"

#. type: Plain text
#: doc/tutorial.md:2196
msgid ""
"~~~ {.xfail-test} use std::f64::consts::pi; # trait Shape { fn area(&self) "
"-> f64; } # trait Circle : Shape { fn radius(&self) -> f64; } # struct "
"Point { x: f64, y: f64 } # struct CircleStruct { center: Point, radius: "
"f64 } # impl Circle for CircleStruct { fn radius(&self) -> f64 { (self."
"area() / pi).sqrt() } } # impl Shape for CircleStruct { fn area(&self) -> "
"f64 { pi * square(self.radius) } }"
msgstr ""
"~~~ {.xfail-test}\n"
"use std::f64::consts::pi;\n"
"# trait Shape { fn area(&self) -> f64; }\n"
"# trait Circle : Shape { fn radius(&self) -> f64; }\n"
"# struct Point { x: f64, y: f64 }\n"
"# struct CircleStruct { center: Point, radius: f64 }\n"
"# impl Circle for CircleStruct { fn radius(&self) -> f64 { (self.area() / "
"pi).sqrt() } }\n"
"# impl Shape for CircleStruct { fn area(&self) -> f64 { pi * square(self."
"radius) } }"

#. type: Plain text
#: doc/tutorial.md:2201
msgid ""
"let concrete = @CircleStruct{center:Point{x:3f,y:4f},radius:5f}; let "
"mycircle: @Circle = concrete as @Circle; let nonsense = mycircle.radius() * "
"mycircle.area(); ~~~"
msgstr ""
"let concrete = @CircleStruct{center:Point{x:3f,y:4f},radius:5f};\n"
"let mycircle: @Circle = concrete as @Circle;\n"
"let nonsense = mycircle.radius() * mycircle.area();\n"
"~~~"

#. type: Plain text
#: doc/tutorial.md:2203
msgid "> ***Note:*** Trait inheritance does not actually work with objects yet"
msgstr ""
"> ***注意*** トレイトの継承は、実際にはまだオブジェクトに対しては動作しませ"
"ん。"

#. type: Plain text
#: doc/tutorial.md:2205
msgid "## Deriving implementations for traits"
msgstr "## トレイトの実装の導出"

#. type: Plain text
#: doc/tutorial.md:2212
msgid ""
"A small number of traits in `std` and `extra` can have implementations that "
"can be automatically derived. These instances are specified by placing the "
"`deriving` attribute on a data type declaration. For example, the following "
"will mean that `Circle` has an implementation for `Eq` and can be used with "
"the equality operators, and that a value of type `ABC` can be randomly "
"generated and converted to a string:"
msgstr ""
"`std` と `extra` で定義されているいくつかのトレイトは、自動的に実装を導出可能"
"です。データ型の宣言時に `deriving` 属性を書くことで、これらのトレイトを実装"
"することを指定します。例えば、以下の例では `Circle` は `Eq` を実装し等価演算"
"子で比較することが可能であり、`ABC` 型の値はランダムに生成することや、文字列"
"に変換することが可能です。"

#. type: Plain text
#: doc/tutorial.md:2216
msgid "~~~ #[deriving(Eq)] struct Circle { radius: f64 }"
msgstr ""
"~~~\n"
"#[deriving(Eq)]\n"
"struct Circle { radius: f64 }"

#. type: Plain text
#: doc/tutorial.md:2220
msgid "#[deriving(Rand, ToStr)] enum ABC { A, B, C } ~~~"
msgstr ""
"#[deriving(Rand, ToStr)]\n"
"enum ABC { A, B, C }\n"
"~~~"

#. type: Plain text
#: doc/tutorial.md:2224
msgid ""
"The full list of derivable traits is `Eq`, `TotalEq`, `Ord`, `TotalOrd`, "
"`Encodable` `Decodable`, `Clone`, `DeepClone`, `IterBytes`, `Rand`, `Zero`, "
"and `ToStr`."
msgstr ""
"実装を自動的に導出可能なトレイトは、 `Eq`, `TotalEq`, `Ord`, `TotalOrd`, "
"`Encodable` `Decodable`, `Clone`, `DeepClone`, `IterBytes`, `Rand`, `Zero`, "
"および `ToStr` です。."

#. type: Plain text
#: doc/tutorial.md:2226
msgid "# Modules and crates"
msgstr "# モジュールとクレート"

#. type: Plain text
#: doc/tutorial.md:2230
msgid ""
"The Rust namespace is arranged in a hierarchy of modules. Each source (.rs) "
"file represents a single module and may in turn contain additional modules."
msgstr ""
"Rust の名前空間はモジュールの階層に配置されている。それぞれのソース (.rs) "
"ファイルは単一のモジュールを表し、追加のモジュールを含んでいる場合もある。"

#. type: Plain text
#: doc/tutorial.md:2236
#, no-wrap
msgid ""
"~~~~\n"
"mod farm {\n"
"    pub fn chicken() -> &str { \"cluck cluck\" }\n"
"    pub fn cow() -> &str { \"mooo\" }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:2241
#, no-wrap
msgid ""
"fn main() {\n"
"    println(farm::chicken());\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:2246
msgid ""
"The contents of modules can be imported into the current scope with the "
"`use` keyword, optionally giving it an alias. `use` may appear at the "
"beginning of crates, `mod`s, `fn`s, and other blocks."
msgstr ""
"でモジュールの内容は`use` キーワードにより現在のスコープにインポートすること"
"ができます。必要に応じて別名を付けることもできます。`use` はクレートの先頭や "
"`mod`, `fn` などのブロックの先頭に記述することができます。"

#. type: Plain text
#: doc/tutorial.md:2252
msgid ""
"~~~ # mod farm { pub fn chicken() { } } # fn main() { // Bring `chicken` "
"into scope use farm::chicken;"
msgstr ""
"~~~\n"
"# mod farm { pub fn chicken() { } }\n"
"# fn main() {\n"
"// `chicken` を現在のスコープに持ち込む\n"
"use farm::chicken;"

#. type: Plain text
#: doc/tutorial.md:2262
#, no-wrap
msgid ""
"fn chicken_farmer() {\n"
"    // The same, but name it `my_chicken`\n"
"    use my_chicken = farm::chicken;\n"
"    ...\n"
"# my_chicken();\n"
"}\n"
"# chicken();\n"
"# }\n"
"~~~\n"
msgstr ""
"fn chicken_farmer() {\n"
"    // 同じことをするが、名前を `my_chicken` とする\n"
"    use my_chicken = farm::chicken;\n"
"    ...\n"
"# my_chicken();\n"
"}\n"
"# chicken();\n"
"# }\n"
"~~~\n"

#. type: Plain text
#: doc/tutorial.md:2269
msgid ""
"These farm animal functions have a new keyword, `pub`, attached to them. The "
"`pub` keyword modifies an item's visibility, making it visible outside its "
"containing module. An expression with `::`, like `farm::chicken`, can name "
"an item outside of its containing module. Items, such as those declared with "
"`fn`, `struct`, `enum`, `type`, or `static`, are module-private by default."
msgstr ""
"farm モジュールの動物の関数定義には、 `pub` という新しいキーワードが付けられ"
"ています。`pub` キーワードは項目の可視性を変更し、項目を含んでいるモジュール"
"の外側から見えるようにします。`farm::chicken` のような、 `::` を含む式は、式"
"を含むモジュールの外側の項目を指定することができます。`fn` や `struct`, "
"`enum`, `type`, `static` により宣言される項目の可視性は、デフォルトではモ"
"ジュールプライベート (同一モジュール内からのみ参照可能)です。"

#. type: Plain text
#: doc/tutorial.md:2276
msgid ""
"Visibility restrictions in Rust exist only at module boundaries. This is "
"quite different from most object-oriented languages that also enforce "
"restrictions on objects themselves. That's not to say that Rust doesn't "
"support encapsulation: both struct fields and methods can be private. But "
"this encapsulation is at the module level, not the struct level. Note that "
"fields and methods are _public_ by default."
msgstr ""
"Rust での可視性の制約はモジュールの境界にのみ存在します。これは、オブジェクト"
"自体にも可視性の制約を課すほとんどのオブジェクト指向言語とは全く異なっていま"
"す。しかし、Rust がカプセル化をサポートしていないというわけではありません。構"
"造体のフィールドとメソッドはプライベートにすることができます。しかし、このカ"
"プセル化はモジュールレベルで働くもので、構造体のレベルで働くものではありませ"
"ん。フィールドとメソッドでは、デフォルトでは __パブリック__ であることに注意"
"してください。"

#. type: Plain text
#: doc/tutorial.md:2289
#, no-wrap
msgid ""
"~~~\n"
"pub mod farm {\n"
"# pub type Chicken = int;\n"
"# type Cow = int;\n"
"# struct Human(int);\n"
"# impl Human { fn rest(&self) { } }\n"
"# pub fn make_me_a_farm() -> Farm { Farm { chickens: ~[], cows: ~[], farmer: Human(0) } }\n"
"    pub struct Farm {\n"
"        priv chickens: ~[Chicken],\n"
"        priv cows: ~[Cow],\n"
"        farmer: Human\n"
"    }\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:2295
#, no-wrap
msgid ""
"    impl Farm {\n"
"        fn feed_chickens(&self) { ... }\n"
"        fn feed_cows(&self) { ... }\n"
"        pub fn add_chicken(&self, c: Chicken) { ... }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:2301
#, no-wrap
msgid ""
"    pub fn feed_animals(farm: &Farm) {\n"
"        farm.feed_chickens();\n"
"        farm.feed_cows();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:2311
#, no-wrap
msgid ""
"fn main() {\n"
"     let f = make_me_a_farm();\n"
"     f.add_chicken(make_me_a_chicken());\n"
"     farm::feed_animals(&f);\n"
"     f.farmer.rest();\n"
"}\n"
"# fn make_me_a_farm() -> farm::Farm { farm::make_me_a_farm() }\n"
"# fn make_me_a_chicken() -> farm::Chicken { 0 }\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:2313
msgid "## Crates"
msgstr "## クレート"

#. type: Plain text
#: doc/tutorial.md:2317
msgid ""
"The unit of independent compilation in Rust is the crate: rustc compiles a "
"single crate at a time, from which it produces either a library or an "
"executable."
msgstr ""
"Rust の独立コンパイルの単位はクレートです。rustc は1度に1つのクレートをコンパ"
"イルし、ライブラリか実行可能ファイルを生成します。"

#. type: Plain text
#: doc/tutorial.md:2322
msgid ""
"When compiling a single `.rs` source file, the file acts as the whole "
"crate.  You can compile it with the `--lib` compiler switch to create a "
"shared library, or without, provided that your file contains a `fn main` "
"somewhere, to create an executable."
msgstr ""
"単一の `.rs` ファイルをコンパイルする場合、1つのファイルがクレート全体として"
"振る舞います。`--lib` コンパイラスイッチを与えてコンパイルすることで、共有ラ"
"イブラリを生成することができます。コンパイラスイッチを与えず、 `fn main` が"
"ファイルのどこかに含まれていれば、実行可能ファイルを生成することができます。"

#. type: Plain text
#: doc/tutorial.md:2327
msgid ""
"Larger crates typically span multiple files and are, by convention, compiled "
"from a source file with the `.rc` extension, called a *crate file*.  The "
"crate file extension distinguishes source files that represent crates from "
"those that do not, but otherwise source files and crate files are identical."
msgstr ""
"大きなクレートは普通複数のファイルから構成され、慣習的に、 `.rc` という拡張子"
"をもつ、 **クレートファイル** と呼ばれるファイルからコンパイルされます。ク"
"レートファイルの拡張子はクレートを表すソースファイルを他のものと区別するため"
"だけのもので、それ以外の店でクレートファイルとソースファイルに違いはありませ"
"ん。"

#. type: Plain text
#: doc/tutorial.md:2336
msgid ""
"A typical crate file declares attributes associated with the crate that may "
"affect how the compiler processes the source.  Crate attributes specify "
"metadata used for locating and linking crates, the type of crate (library or "
"executable), and control warning and error behavior, among other things.  "
"Crate files additionally declare the external crates they depend on as well "
"as any modules loaded from other files."
msgstr ""
"典型的なクレートファイルでは、コンパイラのソースコード処理法に影響を与える、"
"クレートに紐付けられた属性を宣言します。クレートの属性は、クレートの配置やリ"
"ンクに使われたり、クレートの種類 (ライブラリか実行ファイルか) を指定したり、"
"警告やエラーの挙動を制御したりするためのメタデータを指定します。クレートファ"
"イルは、クレートが依存する外部のクレートや、他のファイルから読み込むモジュー"
"ルについても宣言します。"

#. type: Plain text
#: doc/tutorial.md:2340
msgid ""
"~~~~ { .xfail-test } // Crate linkage metadata #[link(name = \"farm\", vers "
"= \"2.5\", author = \"mjh\")];"
msgstr ""
"~~~~ { .xfail-test }\n"
"// クレートのリンケージに関するメタデータ\n"
"#[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")];"

#. type: Plain text
#: doc/tutorial.md:2343
msgid "// Make a library (\"bin\" is the default)  #[crate_type = \"lib\"];"
msgstr ""
"// ライブラリを作成する (\"bin\" がデフォルト値)\n"
"#[crate_type = \"lib\"];"

#. type: Plain text
#: doc/tutorial.md:2346
msgid "// Turn on a warning #[warn(non_camel_case_types)]"
msgstr ""
"// 警告を有効にする\n"
"#[warn(non_camel_case_types)]"

#. type: Plain text
#: doc/tutorial.md:2349
msgid "// Link to the standard library extern mod std;"
msgstr ""
"// 標準ライブラリをリンクする\n"
"extern mod std;"

#. type: Plain text
#: doc/tutorial.md:2354
msgid "// Load some modules from other files mod cow; mod chicken; mod horse;"
msgstr ""
"// 他のファイルからいくつかのモジュールを読み込む\n"
"mod cow;\n"
"mod chicken;\n"
"mod horse;"

#. type: Plain text
#: doc/tutorial.md:2359
#, no-wrap
msgid ""
"fn main() {\n"
"    ...\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:2366
msgid ""
"Compiling this file will cause `rustc` to look for files named `cow.rs`, "
"`chicken.rs`, and `horse.rs` in the same directory as the `.rc` file, "
"compile them all together, and, based on the presence of the `crate_type = "
"\"lib\"` attribute, output a shared library or an executable. (If the line "
"`#[crate_type = \"lib\"];` was omitted, `rustc` would create an executable.)"
msgstr ""
"このファイルをコンパイルすると、 `rustc` は `.rc` ファイルと同じディレクトリ"
"の `cow.rs` と `chicken.rs`、 `horse.rs` を探し、すべてのファイルを同時にコン"
"パイルし、`craete_type = \"lib\"` という属性の有無に応じて、共有ライブラリか"
"実行可能ファイルを出力します。(`#[crate_type = \"lib\"];` の行が取り除かれば"
"場合、 `rustc` は実行可能ファイルを生成します。)"

#. type: Plain text
#: doc/tutorial.md:2370
msgid ""
"The `#[link(...)]` attribute provides meta information about the module, "
"which other crates can use to load the right module. More about that later."
msgstr ""
"`#[link(...)]` 属性は、モジュールに関するメタ情報を提供し、この情報により他の"
"クレートは正しいモジュールをロードすることができます。あとで詳しく述べます。"

#. type: Plain text
#: doc/tutorial.md:2373
msgid ""
"To have a nested directory structure for your source files, you can nest "
"mods:"
msgstr ""
"ソースファイルをネストしたディレクトリに配置する場合、`mod` をネストさせま"
"す。"

#. type: Plain text
#: doc/tutorial.md:2380
#, no-wrap
msgid ""
"~~~~ {.ignore}\n"
"mod poultry {\n"
"    mod chicken;\n"
"    mod turkey;\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:2385
msgid ""
"The compiler will now look for `poultry/chicken.rs` and `poultry/turkey.rs`, "
"and export their content in `poultry::chicken` and `poultry::turkey`. You "
"can also provide a `poultry.rs` to add content to the `poultry` module "
"itself."
msgstr ""
"コンパイラは `poultry/chicken.rs` と `poultry/turkey.rs` を読み込み、ファイル"
"の内容を `poultry::chicken` と `poultry::turkey` としてエクスポートします。"
"`poultry.rs` を作成することで、`poultry` モジュールの内容を追加することも可能"
"です。"

#. type: Plain text
#: doc/tutorial.md:2387
msgid "## Using other crates"
msgstr "## 他のクレートの利用"

#. type: Plain text
#: doc/tutorial.md:2395
msgid ""
"The `extern mod` directive lets you use a crate (once it's been compiled "
"into a library) from inside another crate. `extern mod` can appear at the "
"top of a crate file or at the top of modules. It will cause the compiler to "
"look in the library search path (which you can extend with the `-L` switch) "
"for a compiled Rust library with the right name, then add a module with that "
"crate's name into the local scope."
msgstr ""
"`extern mod` ディレクティブを使うと、あるクレートの中から、(ライブラリにコン"
"パイルされている)　別のクレートを使用することができます。`extern mod` はク"
"レートファイルの先頭かモジュールの先頭に記述することができます。コンパイラ"
"は、対応する名前の Rust ライブラリをライブラリの検索パス (`-L` スイッチにより"
"追加可能) から検索し、クレートと同じ名前のモジュールをローカルスコープに追加"
"します。"

#. type: Plain text
#: doc/tutorial.md:2397
msgid "For example, `extern mod std` links the [standard library]."
msgstr ""
"例えば、 `extern mod std` は [標準ライブラリ][standard library] をリンクしま"
"す。"

#. type: Plain text
#: doc/tutorial.md:2399
msgid "[standard library]: std/index.html"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:2406
msgid ""
"When a comma-separated list of name/value pairs appears after `extern mod`, "
"the compiler front-end matches these pairs against the attributes provided "
"in the `link` attribute of the crate file. The front-end will only select "
"this crate for use if the actual pairs match the declared attributes. You "
"can provide a `name` value to override the name used to search for the crate."
msgstr ""
"`extern mod` の後にカンマで区切られた名前と値のペアが記述された場合、コンパイ"
"ラのフロントエンドはクレートファイルの `link` 属性によって指定された属性と比"
"較します。フロントエンドは宣言された属性とペアが一致するクレートだけを選択"
"し、利用します。`name` の値を設定することで、クレートの検索に使う名前を上書き"
"することができます。"

#. type: Plain text
#: doc/tutorial.md:2408
msgid "Our example crate declared this set of `link` attributes:"
msgstr ""
"先ほどのクレートの例では、 `link` 属性は以下のように宣言されていました。"

#. type: Plain text
#: doc/tutorial.md:2412
msgid "~~~~ #[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")]; ~~~~"
msgstr ""
"~~~~\n"
"#[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")];\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:2414
msgid "Which you can then link with any (or all) of the following:"
msgstr ""
"以下のいずれか (またはすべて) の方法でクレートをリンクすることができます。"

#. type: Plain text
#: doc/tutorial.md:2420
msgid ""
"~~~~ {.xfail-test} extern mod farm; extern mod my_farm (name = \"farm\", "
"vers = \"2.5\"); extern mod my_auxiliary_farm (name = \"farm\", author = "
"\"mjh\"); ~~~~"
msgstr ""
"~~~~ {.xfail-test}\n"
"extern mod farm;\n"
"extern mod my_farm (name = \"farm\", vers = \"2.5\");\n"
"extern mod my_auxiliary_farm (name = \"farm\", author = \"mjh\");\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:2423
msgid ""
"If any of the requested metadata do not match, then the crate will not be "
"compiled successfully."
msgstr ""
"指定されたメタデータに一致するものが存在しない場合、クレートのコンパイルは失"
"敗します。"

#. type: Plain text
#: doc/tutorial.md:2425
msgid "## A minimal example"
msgstr "## 最小限の例"

#. type: Plain text
#: doc/tutorial.md:2428
msgid ""
"Now for something that you can actually compile yourself, we have these two "
"files:"
msgstr ""
"あなた自身で実際にコンパイルが行える例として、以下の2つのファイルを例示しま"
"す。"

#. type: Plain text
#: doc/tutorial.md:2434
msgid ""
"~~~~ // world.rs #[link(name = \"world\", vers = \"1.0\")]; pub fn explore() "
"-> &str { \"world\" } ~~~~"
msgstr ""
"~~~~\n"
"// world.rs\n"
"#[link(name = \"world\", vers = \"1.0\")];\n"
"pub fn explore() -> &str { \"world\" }\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:2440
msgid ""
"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println(~\"hello "
"\" + world::explore()); } ~~~~"
msgstr ""
"~~~~ {.xfail-test}\n"
"// main.rs\n"
"extern mod world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: doc/tutorial.md:2442
msgid "Now compile and run like this (adjust to your platform if necessary):"
msgstr ""
"以下のようにコンパイルし、実行します (必要であれば、お使いのプラットフォーム"
"に合わせて修正してください。)"

#. type: Plain text
#: doc/tutorial.md:2449
#, no-wrap
msgid ""
"~~~~ {.notrust}\n"
"> rustc --lib world.rs  # compiles libworld-94839cbfe144198-1.0.so\n"
"> rustc main.rs -L .    # compiles main\n"
"> ./main\n"
"\"hello world\"\n"
"~~~~\n"
msgstr ""
"~~~~ {.notrust}\n"
"> rustc --lib world.rs  # libworld-94839cbfe144198-1.0.so が生成される\n"
"> rustc main.rs -L .    # main が生成される\n"
"> ./main\n"
"\"hello world\"\n"
"~~~~\n"

#. type: Plain text
#: doc/tutorial.md:2454
msgid ""
"Notice that the library produced contains the version in the filename as "
"well as an inscrutable string of alphanumerics. These are both part of "
"Rust's library versioning scheme. The alphanumerics are a hash representing "
"the crate metadata."
msgstr ""
"生成されたライブラリのファイル名には、バージョン番号だけでなく謎めいた英数字"
"が含まれていることに注意してください。これらは両方共 Rust のバージョン管理ス"
"キームの一員です。英数字は、クレートのメタデータを表すハッシュ値です。"

#. type: Plain text
#: doc/tutorial.md:2456
msgid "## The standard library"
msgstr "## 標準ライブラリ"

#. type: Plain text
#: doc/tutorial.md:2461
msgid ""
"The Rust standard library provides runtime features required by the "
"language, including the task scheduler and memory allocators, as well as "
"library support for Rust built-in types, platform abstractions, and other "
"commonly used features."
msgstr ""
"Rust の標準ライブラリは、タスクスケジューラやメモリアロケータを含む、言語自体"
"が必要とするランタイム機能を提供するだけでなく、Rust の組み込み型や、プラット"
"フォームの抽象化、その他一般的によく利用される機能ををサポートするライブラリ"
"を含んでいます。"

#. type: Plain text
#: doc/tutorial.md:2472
msgid ""
"[`std`] includes modules corresponding to each of the integer types, each of "
"the floating point types, the [`bool`] type, [tuples], [characters], "
"[strings], [vectors], [managed boxes], [owned boxes], and unsafe and "
"borrowed [pointers].  Additionally, `std` provides some pervasive types "
"([`option`] and [`result`]), [task] creation and [communication] primitives, "
"platform abstractions ([`os`] and [`path`]), basic I/O abstractions "
"([`io`]), [containers] like [`hashmap`], common traits ([`kinds`], [`ops`], "
"[`cmp`], [`num`], [`to_str`], [`clone`]), and complete bindings to the C "
"standard library ([`libc`])."
msgstr ""
"[`std`] は整数型や浮動小数点型、[`bool`] 型、[タプル][tuples]、[文字]"
"[characters]、[文字列][strings]、[ベクタ][vectors]、[マネージドボックス]"
"[managed boxes]、[所有ボックス][owned boxes]、unsafe または借用 [ポインタ]"
"[pointers] に対応するモジュールを含んでいます。さらに、 `std` は、いくつかの"
"よく使われる型 ([`option`] と [`result`])や、 [タスク][task] 生成と[通信]"
"[communication] のためのプリミティブ、プラットフォームの抽象化 ([`os`] と "
"[`path`])、基本的な I/O の抽象化 ([`io`]), [`hashmap`] などの [コンテナ]"
"[containers]、共通的に使われるトレイト ([`kinds`], [`ops`], [`cmp`], "
"[`num`], [`to_str`], [`clone`])、C 標準ライブラリ ([`libc`]) への完全なバイン"
"ディングを提供します。"

#. type: Plain text
#: doc/tutorial.md:2474
msgid "### Standard Library injection and the Rust prelude"
msgstr "### 標準ライブラリの注入と Rust の prelude"

#. type: Plain text
#: doc/tutorial.md:2477
msgid ""
"`std` is imported at the topmost level of every crate by default, as if the "
"first line of each crate was"
msgstr ""
"`std` は、すべてのクレートの先頭以下の行か書かれているかのように、デフォルト"
"でクレートの最上位のレベルにインポートされます。"

#. type: Plain text
#: doc/tutorial.md:2479
#, no-wrap
msgid "    extern mod std;\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:2483
msgid ""
"This means that the contents of std can be accessed from from any context "
"with the `std::` path prefix, as in `use std::vec`, `use std::task::spawn`, "
"etc."
msgstr ""
"これは、 std の内容には `std::` というパスプレフィックスを付けることで、任意"
"のコンテキストから `use std::vec`. `use std::task::spawn` のようにアクセスで"
"きることを意味します。"

#. type: Plain text
#: doc/tutorial.md:2488
msgid ""
"Additionally, `std` contains a `prelude` module that reexports many of the "
"most common standard modules, types and traits. The contents of the prelude "
"are imported into every *module* by default.  Implicitly, all modules behave "
"as if they contained the following prologue:"
msgstr ""
"さらに、 `std` は `prelude` という、最も共通的なモジュールや型、トレイトを再"
"エクスポートするモジュールを含んでいます。prelude の内容は、デフォルトですべ"
"ての **モジュール** にインポートされます。すべてのモジュールは、以下の文言を"
"モジュール先頭に暗黙的に含んでいるように動作します。"

#. type: Plain text
#: doc/tutorial.md:2490
#, no-wrap
msgid "    use std::prelude::*;\n"
msgstr ""

#. type: Plain text
#: doc/tutorial.md:2516
msgid ""
"[`std`]: std/index.html [`bool`]: std/bool.html [tuples]: std/tuple.html "
"[characters]: std/char.html [strings]: std/str.html [vectors]: std/vec.html "
"[managed boxes]: std/managed.html [owned boxes]: std/owned.html [pointers]: "
"std/ptr.html [`option`]: std/option.html [`result`]: std/result.html [task]: "
"std/task.html [communication]: std/comm.html [`os`]: std/os.html [`path`]: "
"std/path.html [`io`]: std/io.html [containers]: std/container.html "
"[`hashmap`]: std/hashmap.html [`kinds`]: std/kinds.html [`ops`]: std/ops."
"html [`cmp`]: std/cmp.html [`num`]: std/num.html [`to_str`]: std/to_str.html "
"[`clone`]: std/clone.html [`libc`]: std/libc.html"
msgstr ""
"[`std`]: std/index.html\n"
"[`bool`]: std/bool.html\n"
"[tuples]: std/tuple.html\n"
"[characters]: std/char.html\n"
"[strings]: std/str.html\n"
"[vectors]: std/vec.html\n"
"[managed boxes]: std/managed.html\n"
"[owned boxes]: std/owned.html\n"
"[pointers]: std/ptr.html\n"
"[`option`]: std/option.html\n"
"[`result`]: std/result.html\n"
"[task]: std/task.html\n"
"[communication]: std/comm.html\n"
"[`os`]: std/os.html\n"
"[`path`]: std/path.html\n"
"[`io`]: std/io.html\n"
"[containers]: std/container.html\n"
"[`hashmap`]: std/hashmap.html\n"
"[`kinds`]: std/kinds.html\n"
"[`ops`]: std/ops.html\n"
"[`cmp`]: std/cmp.html\n"
"[`num`]: std/num.html\n"
"[`to_str`]: std/to_str.html\n"
"[`clone`]: std/clone.html\n"
"[`libc`]: std/libc.html"

#. type: Plain text
#: doc/tutorial.md:2518
msgid "# What next?"
msgstr "# 次のステップは？"

#. type: Plain text
#: doc/tutorial.md:2521
msgid ""
"Now that you know the essentials, check out any of the additional tutorials "
"on individual topics."
msgstr ""
"Rust の本質的な部分に関する説明は以上です。個々のトピックにおける追加のチュー"
"トリアルもチェックしてみてください。"

#. type: Bullet: '* '
#: doc/tutorial.md:2527
msgid "[Borrowed pointers][borrow]"
msgstr "[借用ポインタ][borrow]"

#. type: Bullet: '* '
#: doc/tutorial.md:2527
msgid "[Tasks and communication][tasks]"
msgstr "[タスクと通信][tasks]"

#. type: Bullet: '* '
#: doc/tutorial.md:2527
msgid "[Macros][macros]"
msgstr "[マクロ][macros]"

#. type: Bullet: '* '
#: doc/tutorial.md:2527
msgid "[The foreign function interface][ffi]"
msgstr "[他言語間インターフェース (foreign function inferface)][ffi]"

#. type: Bullet: '* '
#: doc/tutorial.md:2527
msgid "[Containers and iterators](tutorial-container.html)"
msgstr "[コンテナとイテレータ](tutorial-container.html)"

#. type: Plain text
#: doc/tutorial.md:2529
msgid "There is further documentation on the [wiki]."
msgstr "[wiki] にもドキュメントがあります。"

#. type: Plain text
#: doc/tutorial.md:2534
msgid ""
"[borrow]: tutorial-borrowed-ptr.html [tasks]: tutorial-tasks.html [macros]: "
"tutorial-macros.html [ffi]: tutorial-ffi.html"
msgstr ""
"[borrow]: tutorial-borrowed-ptr.html\n"
"[tasks]: tutorial-tasks.html\n"
"[macros]: tutorial-macros.html\n"
"[ffi]: tutorial-ffi.html"

#. type: Plain text
#: doc/tutorial.md:2536
msgid "[wiki]: https://github.com/mozilla/rust/wiki/Docs"
msgstr ""
