package graphqlbackend

import (
	"context"
	"fmt"
	"strings"
	"sync"
	"time"
	"unicode"

	"github.com/cockroachdb/errors"
	"github.com/hashicorp/go-multierror"
	"github.com/inconshreveable/log15"

	"github.com/sourcegraph/sourcegraph/cmd/frontend/backend"
	"github.com/sourcegraph/sourcegraph/cmd/frontend/envvar"
	"github.com/sourcegraph/sourcegraph/internal/authz"
	"github.com/sourcegraph/sourcegraph/internal/comby"
	"github.com/sourcegraph/sourcegraph/internal/database"
	"github.com/sourcegraph/sourcegraph/internal/gitserver/gitdomain"
	"github.com/sourcegraph/sourcegraph/internal/search"
	"github.com/sourcegraph/sourcegraph/internal/search/commit"
	"github.com/sourcegraph/sourcegraph/internal/search/query"
	searchrepos "github.com/sourcegraph/sourcegraph/internal/search/repos"
	"github.com/sourcegraph/sourcegraph/internal/search/run"
	"github.com/sourcegraph/sourcegraph/internal/search/searchcontexts"
	"github.com/sourcegraph/sourcegraph/internal/search/streaming"
)

type searchAlert struct {
	prometheusType  string
	title           string
	description     string
	proposedQueries []*searchQueryDescription
	// The higher the priority the more important is the alert.
	priority int
}

func (a searchAlert) PrometheusType() string { return a.prometheusType }

func (a searchAlert) Title() string { return a.title }

func (a searchAlert) Description() *string {
	if a.description == "" {
		return nil
	}
	return &a.description
}

func (a searchAlert) ProposedQueries() *[]*searchQueryDescription {
	if len(a.proposedQueries) == 0 {
		return nil
	}
	return &a.proposedQueries
}

func alertForCappedAndExpression() *searchAlert {
	return &searchAlert{
		prometheusType: "exceed_and_expression_search_limit",
		title:          "Too many files to search for expression",
		description:    "One expression in the query requires a lot of work! This can happen with negated text searches like '-content:', not-expressions, or and-expressions. Try using the '-file:' or '-repo:' filters to narrow your search (like excluding autogenerated files). We're working on improving this experience in https://github.com/sourcegraph/sourcegraph/issues/9824",
	}
}

// alertForQuery converts errors in the query to search alerts.
func alertForQuery(queryString string, err error) *searchAlert {
	if errors.HasType(err, &query.UnsupportedError{}) || errors.HasType(err, &query.ExpectedOperand{}) {
		return &searchAlert{
			prometheusType: "unsupported_and_or_query",
			title:          "Unable To Process Query",
			description:    `I'm having trouble understanding that query. Your query contains "and" or "or" operators that make me think they apply to filters like "repo:" or "file:". We only support "and" or "or" operators on search patterns for file contents currently. You can help me by putting parentheses around the search pattern.`,
		}
	}
	return &searchAlert{
		prometheusType: "generic_invalid_query",
		title:          "Unable To Process Query",
		description:    capFirst(err.Error()),
	}
}

func alertForTimeout(usedTime time.Duration, suggestTime time.Duration, r *searchResolver) *searchAlert {
	q, err := query.ParseLiteral(r.rawQuery()) // Invariant: query is already validated; guard against error anyway.
	if err != nil {
		return &searchAlert{
			prometheusType: "timed_out",
			title:          "Timed out while searching",
			description:    fmt.Sprintf("We weren't able to find any results in %s. Try adding timeout: with a higher value.", usedTime.Round(time.Second)),
		}
	}
	return &searchAlert{
		prometheusType: "timed_out",
		title:          "Timed out while searching",
		description:    fmt.Sprintf("We weren't able to find any results in %s.", usedTime.Round(time.Second)),
		proposedQueries: []*searchQueryDescription{
			{
				search.NewProposedQuery(
					"query with longer timeout",
					fmt.Sprintf("timeout:%v %s", suggestTime, query.OmitField(q, query.FieldTimeout)),
					r.PatternType,
				),
			},
		},
	}
}

// reposExist returns true if one or more repos resolve. If the attempt
// returns 0 repos or fails, it returns false. It is a helper function for
// raising NoResolvedRepos alerts with suggestions when we know the original
// query does not contain any repos to search.
func (o *alertObserver) reposExist(ctx context.Context, options search.RepoOptions) bool {
	options.UserSettings = o.UserSettings
	repositoryResolver := &searchrepos.Resolver{DB: o.Db}
	resolved, err := repositoryResolver.Resolve(ctx, options)
	return err == nil && len(resolved.RepoRevs) > 0
}

func (o *alertObserver) alertForNoResolvedRepos(ctx context.Context, q query.Q) *searchAlert {
	repoFilters, minusRepoFilters := q.Repositories()
	contextFilters, _ := q.StringValues(query.FieldContext)
	onlyForks, noForks, forksNotSet := false, false, true
	if fork := q.Fork(); fork != nil {
		onlyForks = *fork == query.Only
		noForks = *fork == query.No
		forksNotSet = false
	}
	archived := q.Archived()
	archivedNotSet := archived == nil

	if len(repoFilters) == 0 && len(minusRepoFilters) == 0 {
		return &searchAlert{
			prometheusType: "no_resolved_repos__no_repositories",
			title:          "Add repositories or connect repository hosts",
			description:    "There are no repositories to search. Add an external service connection to your code host.",
		}
	}
	if len(contextFilters) == 1 && !searchcontexts.IsGlobalSearchContextSpec(contextFilters[0]) && len(repoFilters) > 0 {
		withoutContextFilter := query.OmitField(q, query.FieldContext)
		proposedQueries := []*searchQueryDescription{
			{
				search.NewProposedQuery(
					"search in the global context",
					fmt.Sprintf("context:%s %s", searchcontexts.GlobalSearchContextName, withoutContextFilter),
					o.PatternType,
				),
			},
		}

		return &searchAlert{
			prometheusType:  "no_resolved_repos__context_none_in_common",
			title:           fmt.Sprintf("No repositories found for your query within the context %s", contextFilters[0]),
			proposedQueries: proposedQueries,
		}
	}

	isSiteAdmin := backend.CheckCurrentUserIsSiteAdmin(ctx, o.Db) == nil
	if !envvar.SourcegraphDotComMode() {
		if needsRepoConfig, err := needsRepositoryConfiguration(ctx, o.Db); err == nil && needsRepoConfig {
			if isSiteAdmin {
				return &searchAlert{
					title:       "No repositories or code hosts configured",
					description: "To start searching code, first go to site admin to configure repositories and code hosts.",
				}
			} else {
				return &searchAlert{
					title:       "No repositories or code hosts configured",
					description: "To start searching code, ask the site admin to configure and enable repositories.",
				}
			}
		}
	}

	proposedQueries := []*searchQueryDescription{}
	if forksNotSet {
		tryIncludeForks := search.RepoOptions{
			RepoFilters:      repoFilters,
			MinusRepoFilters: minusRepoFilters,
			NoForks:          false,
		}
		if o.reposExist(ctx, tryIncludeForks) {
			proposedQueries = append(proposedQueries, &searchQueryDescription{
				search.NewProposedQuery(
					"include forked repositories in your query.",
					o.OriginalQuery+" fork:yes",
					o.PatternType,
				),
			})
		}
	}

	if archivedNotSet {
		tryIncludeArchived := search.RepoOptions{
			RepoFilters:      repoFilters,
			MinusRepoFilters: minusRepoFilters,
			OnlyForks:        onlyForks,
			NoForks:          noForks,
			OnlyArchived:     true,
		}
		if o.reposExist(ctx, tryIncludeArchived) {
			proposedQueries = append(proposedQueries, &searchQueryDescription{
				search.NewProposedQuery(
					"include archived repositories in your query.",
					o.OriginalQuery+" archived:yes",
					o.PatternType,
				),
			})
		}
	}

	if len(proposedQueries) > 0 {
		return &searchAlert{
			prometheusType:  "no_resolved_repos__repos_exist_when_altered",
			title:           "No repositories found",
			description:     "Try alter the query or use a different `repo:<regexp>` filter to see results",
			proposedQueries: proposedQueries,
		}
	}

	return &searchAlert{
		prometheusType: "no_resolved_repos__generic",
		title:          "No repositories found",
		description:    "Try using a different `repo:<regexp>` filter to see results",
	}
}

type errOverRepoLimit struct {
	ProposedQueries []*searchQueryDescription
	Description     string
}

func (e *errOverRepoLimit) Error() string {
	return "Too many matching repositories"
}

func alertForStructuralSearchNotSet(queryString string) *searchAlert {
	return &searchAlert{
		prometheusType: "structural_search_not_set",
		title:          "No results",
		description:    "It looks like you may have meant to run a structural search, but it is not toggled.",
		proposedQueries: []*searchQueryDescription{
			{
				search.NewProposedQuery(
					"Activate structural search",
					queryString,
					query.SearchTypeStructural,
				),
			},
		},
	}
}

func alertForMissingRepoRevs(missingRepoRevs []*search.RepositoryRevisions) *searchAlert {
	var description string
	if len(missingRepoRevs) == 1 {
		if len(missingRepoRevs[0].RevSpecs()) == 1 {
			description = fmt.Sprintf("The repository %s matched by your repo: filter could not be searched because it does not contain the revision %q.", missingRepoRevs[0].Repo.Name, missingRepoRevs[0].RevSpecs()[0])
		} else {
			description = fmt.Sprintf("The repository %s matched by your repo: filter could not be searched because it has multiple specified revisions: @%s.", missingRepoRevs[0].Repo.Name, strings.Join(missingRepoRevs[0].RevSpecs(), ","))
		}
	} else {
		sampleSize := 10
		if sampleSize > len(missingRepoRevs) {
			sampleSize = len(missingRepoRevs)
		}
		repoRevs := make([]string, 0, sampleSize)
		for _, r := range missingRepoRevs[:sampleSize] {
			repoRevs = append(repoRevs, string(r.Repo.Name)+"@"+strings.Join(r.RevSpecs(), ","))
		}
		b := strings.Builder{}
		_, _ = fmt.Fprintf(&b, "%d repositories matched by your repo: filter could not be searched because the following revisions do not exist, or differ but were specified for the same repository:", len(missingRepoRevs))
		for _, rr := range repoRevs {
			_, _ = fmt.Fprintf(&b, "\n* %s", rr)
		}
		if sampleSize < len(missingRepoRevs) {
			b.WriteString("\n* ...")
		}
		description = b.String()
	}
	return &searchAlert{
		prometheusType: "missing_repo_revs",
		title:          "Some repositories could not be searched",
		description:    description,
	}
}

func (a searchAlert) wrapResults() *SearchResults {
	return &SearchResults{Alert: &a}
}

func (a searchAlert) wrapSearchImplementer(db database.DB) *alertSearchImplementer {
	return &alertSearchImplementer{
		db:    db,
		alert: a,
	}
}

// alertSearchImplementer is a light wrapper type around an alert that implements
// SearchImplementer. This helps avoid needing to have a db on the searchAlert type
type alertSearchImplementer struct {
	db    database.DB
	alert searchAlert
}

func (a alertSearchImplementer) Results(context.Context) (*SearchResultsResolver, error) {
	return &SearchResultsResolver{db: a.db, SearchResults: a.alert.wrapResults()}, nil
}

func (alertSearchImplementer) Stats(context.Context) (*searchResultsStats, error) { return nil, nil }
func (alertSearchImplementer) Inputs() run.SearchInputs {
	return run.SearchInputs{}
}

// capFirst capitalizes the first rune in the given string. It can be safely
// used with UTF-8 strings.
func capFirst(s string) string {
	i := 0
	return strings.Map(func(r rune) rune {
		i++
		if i == 1 {
			return unicode.ToTitle(r)
		}
		return r
	}, s)
}

func (o *alertObserver) errorToAlert(ctx context.Context, err error) (*searchAlert, error) {
	if err == nil {
		return nil, nil
	}

	var e *multierror.Error
	if errors.As(err, &e) {
		return o.multierrorToAlert(ctx, e)
	}

	var (
		rErr *commit.RepoLimitError
		tErr *commit.TimeLimitError
		mErr *searchrepos.MissingRepoRevsError
		oErr *errOverRepoLimit
	)

	if errors.HasType(err, authz.ErrStalePermissions{}) {
		return alertForStalePermissions(), nil
	}

	{
		var e gitdomain.BadCommitError
		if errors.As(err, &e) {
			return alertForInvalidRevision(e.Spec), nil
		}
	}

	if err == searchrepos.ErrNoResolvedRepos {
		return o.alertForNoResolvedRepos(ctx, o.Query), nil
	}

	if errors.As(err, &oErr) {
		return &searchAlert{
			prometheusType:  "over_repo_limit",
			title:           "Too many matching repositories",
			proposedQueries: oErr.ProposedQueries,
			description:     oErr.Description,
		}, nil
	}

	if errors.As(err, &mErr) {
		alert := alertForMissingRepoRevs(mErr.Missing)
		alert.priority = 6
		return alert, nil
	}

	if strings.Contains(err.Error(), "Worker_oomed") || strings.Contains(err.Error(), "Worker_exited_abnormally") {
		return &searchAlert{
			prometheusType: "structural_search_needs_more_memory",
			title:          "Structural search needs more memory",
			description:    "Running your structural search may require more memory. If you are running the query on many repositories, try reducing the number of repositories with the `repo:` filter.",
			priority:       5,
		}, nil
	}

	if strings.Contains(err.Error(), "Out of memory") {
		return &searchAlert{
			prometheusType: "structural_search_needs_more_memory__give_searcher_more_memory",
			title:          "Structural search needs more memory",
			description:    `Running your structural search requires more memory. You could try reducing the number of repositories with the "repo:" filter. If you are an administrator, try double the memory allocated for the "searcher" service. If you're unsure, reach out to us at support@sourcegraph.com.`,
			priority:       4,
		}, nil
	}

	if errors.As(err, &rErr) {
		return &searchAlert{
			prometheusType: "exceeded_diff_commit_search_limit",
			title:          fmt.Sprintf("Too many matching repositories for %s search to handle", rErr.ResultType),
			description:    fmt.Sprintf(`%s search can currently only handle searching across %d repositories at a time. Try using the "repo:" filter to narrow down which repositories to search, or using 'after:"1 week ago"'.`, strings.Title(rErr.ResultType), rErr.Max),
			priority:       2,
		}, nil
	}

	if errors.As(err, &tErr) {
		return &searchAlert{
			prometheusType: "exceeded_diff_commit_with_time_search_limit",
			title:          fmt.Sprintf("Too many matching repositories for %s search to handle", tErr.ResultType),
			description:    fmt.Sprintf(`%s search can currently only handle searching across %d repositories at a time. Try using the "repo:" filter to narrow down which repositories to search.`, strings.Title(tErr.ResultType), tErr.Max),
			priority:       1,
		}, nil
	}

	return nil, err
}

func maxAlertByPriority(a, b *searchAlert) *searchAlert {
	if a == nil {
		return b
	}
	if b == nil {
		return a
	}

	if a.priority < b.priority {
		return b
	}

	return a
}

// multierrorToAlert converts a multierror.Error into the highest priority alert
// for the errors contained in it, and a new error with all the errors that could
// not be converted to alerts.
func (o *alertObserver) multierrorToAlert(ctx context.Context, me *multierror.Error) (resAlert *searchAlert, resErr error) {
	for _, err := range me.Errors {
		alert, err := o.errorToAlert(ctx, err)
		resAlert = maxAlertByPriority(resAlert, alert)
		resErr = multierror.Append(resErr, err)
	}

	return resAlert, resErr
}

func alertForStalePermissions() *searchAlert {
	return &searchAlert{
		prometheusType: "no_resolved_repos__stale_permissions",
		title:          "Permissions syncing in progress",
		description:    "Permissions are being synced from your code host, please wait for a minute and try again.",
	}
}

func alertForInvalidRevision(revision string) *searchAlert {
	revision = strings.TrimSuffix(revision, "^0")
	return &searchAlert{
		title:       "Invalid revision syntax",
		description: fmt.Sprintf("We don't know how to interpret the revision (%s) you specified. Learn more about the revision syntax in our documentation: https://docs.sourcegraph.com/code_search/reference/queries#repository-revisions.", revision),
	}
}

type alertObserver struct {
	Db database.DB

	// Inputs are used to generate alert messages based on the query.
	*run.SearchInputs

	// Update state.
	hasResults bool

	// Error state. Can be called concurrently.
	mu    sync.Mutex
	alert *searchAlert
	err   error
}

func (o *alertObserver) Error(ctx context.Context, err error) {
	// Timeouts are reported through Stats so don't report an error for them.
	if err == nil || isContextError(ctx, err) {
		return
	}

	// We can compute the alert outside of the critical section.
	alert, _ := o.errorToAlert(ctx, err)

	o.mu.Lock()
	defer o.mu.Unlock()

	// The error can be converted into an alert.
	if alert != nil {
		o.update(alert)
		return
	}

	// Track the unexpected error for reporting when calling Done.
	o.err = multierror.Append(o.err, err)
}

// update to alert if it is more important than our current alert.
func (o *alertObserver) update(alert *searchAlert) {
	if o.alert == nil || alert.priority > o.alert.priority {
		o.alert = alert
	}
}

//  Done returns the highest priority alert and a multierror.Error containing
//  all errors that could not be converted to alerts.
func (o *alertObserver) Done(stats *streaming.Stats) (*searchAlert, error) {
	if !o.hasResults && o.PatternType != query.SearchTypeStructural && comby.MatchHoleRegexp.MatchString(o.OriginalQuery) {
		o.update(alertForStructuralSearchNotSet(o.OriginalQuery))
	}

	if o.hasResults && o.err != nil {
		log15.Error("Errors during search", "error", o.err)
		return o.alert, nil
	}

	return o.alert, o.err
}
