package api

import (
	"bytes"
	"compress/gzip"
	"encoding/json"
	"io/ioutil"
	"math"
	"unicode"
	"unicode/utf16"
)

// decodeAndTestFilter decodes the filter and determines if identifier is a member of the underlying
// set. Returns an error if the encoded filter is malformed (improperly compressed or invalid JSON).
func decodeAndTestFilter(encodedFilter []byte, identifier string) (bool, error) {
	payload := struct {
		Buckets          []int `json:"buckets"`
		NumHashFunctions int32 `json:"numHashFunctions"`
	}{}

	r, err := gzip.NewReader(bytes.NewReader(encodedFilter))
	if err != nil {
		return false, err
	}

	f, err := ioutil.ReadAll(r)
	if err != nil {
		return false, err
	}

	if err := json.Unmarshal(f, &payload); err != nil {
		return false, err
	}

	//
	// TODO - document bloom filter behaviors
	//

	locations := hashLocations(
		identifier,
		int32(math.Ceil(float64(len(payload.Buckets)))*32),
		payload.NumHashFunctions,
	)

	for _, b := range locations {
		if (payload.Buckets[int(math.Floor(float64(b)/32))] & (1 << (b % 32))) == 0 {
			return false, nil
		}
	}

	return true, nil
}

// The following code is a port of bloomfilter 0.0.18 from npm. We chose not to recreate all the bloom
// filters stored in Postgres because we want a transitionary period where both services (TS and Go) can
// exist and be behaviorally equivalent.
//
// There are not a large number of differences, but there are some subtle ones around overflow behavior
// and UTF-8/16 encoding. The accompanying test suite uses filters generated by the original TypeScript
// code to ensure that they can be read without a migration step. We may want to run a migration step to
// simplify this dependency, but it is in no way urgent.
//
// The original code available at https://github.com/jasondavies/bloomfilter.js.

// Original notes:
// See http://willwhim.wpengine.com/2011/09/03/producing-n-hash-functions-by-hashing-only-once/.
func hashLocations(v string, m, k int32) []int32 {
	a := fowlerNollVo1a(v, 0)
	b := fowlerNollVo1a(v, 1576284489) // The seed value is chosen randomly
	x := a % int32(m)
	r := make([]int32, k)

	for i := int32(0); i < k; i++ {
		if x < 0 {
			r[i] = x + int32(m)
		} else {
			r[i] = x
		}
		x = (x + b) % int32(m)
	}

	return r
}

// Original notes:
// Fowler/Noll/Vo hashing. This function optionally takes a seed value that is incorporated
// into the offset basis. Almost any choice of offset basis will serve so long as it is non-zero,
// according to http://www.isthe.com/chongo/tech/comp/fnv/index.html.
func fowlerNollVo1a(v string, seed int32) int32 {
	q := 2166136261
	a := int64(int32(q) ^ seed)

	for _, r := range utf16Runes(v) {
		c := int64(r)
		if d := c & 0xff00; d != 0 {
			a = (fowlerNollVoMultiply(int32(a ^ int64(d>>8))))
		}
		a = fowlerNollVoMultiply(int32(a) ^ int32(c&0xff))
	}

	return fowlerNollVoMix(int32(a))
}

// Original notes:
// Equivalent to `a * 16777619 mod 2**32`.
func fowlerNollVoMultiply(a int32) int64 {
	return (int64(a) + int64(a<<1) + int64(a<<4) + int64(a<<7) + int64(a<<8) + int64(a<<24))
}

// Original notes:
// See https://web.archive.org/web/20131019013225/http://home.comcast.net/~bretm/hash/6.html.
func fowlerNollVoMix(a int32) int32 {
	a += a << 13
	a ^= int32(uint32(a) >> 7)
	a += a << 3
	a ^= int32(uint32(a) >> 17)
	a += a << 5
	return a
}

// utf16Runes converts the given string into a slice of UTF-16 encoded runes. This works by
// determining if each rune is a UTF-16 surrogate pair. If it is, we replace the rune with
// both runes composing the surrogate pair. Otherwise, we leave the original rune alone.
//
// This is a necessary step as existing filters were created in TypeScript, which treated
// strings as encoded in UTF-16, not UTF-8. We need to do this translation for runes that
// fall outside of the basic multilingual plane, or we wont be able to retrieve the original
// identifiers.
func utf16Runes(v string) []rune {
	var runes []rune
	for _, r := range v {
		// If the pair is not surrogate, U+FFFD is returned for both runes
		if a, b := utf16.EncodeRune(r); a == unicode.ReplacementChar && b == unicode.ReplacementChar {
			runes = append(runes, r)
		} else {
			runes = append(runes, a, b)
		}
	}

	return runes
}
