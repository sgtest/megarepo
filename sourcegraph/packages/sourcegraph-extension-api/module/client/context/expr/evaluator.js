import { TokenType } from './lexer';
import { Parser, TemplateParser } from './parser';
/** A computed context that returns undefined for every key. */
export const EMPTY_COMPUTED_CONTEXT = {
    get: () => undefined,
};
/**
 * Evaluates an expression with the given context and returns the result.
 */
export function evaluate(expr, context) {
    return exec(new Parser().parse(expr), context);
}
/**
 * Evaluates a template with the given context and returns the result.
 *
 * A template is a string that interpolates expressions in ${...}. It uses the same syntax as
 * JavaScript templates.
 */
export function evaluateTemplate(template, context) {
    return exec(new TemplateParser().parse(template), context);
}
const FUNCS = {
    get: (obj, key) => obj[key],
};
function exec(node, context) {
    if ('Literal' in node) {
        switch (node.Literal.type) {
            case TokenType.String:
                return node.Literal.value;
            case TokenType.Number:
                return parseFloat(node.Literal.value);
            default:
                throw new SyntaxError(`Unrecognized literal of type ${TokenType[node.Literal.type]}`);
        }
    }
    if ('Template' in node) {
        const parts = [];
        for (const expr of node.Template.parts) {
            parts.push(exec(expr, context));
        }
        return parts.join('');
    }
    if ('Binary' in node) {
        const left = exec(node.Binary.left, context);
        const right = () => exec(node.Binary.right, context); // lazy evaluation
        switch (node.Binary.operator) {
            case '&&':
                return left && right();
            case '||':
                return left || right();
            case '==':
                // tslint:disable-next-line:triple-equals
                return left == right();
            case '!=':
                // tslint:disable-next-line:triple-equals
                return left != right();
            case '===':
                return left === right();
            case '!==':
                return left !== right();
            case '<':
                return left < right();
            case '>':
                return left > right();
            case '<=':
                return left <= right();
            case '>=':
                return left >= right();
            case '+':
                return left + right();
            case '-':
                return left - right();
            case '*':
                return left * right();
            case '/':
                return left / right();
            case '^':
                return left ^ right();
            case '%':
                return left % right();
            default:
                throw new SyntaxError(`Invalid operator: ${node.Binary.operator}`);
        }
    }
    if ('Unary' in node) {
        const expr = exec(node.Unary.expression, context);
        switch (node.Unary.operator) {
            case '!':
                return !expr;
            case '+':
                return expr;
            case '-':
                return -expr;
            default:
                throw new SyntaxError(`Invalid operator: ${node.Unary.operator}`);
        }
    }
    if ('Identifier' in node) {
        return context.get(node.Identifier);
    }
    if ('FunctionCall' in node) {
        const expr = node.FunctionCall;
        const func = FUNCS[expr.name];
        if (typeof func === 'function') {
            const args = expr.args.map(arg => exec(arg, context));
            return func.apply(null, args);
        }
        throw new SyntaxError(`Undefined function: ${expr.name}`);
    }
    throw new SyntaxError('Unrecognized syntax node');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZhbHVhdG9yLmpzIiwic291cmNlUm9vdCI6InNyYy8iLCJzb3VyY2VzIjpbImNsaWVudC9jb250ZXh0L2V4cHIvZXZhbHVhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxTQUFTLENBQUE7QUFDbkMsT0FBTyxFQUFjLE1BQU0sRUFBRSxjQUFjLEVBQUUsTUFBTSxVQUFVLENBQUE7QUFPN0QsK0RBQStEO0FBQy9ELE1BQU0sQ0FBQyxNQUFNLHNCQUFzQixHQUFvQjtJQUNuRCxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsU0FBUztDQUN2QixDQUFBO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLFVBQVUsUUFBUSxDQUFDLElBQVksRUFBRSxPQUF3QjtJQUMzRCxPQUFPLElBQUksQ0FBQyxJQUFJLE1BQU0sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQTtBQUNsRCxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsZ0JBQWdCLENBQUMsUUFBZ0IsRUFBRSxPQUF3QjtJQUN2RSxPQUFPLElBQUksQ0FBQyxJQUFJLGNBQWMsRUFBRSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQTtBQUM5RCxDQUFDO0FBRUQsTUFBTSxLQUFLLEdBQWdEO0lBQ3ZELEdBQUcsRUFBRSxDQUFDLEdBQVEsRUFBRSxHQUFXLEVBQU8sRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7Q0FDaEQsQ0FBQTtBQUVELFNBQVMsSUFBSSxDQUFDLElBQWdCLEVBQUUsT0FBd0I7SUFDcEQsSUFBSSxTQUFTLElBQUksSUFBSSxFQUFFO1FBQ25CLFFBQVEsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUU7WUFDdkIsS0FBSyxTQUFTLENBQUMsTUFBTTtnQkFDakIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQTtZQUM3QixLQUFLLFNBQVMs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O1lBQ2hCLEtBQUssR0FBRztnQkFDSixPQUFPLElBQUksQ0FBQTtZQUNmLEtBQUssR0FBRztnQkFDSixPQUFPLENBQUMsSUFBSSxDQUFBO1lBQ2hCO2dCQUNJLE1BQU0sSUFBSSxXQUFXLENBQUMscUJBQXFCLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQTtTQUN4RTtLQUNKO0lBRUQsSUFBSSxZQUFZLElBQUksSUFBSSxFQUFFO1FBQ3RCLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUE7S0FDdEM7SUFFRCxJQUFJLGNBQWMsSUFBSSxJQUFJLEVBQUU7UUFDeEIsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQTtRQUM5QixNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBO1FBQzdCLElBQUksT0FBTyxJQUFJLEtBQUssVUFBVSxFQUFFO1lBQzVCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFBO1lBQ3JELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUE7U0FDaEM7UUFDRCxNQUFNLElBQUksV0FBVyxDQUFDLHVCQUF1QixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQTtLQUM1RDtJQUVELE1BQU0sSUFBSSxXQUFXLENBQUMsMEJBQTBCLENBQUMsQ0FBQTtBQUNyRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVG9rZW5UeXBlIH0gZnJvbSAnLi9sZXhlcidcbmltcG9ydCB7IEV4cHJlc3Npb24sIFBhcnNlciwgVGVtcGxhdGVQYXJzZXIgfSBmcm9tICcuL3BhcnNlcidcblxuLyoqIEEgd2F5IHRvIGxvb2sgdXAgdGhlIHZhbHVlIGZvciBhbiBpZGVudGlmaWVyLiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb21wdXRlZENvbnRleHQge1xuICAgIGdldChrZXk6IHN0cmluZyk6IGFueVxufVxuXG4vKiogQSBjb21wdXRlZCBjb250ZXh0IHRoYXQgcmV0dXJucyB1bmRlZmluZWQgZm9yIGV2ZXJ5IGtleS4gKi9cbmV4cG9ydCBjb25zdCBFTVBUWV9DT01QVVRFRF9DT05URVhUOiBDb21wdXRlZENvbnRleHQgPSB7XG4gICAgZ2V0OiAoKSA9PiB1bmRlZmluZWQsXG59XG5cbi8qKlxuICogRXZhbHVhdGVzIGFuIGV4cHJlc3Npb24gd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXZhbHVhdGUoZXhwcjogc3RyaW5nLCBjb250ZXh0OiBDb21wdXRlZENvbnRleHQpOiBhbnkge1xuICAgIHJldHVybiBleGVjKG5ldyBQYXJzZXIoKS5wYXJzZShleHByKSwgY29udGV4dClcbn1cblxuLyoqXG4gKiBFdmFsdWF0ZXMgYSB0ZW1wbGF0ZSB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXG4gKlxuICogQSB0ZW1wbGF0ZSBpcyBhIHN0cmluZyB0aGF0IGludGVycG9sYXRlcyBleHByZXNzaW9ucyBpbiAkey4uLn0uIEl0IHVzZXMgdGhlIHNhbWUgc3ludGF4IGFzXG4gKiBKYXZhU2NyaXB0IHRlbXBsYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV2YWx1YXRlVGVtcGxhdGUodGVtcGxhdGU6IHN0cmluZywgY29udGV4dDogQ29tcHV0ZWRDb250ZXh0KTogYW55IHtcbiAgICByZXR1cm4gZXhlYyhuZXcgVGVtcGxhdGVQYXJzZXIoKS5wYXJzZSh0ZW1wbGF0ZSksIGNvbnRleHQpXG59XG5cbmNvbnN0IEZVTkNTOiB7IFtuYW1lOiBzdHJpbmddOiAoLi4uYXJnczogYW55W10pID0+IGFueSB9ID0ge1xuICAgIGdldDogKG9iajogYW55LCBrZXk6IHN0cmluZyk6IGFueSA9PiBvYmpba2V5XSxcbn1cblxuZnVuY3Rpb24gZXhlYyhub2RlOiBFeHByZXNzaW9uLCBjb250ZXh0OiBDb21wdXRlZENvbnRleHQpOiBhbnkge1xuICAgIGlmICgnTGl0ZXJhbCcgaW4gbm9kZSkge1xuICAgICAgICBzd2l0Y2ggKG5vZGUuTGl0ZXJhbC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5TdHJpbmc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuTGl0ZXJhbC52YWx1ZVxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuTnVtYmVyOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG5vZGUuTGl0ZXJhbC52YWx1ZSlcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbnJlY29nbml6ZWQgbGl0ZXJhbCBvZiB0eXBlICR7VG9rZW5UeXBlW25vZGUuTGl0ZXJhbC50eXBlXX1gKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCdUZW1wbGF0ZScgaW4gbm9kZSkge1xuICAgICAgICBjb25zdCBwYXJ0czogYW55W10gPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IGV4cHIgb2Ygbm9kZS5UZW1wbGF0ZS5wYXJ0cykge1xuICAgICAgICAgICAgcGFydHMucHVzaChleGVjKGV4cHIsIGNvbnRleHQpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKVxuICAgIH1cblxuICAgIGlmICgnQmluYXJ5JyBpbiBub2RlKSB7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBleGVjKG5vZGUuQmluYXJ5LmxlZnQsIGNvbnRleHQpXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gKCkgPT4gZXhlYyhub2RlLkJpbmFyeS5yaWdodCwgY29udGV4dCkgLy8gbGF6eSBldmFsdWF0aW9uXG4gICAgICAgIHN3aXRjaCAobm9kZS5CaW5hcnkub3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAmJiByaWdodCgpXG4gICAgICAgICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgfHwgcmlnaHQoKVxuICAgICAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0cmlwbGUtZXF1YWxzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPT0gcmlnaHQoKVxuICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0cmlwbGUtZXF1YWxzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgIT0gcmlnaHQoKVxuICAgICAgICAgICAgY2FzZSAnPT09JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQoKVxuICAgICAgICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAhPT0gcmlnaHQoKVxuICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPCByaWdodCgpXG4gICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA+IHJpZ2h0KClcbiAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA8PSByaWdodCgpXG4gICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPj0gcmlnaHQoKVxuICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgKyByaWdodCgpXG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAtIHJpZ2h0KClcbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ICogcmlnaHQoKVxuICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgLyByaWdodCgpXG4gICAgICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCBeIHJpZ2h0KClcbiAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ICUgcmlnaHQoKVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgb3BlcmF0b3I6ICR7bm9kZS5CaW5hcnkub3BlcmF0b3J9YClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICgnVW5hcnknIGluIG5vZGUpIHtcbiAgICAgICAgY29uc3QgZXhwciA9IGV4ZWMobm9kZS5VbmFyeS5leHByZXNzaW9uLCBjb250ZXh0KVxuICAgICAgICBzd2l0Y2ggKG5vZGUuVW5hcnkub3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgIHJldHVybiAhZXhwclxuICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIHJldHVybiAtZXhwclxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgb3BlcmF0b3I6ICR7bm9kZS5VbmFyeS5vcGVyYXRvcn1gKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCdJZGVudGlmaWVyJyBpbiBub2RlKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmdldChub2RlLklkZW50aWZpZXIpXG4gICAgfVxuXG4gICAgaWYgKCdGdW5jdGlvbkNhbGwnIGluIG5vZGUpIHtcbiAgICAgICAgY29uc3QgZXhwciA9IG5vZGUuRnVuY3Rpb25DYWxsXG4gICAgICAgIGNvbnN0IGZ1bmMgPSBGVU5DU1tleHByLm5hbWVdXG4gICAgICAgIGlmICh0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IGV4cHIuYXJncy5tYXAoYXJnID0+IGV4ZWMoYXJnLCBjb250ZXh0KSlcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmRlZmluZWQgZnVuY3Rpb246ICR7ZXhwci5uYW1lfWApXG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbnJlY29nbml6ZWQgc3ludGF4IG5vZGUnKVxufVxuIl19