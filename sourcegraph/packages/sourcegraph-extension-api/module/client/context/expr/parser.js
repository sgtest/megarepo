import { Lexer, TemplateLexer, TokenType } from './lexer';
/**
 * Parses an expression.
 *
 * TODO: Operator precedence is not handled correctly. Use parentheses to be explicit about your desired
 * precedence.
 */
export class Parser {
    parse(exprStr) {
        if (!this.lexer) {
            this.lexer = new Lexer();
        }
        this.lexer.reset(exprStr);
        const expr = this.parseExpression();
        const token = this.lexer.next();
        if (token !== undefined) {
            throw new SyntaxError(`Unexpected token at end of input: ${JSON.stringify(token.value)} (at ${this.lexer.index})`);
        }
        return expr;
    }
    // ArgumentList := Expression |
    //                 Expression ',' ArgumentList
    parseArgumentList() {
        const args = [];
        while (true) {
            const expr = this.parseExpression();
            if (expr === undefined) {
                throw new Error(`Parse error on token in arguments list: ${JSON.stringify(this.lexer.peek())} (at ${this.lexer.index})`);
            }
            args.push(expr);
            const token = this.lexer.peek();
            if (!matchOp(token, ',')) {
                break;
            }
            this.lexer.next();
        }
        return args;
    }
    // FunctionCall ::= Identifier '(' ')' ||
    //                  Identifier '(' ArgumentList ')'
    parseFunctionCall(name) {
        let token = this.lexer.next();
        if (!matchOp(token, '(')) {
            throw new SyntaxError(`Expected "(" in function call ${JSON.stringify(name)} (at ${this.lexer.index})`);
        }
        token = this.lexer.peek();
        const args = matchOp(token, ')') ? [] : this.parseArgumentList();
        token = this.lexer.next();
        if (!matchOp(token, ')')) {
            throw new SyntaxError(`Expected ")" in function call ${JSON.stringify(name)} (at ${this.lexer.index})`);
        }
        return {
            FunctionCall: {
                name,
                args,
            },
        };
    }
    parseTemplateParts() {
        const parts = [];
        while (true) {
            const token = this.lexer.peek();
            if (!token) {
                break;
            }
            if (token.type === TokenType.TemplateTail) {
                if (token.value) {
                    parts.push({ Literal: { type: TokenType.String, value: token.value } });
                }
                this.lexer.next();
                break;
            }
            if (matchOp(token, '}')) {
                this.lexer.next();
            }
            else if (token.type === TokenType.TemplateMiddle) {
                if (token.value) {
                    parts.push({ Literal: { type: TokenType.String, value: token.value } });
                }
                this.lexer.next();
            }
            else {
                parts.push(this.parseExpression());
            }
        }
        return parts;
    }
    parseTemplate() {
        const token = this.lexer.peek();
        if (token === undefined) {
            throw new SyntaxError(`Unexpected termination of expression at beginning of template (at ${this.lexer.index})`);
        }
        if (token.type === TokenType.NoSubstitutionTemplate) {
            this.lexer.next();
            // The caller doesn't need to distinguish between NoSubstitutionTemplate and String
            // tokens, so collapse both token types into String.
            return { Literal: { type: TokenType.String, value: token.value } };
        }
        if (token.type === TokenType.TemplateHead || token.type === TokenType.TemplateMiddle) {
            this.lexer.next();
            const parts = this.parseTemplateParts();
            if (token.value) {
                parts.unshift({ Literal: { type: TokenType.String, value: token.value } });
            }
            return {
                Template: { parts },
            };
        }
        throw new SyntaxError(`Unexpected token at beginning of template: ${JSON.stringify(token.value)} (at ${this.lexer.index})`);
    }
    // Primary ::= Identifier |
    //             String |
    //             Template |
    //             Number |
    //             FunctionCall
    parsePrimary() {
        const token = this.lexer.peek();
        if (token === undefined) {
            throw new SyntaxError(`Unexpected termination of expression (at ${this.lexer.index})`);
        }
        if (token.type === TokenType.Identifier) {
            this.lexer.next();
            if (matchOp(this.lexer.peek(), '(')) {
                return this.parseFunctionCall(token.value);
            }
            return {
                Identifier: token.value,
            };
        }
        if (token.type === TokenType.String || token.type === TokenType.Number) {
            this.lexer.next();
            return { Literal: { type: token.type, value: token.value } };
        }
        if (token.type === TokenType.NoSubstitutionTemplate ||
            token.type === TokenType.TemplateHead ||
            token.type === TokenType.TemplateMiddle) {
            return this.parseTemplate();
        }
        if (matchOp(token, '(')) {
            this.lexer.next();
            const expr = this.parseAdditive();
            const token = this.lexer.next();
            if (!matchOp(token, ')')) {
                throw new SyntaxError(`Expected ")" (at ${this.lexer.index})`);
            }
            return expr;
        }
        throw new SyntaxError(`Parse error on token: ${JSON.stringify(token.value)} (at ${this.lexer.index})`);
    }
    // Unary ::= Primary |
    //           UnaryOp Unary
    parseUnary() {
        const token = this.lexer.peek();
        if (token !== undefined && (matchOp(token, '-') || matchOp(token, '+') || matchOp(token, '!'))) {
            this.lexer.next();
            const expr = this.parseUnary();
            return {
                Unary: {
                    operator: token.value,
                    expression: expr,
                },
            };
        }
        return this.parsePrimary();
    }
    // Multiplicative ::= Unary |
    //                    Multiplicative BinaryOp Unary
    parseMultiplicative() {
        let expr = this.parseUnary();
        let token = this.lexer.peek();
        while (token !== undefined && (matchOp(token, '*') || matchOp(token, '/') || matchOp(token, '%'))) {
            this.lexer.next();
            expr = {
                Binary: {
                    operator: token.value,
                    left: expr,
                    right: this.parseUnary(),
                },
            };
            token = this.lexer.peek();
        }
        return expr;
    }
    // Additive ::= Multiplicative |
    //              Additive BinaryOp Multiplicative
    parseAdditive() {
        let expr = this.parseMultiplicative();
        let token = this.lexer.peek();
        while (token !== undefined &&
            (matchOp(token, '+') ||
                matchOp(token, '-') ||
                matchOp(token, '==') ||
                matchOp(token, '!=') ||
                matchOp(token, '===') ||
                matchOp(token, '!==') ||
                matchOp(token, '<') ||
                matchOp(token, '>') ||
                matchOp(token, '<=') ||
                matchOp(token, '>=') ||
                matchOp(token, '&&') ||
                matchOp(token, '||'))) {
            this.lexer.next();
            expr = {
                Binary: {
                    operator: token.value,
                    left: expr,
                    right: this.parseMultiplicative(),
                },
            };
            token = this.lexer.peek();
        }
        return expr;
    }
    // Expression ::= Additive
    parseExpression() {
        return this.parseAdditive();
    }
}
/** Parses a template. */
export class TemplateParser extends Parser {
    parse(templateStr) {
        if (!this.lexer) {
            this.lexer = new TemplateLexer();
        }
        this.lexer.reset(templateStr);
        const expr = this.parseTemplate();
        const token = this.lexer.next();
        if (token !== undefined) {
            throw new SyntaxError(`Unexpected token at end of template input: ${JSON.stringify(token.value)} (at ${this.lexer.index})`);
        }
        return expr;
    }
}
function matchOp(token, op) {
    return token !== undefined && token.type === TokenType.Operator && token.value === op;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2VyLmpzIiwic291cmNlUm9vdCI6InNyYy8iLCJzb3VyY2VzIjpbImNsaWVudC9jb250ZXh0L2V4cHIvcGFyc2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxLQUFLLEVBQVksYUFBYSxFQUFTLFNBQVMsRUFBRSxNQUFNLFNBQVMsQ0FBQTtBQVUxRTs7Ozs7R0FLRztBQUNILE1BQU0sT0FBTyxNQUFNO0lBR1IsS0FBSyxDQUFDLE9BQWU7UUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDYixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUE7U0FDM0I7UUFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQTtRQUN6QixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUE7UUFFbkMsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQTtRQUMvQixJQUFJLEtBQUssS0FBSyxTQUFTLEVBQUU7WUFDckIsTUFBTSxJQUFJLFdBQVcsQ0FDakIscUNBQXFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxRQUFRLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLENBQzlGLENBQUE7U0FDSjtRQUVELE9BQU8sSUFBSSxDQUFBO0lBQ2YsQ0FBQztJQUVELCtCQUErQjtJQUMvQiw4Q0FBOEM7SUFDdEMsaUJBQWlCO1FBQ3JCLE1BQU0sSUFBSSxHQUFpQixFQUFFLENBQUE7UUFDN0IsT0FBTyxJQUFJLEVBQUU7WUFDVCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUE7WUFDbkMsSUFBSSxJQUFJLEtBQUssU0FBUyxFQUFFO2dCQUNwQixNQUFNLElBQUksS0FBSyxDQUNYLDJDQUEyQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMs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QW1CO1FBQzVCLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ2IsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLGFBQWEsRUFBRSxDQUFBO1NBQ25DO1FBRUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUE7UUFDN0IsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFBO1FBRWpDLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUE7UUFDL0IsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQ3JCLE1BQU0sSUFBSSxXQUFXLENBQ2pCLDhDQUE4QyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsUUFBUSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUN2RyxDQUFBO1NBQ0o7UUFFRCxPQUFPLElBQUksQ0FBQTtJQUNmLENBQUM7Q0FDSjtBQUVELFNBQVMsT0FBTyxDQUFDLEtBQWdELEVBQUUsRUFBWTtJQUMzRSxPQUFPLEtBQUssS0FBSyxTQUFTLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxTQUFTLENBQUMsUUFBUSxJQUFJLEtBQUssQ0FBQyxLQUFLLEtBQUssRUFBRSxDQUFBO0FBQ3pGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMZXhlciwgT3BlcmF0b3IsIFRlbXBsYXRlTGV4ZXIsIFRva2VuLCBUb2tlblR5cGUgfSBmcm9tICcuL2xleGVyJ1xuXG5leHBvcnQgdHlwZSBFeHByZXNzaW9uID1cbiAgICB8IHsgRnVuY3Rpb25DYWxsOiB7IG5hbWU6IHN0cmluZzsgYXJnczogRXhwcmVzc2lvbltdIH0gfVxuICAgIHwgeyBJZGVudGlmaWVyOiBzdHJpbmcgfVxuICAgIHwgeyBMaXRlcmFsOiB7IHR5cGU6IFRva2VuVHlwZS5TdHJpbmcgfCBUb2tlblR5cGUuTnVtYmVyOyB2YWx1ZTogc3RyaW5nIH0gfVxuICAgIHwgeyBUZW1wbGF0ZTogeyBwYXJ0czogRXhwcmVzc2lvbltdIH0gfVxuICAgIHwgeyBVbmFyeTogeyBvcGVyYXRvcjogT3BlcmF0b3I7IGV4cHJlc3Npb246IEV4cHJlc3Npb24gfSB9XG4gICAgfCB7IEJpbmFyeTogeyBvcGVyYXRvcjogT3BlcmF0b3I7IGxlZnQ6IEV4cHJlc3Npb247IHJpZ2h0OiBFeHByZXNzaW9uIH0gfVxuXG4vKipcbiAqIFBhcnNlcyBhbiBleHByZXNzaW9uLlxuICpcbiAqIFRPRE86IE9wZXJhdG9yIHByZWNlZGVuY2UgaXMgbm90IGhhbmRsZWQgY29ycmVjdGx5LiBVc2UgcGFyZW50aGVzZXMgdG8gYmUgZXhwbGljaXQgYWJvdXQgeW91ciBkZXNpcmVkXG4gKiBwcmVjZWRlbmNlLlxuICovXG5leHBvcnQgY2xhc3MgUGFyc2VyIHtcbiAgICBwcm90ZWN0ZWQgbGV4ZXIhOiBMZXhlclxuXG4gICAgcHVibGljIHBhcnNlKGV4cHJTdHI6IHN0cmluZyk6IEV4cHJlc3Npb24ge1xuICAgICAgICBpZiAoIXRoaXMubGV4ZXIpIHtcbiAgICAgICAgICAgIHRoaXMubGV4ZXIgPSBuZXcgTGV4ZXIoKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGV4ZXIucmVzZXQoZXhwclN0cilcbiAgICAgICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKClcblxuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMubGV4ZXIubmV4dCgpXG4gICAgICAgIGlmICh0b2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgICAgICAgYFVuZXhwZWN0ZWQgdG9rZW4gYXQgZW5kIG9mIGlucHV0OiAke0pTT04uc3RyaW5naWZ5KHRva2VuLnZhbHVlKX0gKGF0ICR7dGhpcy5sZXhlci5pbmRleH0pYFxuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHJcbiAgICB9XG5cbiAgICAvLyBBcmd1bWVudExpc3QgOj0gRXhwcmVzc2lvbiB8XG4gICAgLy8gICAgICAgICAgICAgICAgIEV4cHJlc3Npb24gJywnIEFyZ3VtZW50TGlzdFxuICAgIHByaXZhdGUgcGFyc2VBcmd1bWVudExpc3QoKTogRXhwcmVzc2lvbltdIHtcbiAgICAgICAgY29uc3QgYXJnczogRXhwcmVzc2lvbltdID0gW11cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpXG4gICAgICAgICAgICBpZiAoZXhwciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgUGFyc2UgZXJyb3Igb24gdG9rZW4gaW4gYXJndW1lbnRzIGxpc3Q6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5sZXhlci5wZWVrKCkpfSAoYXQgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfSlgXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncy5wdXNoKGV4cHIpXG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMubGV4ZXIucGVlaygpXG4gICAgICAgICAgICBpZiAoIW1hdGNoT3AodG9rZW4sICcsJykpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sZXhlci5uZXh0KClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnc1xuICAgIH1cblxuICAgIC8vIEZ1bmN0aW9uQ2FsbCA6Oj0gSWRlbnRpZmllciAnKCcgJyknIHx8XG4gICAgLy8gICAgICAgICAgICAgICAgICBJZGVudGlmaWVyICcoJyBBcmd1bWVudExpc3QgJyknXG4gICAgcHJpdmF0ZSBwYXJzZUZ1bmN0aW9uQ2FsbChuYW1lOiBzdHJpbmcpOiBFeHByZXNzaW9uIHtcbiAgICAgICAgbGV0IHRva2VuOiBQaWNrPFRva2VuLCAndHlwZScgfCAndmFsdWUnPiB8IHVuZGVmaW5lZCA9IHRoaXMubGV4ZXIubmV4dCgpXG4gICAgICAgIGlmICghbWF0Y2hPcCh0b2tlbiwgJygnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBFeHBlY3RlZCBcIihcIiBpbiBmdW5jdGlvbiBjYWxsICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9IChhdCAke3RoaXMubGV4ZXIuaW5kZXh9KWApXG4gICAgICAgIH1cblxuICAgICAgICB0b2tlbiA9IHRoaXMubGV4ZXIucGVlaygpXG4gICAgICAgIGNvbnN0IGFyZ3M6IEV4cHJlc3Npb25bXSA9IG1hdGNoT3AodG9rZW4sICcpJykgPyBbXSA6IHRoaXMucGFyc2VBcmd1bWVudExpc3QoKVxuXG4gICAgICAgIHRva2VuID0gdGhpcy5sZXhlci5uZXh0KClcbiAgICAgICAgaWYgKCFtYXRjaE9wKHRva2VuLCAnKScpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEV4cGVjdGVkIFwiKVwiIGluIGZ1bmN0aW9uIGNhbGwgJHtKU09OLnN0cmluZ2lmeShuYW1lKX0gKGF0ICR7dGhpcy5sZXhlci5pbmRleH0pYClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBGdW5jdGlvbkNhbGw6IHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYXJzZVRlbXBsYXRlUGFydHMoKTogRXhwcmVzc2lvbltdIHtcbiAgICAgICAgY29uc3QgcGFydHM6IEV4cHJlc3Npb25bXSA9IFtdXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbjogUGljazxUb2tlbiwgJ3R5cGUnIHwgJ3ZhbHVlJz4gfCB1bmRlZmluZWQgPSB0aGlzLmxleGVyLnBlZWsoKVxuICAgICAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLlRlbXBsYXRlVGFpbCkge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgTGl0ZXJhbDogeyB0eXBlOiBUb2tlblR5cGUuU3RyaW5nLCB2YWx1ZTogdG9rZW4udmFsdWUgfSB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLm5leHQoKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hPcCh0b2tlbiwgJ30nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIubmV4dCgpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5UZW1wbGF0ZU1pZGRsZSkge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgTGl0ZXJhbDogeyB0eXBlOiBUb2tlblR5cGUuU3RyaW5nLCB2YWx1ZTogdG9rZW4udmFsdWUgfSB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLm5leHQoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMucGFyc2VFeHByZXNzaW9uKCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRzXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlVGVtcGxhdGUoKTogRXhwcmVzc2lvbiB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5sZXhlci5wZWVrKClcbiAgICAgICAgaWYgKHRva2VuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICAgICAgICBgVW5leHBlY3RlZCB0ZXJtaW5hdGlvbiBvZiBleHByZXNzaW9uIGF0IGJlZ2lubmluZyBvZiB0ZW1wbGF0ZSAoYXQgJHt0aGlzLmxleGVyLmluZGV4fSlgXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLk5vU3Vic3RpdHV0aW9uVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMubGV4ZXIubmV4dCgpXG4gICAgICAgICAgICAvLyBUaGUgY2FsbGVyIGRvZXNuJ3QgbmVlZCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIE5vU3Vic3RpdHV0aW9uVGVtcGxhdGUgYW5kIFN0cmluZ1xuICAgICAgICAgICAgLy8gdG9rZW5zLCBzbyBjb2xsYXBzZSBib3RoIHRva2VuIHR5cGVzIGludG8gU3RyaW5nLlxuICAgICAgICAgICAgcmV0dXJuIHsgTGl0ZXJhbDogeyB0eXBlOiBUb2tlblR5cGUuU3RyaW5nLCB2YWx1ZTogdG9rZW4udmFsdWUgfSB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLlRlbXBsYXRlSGVhZCB8fCB0b2tlbi50eXBlID09PSBUb2tlblR5cGUuVGVtcGxhdGVNaWRkbGUpIHtcbiAgICAgICAgICAgIHRoaXMubGV4ZXIubmV4dCgpXG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMucGFyc2VUZW1wbGF0ZVBhcnRzKClcbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnVuc2hpZnQoeyBMaXRlcmFsOiB7IHR5cGU6IFRva2VuVHlwZS5TdHJpbmcsIHZhbHVlOiB0b2tlbi52YWx1ZSB9IH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIFRlbXBsYXRlOiB7IHBhcnRzIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgICBgVW5leHBlY3RlZCB0b2tlbiBhdCBiZWdpbm5pbmcgb2YgdGVtcGxhdGU6ICR7SlNPTi5zdHJpbmdpZnkodG9rZW4udmFsdWUpfSAoYXQgJHt0aGlzLmxleGVyLmluZGV4fSlgXG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvLyBQcmltYXJ5IDo6PSBJZGVudGlmaWVyIHxcbiAgICAvLyAgICAgICAgICAgICBTdHJpbmcgfFxuICAgIC8vICAgICAgICAgICAgIFRlbXBsYXRlIHxcbiAgICAvLyAgICAgICAgICAgICBOdW1iZXIgfFxuICAgIC8vICAgICAgICAgICAgIEZ1bmN0aW9uQ2FsbFxuICAgIHByaXZhdGUgcGFyc2VQcmltYXJ5KCk6IEV4cHJlc3Npb24ge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMubGV4ZXIucGVlaygpXG4gICAgICAgIGlmICh0b2tlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgdGVybWluYXRpb24gb2YgZXhwcmVzc2lvbiAoYXQgJHt0aGlzLmxleGVyLmluZGV4fSlgKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICB0aGlzLmxleGVyLm5leHQoKVxuICAgICAgICAgICAgaWYgKG1hdGNoT3AodGhpcy5sZXhlci5wZWVrKCksICcoJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uQ2FsbCh0b2tlbi52YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgSWRlbnRpZmllcjogdG9rZW4udmFsdWUsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLlN0cmluZyB8fCB0b2tlbi50eXBlID09PSBUb2tlblR5cGUuTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLmxleGVyLm5leHQoKVxuICAgICAgICAgICAgcmV0dXJuIHsgTGl0ZXJhbDogeyB0eXBlOiB0b2tlbi50eXBlLCB2YWx1ZTogdG9rZW4udmFsdWUgfSB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlblR5cGUuTm9TdWJzdGl0dXRpb25UZW1wbGF0ZSB8fFxuICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLlRlbXBsYXRlSGVhZCB8fFxuICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLlRlbXBsYXRlTWlkZGxlXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUZW1wbGF0ZSgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hPcCh0b2tlbiwgJygnKSkge1xuICAgICAgICAgICAgdGhpcy5sZXhlci5uZXh0KClcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlQWRkaXRpdmUoKVxuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmxleGVyLm5leHQoKVxuICAgICAgICAgICAgaWYgKCFtYXRjaE9wKHRva2VuLCAnKScpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBFeHBlY3RlZCBcIilcIiAoYXQgJHt0aGlzLmxleGVyLmluZGV4fSlgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4cHJcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgUGFyc2UgZXJyb3Igb24gdG9rZW46ICR7SlNPTi5zdHJpbmdpZnkodG9rZW4udmFsdWUpfSAoYXQgJHt0aGlzLmxleGVyLmluZGV4fSlgKVxuICAgIH1cblxuICAgIC8vIFVuYXJ5IDo6PSBQcmltYXJ5IHxcbiAgICAvLyAgICAgICAgICAgVW5hcnlPcCBVbmFyeVxuICAgIHByaXZhdGUgcGFyc2VVbmFyeSgpOiBFeHByZXNzaW9uIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmxleGVyLnBlZWsoKVxuICAgICAgICBpZiAodG9rZW4gIT09IHVuZGVmaW5lZCAmJiAobWF0Y2hPcCh0b2tlbiwgJy0nKSB8fCBtYXRjaE9wKHRva2VuLCAnKycpIHx8IG1hdGNoT3AodG9rZW4sICchJykpKSB7XG4gICAgICAgICAgICB0aGlzLmxleGVyLm5leHQoKVxuICAgICAgICAgICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VVbmFyeSgpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIFVuYXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiB0b2tlbi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUHJpbWFyeSgpXG4gICAgfVxuXG4gICAgLy8gTXVsdGlwbGljYXRpdmUgOjo9IFVuYXJ5IHxcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgTXVsdGlwbGljYXRpdmUgQmluYXJ5T3AgVW5hcnlcbiAgICBwcml2YXRlIHBhcnNlTXVsdGlwbGljYXRpdmUoKTogRXhwcmVzc2lvbiB7XG4gICAgICAgIGxldCBleHByID0gdGhpcy5wYXJzZVVuYXJ5KClcbiAgICAgICAgbGV0IHRva2VuID0gdGhpcy5sZXhlci5wZWVrKClcbiAgICAgICAgd2hpbGUgKHRva2VuICE9PSB1bmRlZmluZWQgJiYgKG1hdGNoT3AodG9rZW4sICcqJykgfHwgbWF0Y2hPcCh0b2tlbiwgJy8nKSB8fCBtYXRjaE9wKHRva2VuLCAnJScpKSkge1xuICAgICAgICAgICAgdGhpcy5sZXhlci5uZXh0KClcbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgQmluYXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiB0b2tlbi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZXhwcixcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHRoaXMucGFyc2VVbmFyeSgpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMubGV4ZXIucGVlaygpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHJcbiAgICB9XG5cbiAgICAvLyBBZGRpdGl2ZSA6Oj0gTXVsdGlwbGljYXRpdmUgfFxuICAgIC8vICAgICAgICAgICAgICBBZGRpdGl2ZSBCaW5hcnlPcCBNdWx0aXBsaWNhdGl2ZVxuICAgIHByaXZhdGUgcGFyc2VBZGRpdGl2ZSgpOiBFeHByZXNzaW9uIHtcbiAgICAgICAgbGV0IGV4cHIgPSB0aGlzLnBhcnNlTXVsdGlwbGljYXRpdmUoKVxuICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLmxleGVyLnBlZWsoKVxuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICB0b2tlbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAobWF0Y2hPcCh0b2tlbiwgJysnKSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoT3AodG9rZW4sICctJykgfHxcbiAgICAgICAgICAgICAgICBtYXRjaE9wKHRva2VuLCAnPT0nKSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoT3AodG9rZW4sICchPScpIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2hPcCh0b2tlbiwgJz09PScpIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2hPcCh0b2tlbiwgJyE9PScpIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2hPcCh0b2tlbiwgJzwnKSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoT3AodG9rZW4sICc+JykgfHxcbiAgICAgICAgICAgICAgICBtYXRjaE9wKHRva2VuLCAnPD0nKSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoT3AodG9rZW4sICc+PScpIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2hPcCh0b2tlbiwgJyYmJykgfHxcbiAgICAgICAgICAgICAgICBtYXRjaE9wKHRva2VuLCAnfHwnKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmxleGVyLm5leHQoKVxuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICBCaW5hcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHRva2VuLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBleHByLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogdGhpcy5wYXJzZU11bHRpcGxpY2F0aXZlKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5sZXhlci5wZWVrKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwclxuICAgIH1cblxuICAgIC8vIEV4cHJlc3Npb24gOjo9IEFkZGl0aXZlXG4gICAgcHJpdmF0ZSBwYXJzZUV4cHJlc3Npb24oKTogRXhwcmVzc2lvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQWRkaXRpdmUoKVxuICAgIH1cbn1cblxuLyoqIFBhcnNlcyBhIHRlbXBsYXRlLiAqL1xuZXhwb3J0IGNsYXNzIFRlbXBsYXRlUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBwdWJsaWMgcGFyc2UodGVtcGxhdGVTdHI6IHN0cmluZyk6IEV4cHJlc3Npb24ge1xuICAgICAgICBpZiAoIXRoaXMubGV4ZXIpIHtcbiAgICAgICAgICAgIHRoaXMubGV4ZXIgPSBuZXcgVGVtcGxhdGVMZXhlcigpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxleGVyLnJlc2V0KHRlbXBsYXRlU3RyKVxuICAgICAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZVRlbXBsYXRlKClcblxuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMubGV4ZXIubmV4dCgpXG4gICAgICAgIGlmICh0b2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgICAgICAgYFVuZXhwZWN0ZWQgdG9rZW4gYXQgZW5kIG9mIHRlbXBsYXRlIGlucHV0OiAke0pTT04uc3RyaW5naWZ5KHRva2VuLnZhbHVlKX0gKGF0ICR7dGhpcy5sZXhlci5pbmRleH0pYFxuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHJcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoT3AodG9rZW46IFBpY2s8VG9rZW4sICd0eXBlJyB8ICd2YWx1ZSc+IHwgdW5kZWZpbmVkLCBvcDogT3BlcmF0b3IpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdG9rZW4gIT09IHVuZGVmaW5lZCAmJiB0b2tlbi50eXBlID09PSBUb2tlblR5cGUuT3BlcmF0b3IgJiYgdG9rZW4udmFsdWUgPT09IG9wXG59XG4iXX0=