---
source: crates/sg-syntax/src/sg_treesitter.rs
assertion_line: 362
expression: "snapshot_treesitter_syntax_kinds(&document, &contents)"
---
  package HTTP::Config;
//^^^^^^^ Keyword
//        ^^^^^^^^^^^^ IdentifierType
  
  use strict;
//^^^ Keyword
//    ^^^^^^ IdentifierType
  use URI;
//^^^ Keyword
//    ^^^ IdentifierType
  use vars qw($VERSION);
//^^^ Keyword
//    ^^^^ IdentifierType
//         ^^^^^^^^^^^^ StringLiteral
  
  $VERSION = "5.835";
//^^^^^^^^ Identifier
//         ^ IdentifierOperator
//           ^^^^^^^ StringLiteral
  
  sub new {
//^^^ Keyword
//    ^^^ IdentifierFunction
      my $class = shift;
//    ^^ Keyword
//       ^^^^^^ Identifier
//              ^ IdentifierOperator
//                ^^^^^ IdentifierBuiltin
      return bless [], $class;
//    ^^^^^^ Keyword
//                     ^^^^^^ Identifier
  }
  
  sub entries {
//^^^ Keyword
//    ^^^^^^^ IdentifierFunction
      my $self = shift;
//    ^^ Keyword
//       ^^^^^ Identifier
//             ^ IdentifierOperator
//               ^^^^^ IdentifierBuiltin
      @$self;
//    ^ Identifier
//     ^^^^^ Identifier
  }
  
  sub empty {
//^^^ Keyword
//    ^^^^^ IdentifierFunction
      my $self = shift;
//    ^^ Keyword
//       ^^^^^ Identifier
//             ^ IdentifierOperator
//               ^^^^^ IdentifierBuiltin
      not @$self;
//        ^ Identifier
//         ^^^^^ Identifier
  }
  
  sub add {
//^^^ Keyword
//    ^^^ IdentifierFunction
      if (@_ == 2) {
//    ^^ Keyword
//        ^^ Identifier
//              ^ NumericLiteral
          my $self = shift;
//        ^^ Keyword
//           ^^^^^ Identifier
//                 ^ IdentifierOperator
//                   ^^^^^ IdentifierBuiltin
          push(@$self, shift);
//        ^^^^ IdentifierFunction
//             ^ Identifier
//              ^^^^^ Identifier
//                     ^^^^^ IdentifierBuiltin
          return;
//        ^^^^^^ Keyword
      }
      my($self, %spec) = @_;
//    ^^ Keyword
//       ^^^^^ Identifier
//              ^^^^^ Identifier
//                     ^ IdentifierOperator
//                       ^^ Identifier
      push(@$self, \%spec);
//    ^^^^ IdentifierFunction
//         ^ Identifier
//          ^^^^^ Identifier
//                  ^^^^^ Identifier
      return;
//    ^^^^^^ Keyword
  }
  
  sub find2 {
//^^^ Keyword
//    ^^^^^ IdentifierFunction
      my($self, %spec) = @_;
//    ^^ Keyword
//       ^^^^^ Identifier
//              ^^^^^ Identifier
//                     ^ IdentifierOperator
//                       ^^ Identifier
      my @found;
//    ^^ Keyword
//       ^^^^^^ Identifier
      my @rest;
//    ^^ Keyword
//       ^^^^^ Identifier
   ITEM:
      for my $item (@$self) {
//    ^^^ Keyword
//        ^^ Keyword
//           ^^^^^ Identifier
//                  ^ Identifier
//                   ^^^^^ Identifier
          for my $k (keys %spec) {
//        ^^^ Keyword
//            ^^ Keyword
//               ^^ Identifier
//                   ^^^^ IdentifierBuiltin
//                        ^^^^^ Identifier
              if (!exists $item->{$k} || $spec{$k} ne $item->{$k}) {
//            ^^ Keyword
//                 ^^^^^^ IdentifierBuiltin
//                        ^^^^^ Identifier
//                             ^^ Identifier
//                               ^ Identifier
//                                ^^ Identifier
//                                  ^ Identifier
//                                       ^^^^^ Identifier
//                                            ^ Identifier
//                                             ^^ Identifier
//                                               ^ Identifier
//                                                 ^^ IdentifierOperator
//                                                    ^^^^^ Identifier
//                                                         ^^ Identifier
//                                                           ^ Identifier
//                                                            ^^ Identifier
//                                                              ^ Identifier
                  push(@rest, $item);
//                ^^^^ IdentifierFunction
//                     ^^^^^ Identifier
//                            ^^^^^ Identifier
                  next ITEM;
//                ^^^^ Keyword
              }
          }
          push(@found, $item);
//        ^^^^ IdentifierFunction
//             ^^^^^^ Identifier
//                     ^^^^^ Identifier
      }
      return \@found unless wantarray;
//    ^^^^^^ Keyword
//            ^^^^^^ Identifier
//                   ^^^^^^ Keyword
//                          ^^^^^^^^^ IdentifierBuiltin
      return \@found, \@rest;
//    ^^^^^^ Keyword
//            ^^^^^^ Identifier
//                     ^^^^^ Identifier
  }
  
  sub find {
//^^^ Keyword
//    ^^^^ IdentifierFunction
      my $self = shift;
//    ^^ Keyword
//       ^^^^^ Identifier
//             ^ IdentifierOperator
//               ^^^^^ IdentifierBuiltin
      my $f = $self->find2(@_);
//    ^^ Keyword
//       ^^ Identifier
//          ^ IdentifierOperator
//            ^^^^^ Identifier
//                   ^^^^^ IdentifierFunction
//                         ^^ Identifier
      return @$f if wantarray;
//    ^^^^^^ Keyword
//           ^ Identifier
//            ^^ Identifier
//               ^^ Keyword
//                  ^^^^^^^^^ IdentifierBuiltin
      return $f->[0];
//    ^^^^^^ Keyword
//           ^^ Identifier
//             ^^ Identifier
//               ^ Identifier
//                ^ NumericLiteral
//                 ^ Identifier
  }
  
  sub remove {
//^^^ Keyword
//    ^^^^^^ IdentifierFunction
      my($self, %spec) = @_;
//    ^^ Keyword
//       ^^^^^ Identifier
//              ^^^^^ Identifier
//                     ^ IdentifierOperator
//                       ^^ Identifier
      my($removed, $rest) = $self->find2(%spec);
//    ^^ Keyword
//       ^^^^^^^^ Identifier
//                 ^^^^^ Identifier
//                        ^ IdentifierOperator
//                          ^^^^^ Identifier
//                                 ^^^^^ IdentifierFunction
//                                       ^^^^^ Identifier
      @$self = @$rest if @$removed;
//    ^ Identifier
//     ^^^^^ Identifier
//           ^ IdentifierOperator
//             ^ Identifier
//              ^^^^^ Identifier
//                    ^^ Keyword
//                       ^ Identifier
//                        ^^^^^^^^ Identifier
      return @$removed;
//    ^^^^^^ Keyword
//           ^ Identifier
//            ^^^^^^^^ Identifier
  }
  
  my %MATCH = (
//^^ Keyword
//   ^^^^^^ Identifier
//          ^ IdentifierOperator
      m_scheme => sub {
//    ^^^^^^^^^ StringLiteral
//             ^^ IdentifierOperator
//                ^^^ Keyword
          my($v, $uri) = @_;
//        ^^ Keyword
//           ^^ Identifier
//               ^^^^ Identifier
//                     ^ IdentifierOperator
//                       ^^ Identifier
          return $uri->_scheme eq $v;  # URI known to be canonical
//        ^^^^^^ Keyword
//               ^^^^ Identifier
//                     ^^^^^^^ IdentifierFunction
//                             ^^ IdentifierOperator
//                                ^^ Identifier
//                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment
      },
      m_secure => sub {
//    ^^^^^^^^^ StringLiteral
//             ^^ IdentifierOperator
//                ^^^ Keyword
          my($v, $uri) = @_;
//        ^^ Keyword
//           ^^ Identifier
//               ^^^^ Identifier
//                     ^ IdentifierOperator
//                       ^^ Identifier
          my $secure = $uri->can("secure") ? $uri->secure : $uri->_scheme eq "https";
//        ^^ Keyword
//           ^^^^^^^ Identifier
//                   ^ IdentifierOperator
//                     ^^^^ Identifier
//                           ^^^ IdentifierFunction
//                               ^^^^^^^^ StringLiteral
//                                           ^^^^ Identifier
//                                                 ^^^^^^ IdentifierFunction
//                                                          ^^^^ Identifier
//                                                                ^^^^^^^ IdentifierFunction
//                                                                        ^^ IdentifierOperator
//                                                                           ^^^^^^^ StringLiteral
          return $secure == !!$v;
//        ^^^^^^ Keyword
//               ^^^^^^^ Identifier
//                            ^^ Identifier
      },
      m_host_port => sub {
//    ^^^^^^^^^^^^ StringLiteral
//                ^^ IdentifierOperator
//                   ^^^ Keyword
          my($v, $uri) = @_;
//        ^^ Keyword
//           ^^ Identifier
//               ^^^^ Identifier
//                     ^ IdentifierOperator
//                       ^^ Identifier
          return unless $uri->can("host_port");
//        ^^^^^^ Keyword
//               ^^^^^^ Keyword
//                      ^^^^ Identifier
//                            ^^^ IdentifierFunction
//                                ^^^^^^^^^^^ StringLiteral
          return $uri->host_port eq $v, 7;
//        ^^^^^^ Keyword
//               ^^^^ Identifier
//                     ^^^^^^^^^ IdentifierFunction
//                               ^^ IdentifierOperator
//                                  ^^ Identifier
//                                      ^ NumericLiteral
      },
      m_host => sub {
//    ^^^^^^^ StringLiteral
//           ^^ IdentifierOperator
//              ^^^ Keyword
          my($v, $uri) = @_;
//        ^^ Keyword
//           ^^ Identifier
//               ^^^^ Identifier
//                     ^ IdentifierOperator
//                       ^^ Identifier
          return unless $uri->can("host");
//        ^^^^^^ Keyword
//               ^^^^^^ Keyword
//                      ^^^^ Identifier
//                            ^^^ IdentifierFunction
//                                ^^^^^^ StringLiteral
          return $uri->host eq $v, 6;
//        ^^^^^^ Keyword
//               ^^^^ Identifier
//                     ^^^^ IdentifierFunction
//                          ^^ IdentifierOperator
//                             ^^ Identifier
//                                 ^ NumericLiteral
      },
      m_port => sub {
//    ^^^^^^^ StringLiteral
//           ^^ IdentifierOperator
//              ^^^ Keyword
          my($v, $uri) = @_;
//        ^^ Keyword
//           ^^ Identifier
//               ^^^^ Identifier
//                     ^ IdentifierOperator
//                       ^^ Identifier
          return unless $uri->can("port");
//        ^^^^^^ Keyword
//               ^^^^^^ Keyword
//                      ^^^^ Identifier
//                            ^^^ IdentifierFunction
//                                ^^^^^^ StringLiteral
          return $uri->port eq $v;
//        ^^^^^^ Keyword
//               ^^^^ Identifier
//                     ^^^^ IdentifierFunction
//                          ^^ IdentifierOperator
//                             ^^ Identifier
      },
      m_domain => sub {
//    ^^^^^^^^^ StringLiteral
//             ^^ IdentifierOperator
//                ^^^ Keyword
          my($v, $uri) = @_;
//        ^^ Keyword
//           ^^ Identifier
//               ^^^^ Identifier
//                     ^ IdentifierOperator
//                       ^^ Identifier
          return unless $uri->can("host");
//        ^^^^^^ Keyword
//               ^^^^^^ Keyword
//                      ^^^^ Identifier
//                            ^^^ IdentifierFunction
//                                ^^^^^^ StringLiteral
          my $h = $uri->host;
//        ^^ Keyword
//           ^^ Identifier
//              ^ IdentifierOperator
//                ^^^^ Identifier
//                      ^^^^ IdentifierFunction
          $h = "$h.local" unless $h =~ /\./;
//        ^^ Identifier
//           ^ IdentifierOperator
//             ^ StringLiteral
//              ^^ Identifier
//                ^^^^^^^ StringLiteral
//                        ^^^^^^ Keyword
//                               ^^ Identifier
//                                  ^^ IdentifierOperator
          $v = ".$v" unless $v =~ /^\./;
//        ^^ Identifier
//           ^ IdentifierOperator
//             ^^ StringLiteral
//               ^^ Identifier
//                 ^ StringLiteral
//                   ^^^^^^ Keyword
//                          ^^ Identifier
//                             ^^ IdentifierOperator
          return length($v), 5 if substr($h, -length($v)) eq $v;
//        ^^^^^^ Keyword
//               ^^^^^^ IdentifierBuiltin
//                      ^^ Identifier
//                           ^ NumericLiteral
//                             ^^ Keyword
//                                ^^^^^^ IdentifierFunction
//                                       ^^ Identifier
//                                           ^^ IdentifierBuiltin
//                                             ^^^^^ IdentifierFunction
//                                                   ^^ Identifier
//                                                        ^^ IdentifierOperator
//                                                           ^^ Identifier
          return 0;
//        ^^^^^^ Keyword
//               ^ NumericLiteral
      },
      m_path => sub {
//    ^^^^^^^ StringLiteral
//           ^^ IdentifierOperator
//              ^^^ Keyword
          my($v, $uri) = @_;
//        ^^ Keyword
//           ^^ Identifier
//               ^^^^ Identifier
//                     ^ IdentifierOperator
//                       ^^ Identifier
          return unless $uri->can("path");
//        ^^^^^^ Keyword
//               ^^^^^^ Keyword
//                      ^^^^ Identifier
//                            ^^^ IdentifierFunction
//                                ^^^^^^ StringLiteral
          return $uri->path eq $v, 4;
//        ^^^^^^ Keyword
//               ^^^^ Identifier
//                     ^^^^ IdentifierFunction
//                          ^^ IdentifierOperator
//                             ^^ Identifier
//                                 ^ NumericLiteral
      },
      m_path_prefix => sub {
//    ^^^^^^^^^^^^^^ StringLiteral
//                  ^^ IdentifierOperator
//                     ^^^ Keyword
          my($v, $uri) = @_;
//        ^^ Keyword
//           ^^ Identifier
//               ^^^^ Identifier
//                     ^ IdentifierOperator
//                       ^^ Identifier
          return unless $uri->can("path");
//        ^^^^^^ Keyword
//               ^^^^^^ Keyword
//                      ^^^^ Identifier
//                            ^^^ IdentifierFunction
//                                ^^^^^^ StringLiteral
          my $path = $uri->path;
//        ^^ Keyword
//           ^^^^^ Identifier
//                 ^ IdentifierOperator
//                   ^^^^ Identifier
//                         ^^^^ IdentifierFunction
          my $len = length($v);
//        ^^ Keyword
//           ^^^^ Identifier
//                ^ IdentifierOperator
//                  ^^^^^^ IdentifierBuiltin
//                         ^^ Identifier
          return $len, 3 if $path eq $v;
//        ^^^^^^ Keyword
//               ^^^^ Identifier
//                     ^ NumericLiteral
//                       ^^ Keyword
//                          ^^^^^ Identifier
//                                ^^ IdentifierOperator
//                                   ^^ Identifier
          return 0 if length($path) <= $len;
//        ^^^^^^ Keyword
//               ^ NumericLiteral
//                 ^^ Keyword
//                    ^^^^^^ IdentifierBuiltin
//                           ^^^^^ Identifier
//                                     ^^^^ Identifier
          $v .= "/" unless $v =~ m,/\z,,;
//        ^^ Identifier
//              ^^^ StringLiteral
//                  ^^^^^^ Keyword
//                         ^^ Identifier
//                            ^^ IdentifierOperator
//                               ^ Keyword
//                                   ^ Keyword
          return $len, 3 if substr($path, 0, length($v)) eq $v;
//        ^^^^^^ Keyword
//               ^^^^ Identifier
//                     ^ NumericLiteral
//                       ^^ Keyword
//                          ^^^^^^ IdentifierFunction
//                                 ^^^^^ Identifier
//                                        ^ NumericLiteral
//                                           ^^^^^^ IdentifierBuiltin
//                                                  ^^ Identifier
//                                                       ^^ IdentifierOperator
//                                                          ^^ Identifier
          return 0;
//        ^^^^^^ Keyword
//               ^ NumericLiteral
      },
      m_path_match => sub {
//    ^^^^^^^^^^^^^ StringLiteral
//                 ^^ IdentifierOperator
//                    ^^^ Keyword
          my($v, $uri) = @_;
//        ^^ Keyword
//           ^^ Identifier
//               ^^^^ Identifier
//                     ^ IdentifierOperator
//                       ^^ Identifier
          return unless $uri->can("path");
//        ^^^^^^ Keyword
//               ^^^^^^ Keyword
//                      ^^^^ Identifier
//                            ^^^ IdentifierFunction
//                                ^^^^^^ StringLiteral
          return $uri->path =~ $v;
//        ^^^^^^ Keyword
//               ^^^^ Identifier
//                     ^^^^ IdentifierFunction
//                          ^^ IdentifierOperator
//                             ^^ Identifier
      },
      m_uri__ => sub {
//    ^^^^^^^^ StringLiteral
//            ^^ IdentifierOperator
//               ^^^ Keyword
          my($v, $k, $uri) = @_;
//        ^^ Keyword
//           ^^ Identifier
//               ^^ Identifier
//                   ^^^^ Identifier
//                         ^ IdentifierOperator
//                           ^^ Identifier
          return unless $uri->can($k);
//        ^^^^^^ Keyword
//               ^^^^^^ Keyword
//                      ^^^^ Identifier
//                            ^^^ IdentifierFunction
//                                ^^ Identifier
          return 1 unless defined $v;
//        ^^^^^^ Keyword
//               ^ NumericLiteral
//                 ^^^^^^ Keyword
//                        ^^^^^^^ IdentifierBuiltin
//                                ^^ Identifier
          return $uri->$k eq $v;
//        ^^^^^^ Keyword
//               ^^^^ Identifier
//                     ^^ Identifier
//                        ^^ IdentifierOperator
//                           ^^ Identifier
      },
      m_method => sub {
//    ^^^^^^^^^ StringLiteral
//             ^^ IdentifierOperator
//                ^^^ Keyword
          my($v, $uri, $request) = @_;
//        ^^ Keyword
//           ^^ Identifier
//               ^^^^ Identifier
//                     ^^^^^^^^ Identifier
//                               ^ IdentifierOperator
//                                 ^^ Identifier
          return $request && $request->method eq $v;
//        ^^^^^^ Keyword
//               ^^^^^^^^ Identifier
//                           ^^^^^^^^ Identifier
//                                     ^^^^^^ IdentifierFunction
//                                            ^^ IdentifierOperator
//                                               ^^ Identifier
      },
      m_proxy => sub {
//    ^^^^^^^^ StringLiteral
//            ^^ IdentifierOperator
//               ^^^ Keyword
          my($v, $uri, $request) = @_;
//        ^^ Keyword
//           ^^ Identifier
//               ^^^^ Identifier
//                     ^^^^^^^^ Identifier
//                               ^ IdentifierOperator
//                                 ^^ Identifier
          return $request && ($request->{proxy} || "") eq $v;
//        ^^^^^^ Keyword
//               ^^^^^^^^ Identifier
//                            ^^^^^^^^ Identifier
//                                    ^^ Identifier
//                                      ^ Identifier
//                                       ^^^^^ StringLiteral
//                                            ^ Identifier
//                                                 ^^ StringLiteral
//                                                     ^^ IdentifierOperator
//                                                        ^^ Identifier
      },
      m_code => sub {
//    ^^^^^^^ StringLiteral
//           ^^ IdentifierOperator
//              ^^^ Keyword
          my($v, $uri, $request, $response) = @_;
//        ^^ Keyword
//           ^^ Identifier
//               ^^^^ Identifier
//                     ^^^^^^^^ Identifier
//                               ^^^^^^^^^ Identifier
//                                          ^ IdentifierOperator
//                                            ^^ Identifier
          $v =~ s/xx\z//;
//        ^^ Identifier
//           ^^ IdentifierOperator
//              ^ Keyword
//               ^^^^^^^ StringLiteral
          return unless $response;
//        ^^^^^^ Keyword
//               ^^^^^^ Keyword
//                      ^^^^^^^^^ Identifier
          return length($v), 2 if substr($response->code, 0, length($v)) eq $v;
//        ^^^^^^ Keyword
//               ^^^^^^ IdentifierBuiltin
//                      ^^ Identifier
//                           ^ NumericLiteral
//                             ^^ Keyword
//                                ^^^^^^ IdentifierFunction
//                                       ^^^^^^^^^ Identifier
//                                                  ^^^^ IdentifierFunction
//                                                        ^ NumericLiteral
//                                                           ^^^^^^ IdentifierBuiltin
//                                                                  ^^ Identifier
//                                                                       ^^ IdentifierOperator
//                                                                          ^^ Identifier
      },
      m_media_type => sub {  # for request too??
//    ^^^^^^^^^^^^^ StringLiteral
//                 ^^ IdentifierOperator
//                    ^^^ Keyword
//                           ^^^^^^^^^^^^^^^^^^^ Comment
          my($v, $uri, $request, $response) = @_;
//        ^^ Keyword
//           ^^ Identifier
//               ^^^^ Identifier
//                     ^^^^^^^^ Identifier
//                               ^^^^^^^^^ Identifier
//                                          ^ IdentifierOperator
//                                            ^^ Identifier
          return unless $response;
//        ^^^^^^ Keyword
//               ^^^^^^ Keyword
//                      ^^^^^^^^^ Identifier
          return 1, 1 if $v eq "*/*";
//        ^^^^^^ Keyword
//               ^ NumericLiteral
//                  ^ NumericLiteral
//                    ^^ Keyword
//                       ^^ Identifier
//                          ^^ IdentifierOperator
//                             ^^^^^ StringLiteral
          my $ct = $response->content_type;
//        ^^ Keyword
//           ^^^ Identifier
//               ^ IdentifierOperator
//                 ^^^^^^^^^ Identifier
//                            ^^^^^^^^^^^^ IdentifierFunction
          return 2, 1 if $v =~ s,/\*\z,, && $ct =~ m,^\Q$v\E/,;
//        ^^^^^^ Keyword
//               ^ NumericLiteral
//                  ^ NumericLiteral
//                    ^^ Keyword
//                       ^^ Identifier
//                          ^^ IdentifierOperator
//                                          ^^^ Identifier
//                                              ^^ IdentifierOperator
//                                                 ^ Keyword
//                                                      ^^ Identifier
          return 3, 1 if $v eq "html" && $response->content_is_html;
//        ^^^^^^ Keyword
//               ^ NumericLiteral
//                  ^ NumericLiteral
//                    ^^ Keyword
//                       ^^ Identifier
//                          ^^ IdentifierOperator
//                             ^^^^^^ StringLiteral
//                                       ^^^^^^^^^ Identifier
//                                                  ^^^^^^^^^^^^^^^ IdentifierFunction
          return 4, 1 if $v eq "xhtml" && $response->content_is_xhtml;
//        ^^^^^^ Keyword
//               ^ NumericLiteral
//                  ^ NumericLiteral
//                    ^^ Keyword
//                       ^^ Identifier
//                          ^^ IdentifierOperator
//                             ^^^^^^^ StringLiteral
//                                        ^^^^^^^^^ Identifier
//                                                   ^^^^^^^^^^^^^^^^ IdentifierFunction
          return 10, 1 if $v eq $ct;
//        ^^^^^^ Keyword
//               ^^ NumericLiteral
//                   ^ NumericLiteral
//                     ^^ Keyword
//                        ^^ Identifier
//                           ^^ IdentifierOperator
//                              ^^^ Identifier
          return 0;
//        ^^^^^^ Keyword
//               ^ NumericLiteral
      },
      m_header__ => sub {
//    ^^^^^^^^^^^ StringLiteral
//               ^^ IdentifierOperator
//                  ^^^ Keyword
          my($v, $k, $uri, $request, $response) = @_;
//        ^^ Keyword
//           ^^ Identifier
//               ^^ Identifier
//                   ^^^^ Identifier
//                         ^^^^^^^^ Identifier
//                                   ^^^^^^^^^ Identifier
//                                              ^ IdentifierOperator
//                                                ^^ Identifier
          return unless $request;
//        ^^^^^^ Keyword
//               ^^^^^^ Keyword
//                      ^^^^^^^^ Identifier
          return 1 if $request->header($k) eq $v;
//        ^^^^^^ Keyword
//               ^ NumericLiteral
//                 ^^ Keyword
//                    ^^^^^^^^ Identifier
//                              ^^^^^^ IdentifierFunction
//                                     ^^ Identifier
//                                         ^^ IdentifierOperator
//                                            ^^ Identifier
          return 1 if $response && $response->header($k) eq $v;
//        ^^^^^^ Keyword
//               ^ NumericLiteral
//                 ^^ Keyword
//                    ^^^^^^^^^ Identifier
//                                 ^^^^^^^^^ Identifier
//                                            ^^^^^^ IdentifierFunction
//                                                   ^^ Identifier
//                                                       ^^ IdentifierOperator
//                                                          ^^ Identifier
          return 0;
//        ^^^^^^ Keyword
//               ^ NumericLiteral
      },
      m_response_attr__ => sub {
//    ^^^^^^^^^^^^^^^^^^ StringLiteral
//                      ^^ IdentifierOperator
//                         ^^^ Keyword
          my($v, $k, $uri, $request, $response) = @_;
//        ^^ Keyword
//           ^^ Identifier
//               ^^ Identifier
//                   ^^^^ Identifier
//                         ^^^^^^^^ Identifier
//                                   ^^^^^^^^^ Identifier
//                                              ^ IdentifierOperator
//                                                ^^ Identifier
          return unless $response;
//        ^^^^^^ Keyword
//               ^^^^^^ Keyword
//                      ^^^^^^^^^ Identifier
          return 1 if !defined($v) && exists $response->{$k};
//        ^^^^^^ Keyword
//               ^ NumericLiteral
//                 ^^ Keyword
//                     ^^^^^^^ IdentifierBuiltin
//                             ^^ Identifier
//                                    ^^^^^^ IdentifierBuiltin
//                                           ^^^^^^^^^ Identifier
//                                                    ^^ Identifier
//                                                      ^ Identifier
//                                                       ^^ Identifier
//                                                         ^ Identifier
          return 0 unless exists $response->{$k};
//        ^^^^^^ Keyword
//               ^ NumericLiteral
//                 ^^^^^^ Keyword
//                        ^^^^^^ IdentifierBuiltin
//                               ^^^^^^^^^ Identifier
//                                        ^^ Identifier
//                                          ^ Identifier
//                                           ^^ Identifier
//                                             ^ Identifier
          return 1 if $response->{$k} eq $v;
//        ^^^^^^ Keyword
//               ^ NumericLiteral
//                 ^^ Keyword
//                    ^^^^^^^^^ Identifier
//                             ^^ Identifier
//                               ^ Identifier
//                                ^^ Identifier
//                                  ^ Identifier
//                                    ^^ IdentifierOperator
//                                       ^^ Identifier
          return 0;
//        ^^^^^^ Keyword
//               ^ NumericLiteral
      },
  );
  
  sub matching {
//^^^ Keyword
//    ^^^^^^^^ IdentifierFunction
      my $self = shift;
//    ^^ Keyword
//       ^^^^^ Identifier
//             ^ IdentifierOperator
//               ^^^^^ IdentifierBuiltin
      if (@_ == 1) {
//    ^^ Keyword
//        ^^ Identifier
//              ^ NumericLiteral
          if ($_[0]->can("request")) {
//        ^^ Keyword
//            ^^ Identifier
//              ^ Identifier
//               ^ NumericLiteral
//                ^ Identifier
//                   ^^^ IdentifierFunction
//                       ^^^^^^^^^ StringLiteral
              unshift(@_, $_[0]->request);
//            ^^^^^^^ IdentifierFunction
//                    ^^ Identifier
//                        ^^ Identifier
//                          ^ Identifier
//                           ^ NumericLiteral
//                            ^ Identifier
//                               ^^^^^^^ IdentifierFunction
              unshift(@_, undef) unless defined $_[0];
//            ^^^^^^^ IdentifierFunction
//                    ^^ Identifier
//                        ^^^^^ Keyword
//                               ^^^^^^ Keyword
//                                      ^^^^^^^ IdentifierBuiltin
//                                              ^^ Identifier
//                                                ^ Identifier
//                                                 ^ NumericLiteral
//                                                  ^ Identifier
          }
          unshift(@_, $_[0]->uri_canonical) if $_[0] && $_[0]->can("uri_canonical");
//        ^^^^^^^ IdentifierFunction
//                ^^ Identifier
//                    ^^ Identifier
//                      ^ Identifier
//                       ^ NumericLiteral
//                        ^ Identifier
//                           ^^^^^^^^^^^^^ IdentifierFunction
//                                          ^^ Keyword
//                                             ^^ Identifier
//                                               ^ Identifier
//                                                ^ NumericLiteral
//                                                 ^ Identifier
//                                                      ^^ Identifier
//                                                        ^ Identifier
//                                                         ^ NumericLiteral
//                                                          ^ Identifier
//                                                             ^^^ IdentifierFunction
//                                                                 ^^^^^^^^^^^^^^^ StringLiteral
      }
      my($uri, $request, $response) = @_;
//    ^^ Keyword
//       ^^^^ Identifier
//             ^^^^^^^^ Identifier
//                       ^^^^^^^^^ Identifier
//                                  ^ IdentifierOperator
//                                    ^^ Identifier
      $uri = URI->new($uri) unless ref($uri);
//    ^^^^ Identifier
//         ^ IdentifierOperator
//           ^^^ IdentifierType
//                ^^^ IdentifierFunction
//                    ^^^^ Identifier
//                          ^^^^^^ Keyword
//                                 ^^^ IdentifierBuiltin
//                                     ^^^^ Identifier
  
      my @m;
//    ^^ Keyword
//       ^^ Identifier
   ITEM:
      for my $item (@$self) {
//    ^^^ Keyword
//        ^^ Keyword
//           ^^^^^ Identifier
//                  ^ Identifier
//                   ^^^^^ Identifier
          my $order;
//        ^^ Keyword
//           ^^^^^^ Identifier
          for my $ikey (keys %$item) {
//        ^^^ Keyword
//            ^^ Keyword
//               ^^^^^ Identifier
//                      ^^^^ IdentifierBuiltin
//                           ^ Identifier
//                            ^^^^^ Identifier
              my $mkey = $ikey;
//            ^^ Keyword
//               ^^^^^ Identifier
//                     ^ IdentifierOperator
//                       ^^^^^ Identifier
              my $k;
//            ^^ Keyword
//               ^^ Identifier
              $k = $1 if $mkey =~ s/__(.*)/__/;
//            ^^ Identifier
//               ^ IdentifierOperator
//                 ^^ Identifier
//                    ^^ Keyword
//                       ^^^^^ Identifier
//                             ^^ IdentifierOperator
//                                ^ Keyword
//                                 ^^^^^^^^^^^ StringLiteral
              if (my $m = $MATCH{$mkey}) {
//            ^^ Keyword
//                ^^ Keyword
//                   ^^ Identifier
//                      ^ IdentifierOperator
//                        ^^^^^^ Identifier
//                              ^ Identifier
//                               ^^^^^ Identifier
//                                    ^ Identifier
                  #print "$ikey $mkey\n";
//                ^^^^^^^^^^^^^^^^^^^^^^^ Comment
                  my($c, $o);
//                ^^ Keyword
//                   ^^ Identifier
//                       ^^ Identifier
                  my @arg = (
//                ^^ Keyword
//                   ^^^^ Identifier
//                        ^ IdentifierOperator
                      defined($k) ? $k : (),
//                    ^^^^^^^ IdentifierBuiltin
//                            ^^ Identifier
//                                  ^^ Identifier
                      $uri, $request, $response
//                    ^^^^ Identifier
//                          ^^^^^^^^ Identifier
//                                    ^^^^^^^^^ Identifier
                  );
                  my $v = $item->{$ikey};
//                ^^ Keyword
//                   ^^ Identifier
//                      ^ IdentifierOperator
//                        ^^^^^ Identifier
//                             ^^ Identifier
//                               ^ Identifier
//                                ^^^^^ Identifier
//                                     ^ Identifier
                  $v = [$v] unless ref($v) eq "ARRAY";
//                ^^ Identifier
//                   ^ IdentifierOperator
//                      ^^ Identifier
//                          ^^^^^^ Keyword
//                                 ^^^ IdentifierBuiltin
//                                     ^^ Identifier
//                                         ^^ IdentifierOperator
//                                            ^^^^^^^ StringLiteral
                  for (@$v) {
//                ^^^ Keyword
//                     ^ Identifier
//                      ^^ Identifier
                      ($c, $o) = $m->($_, @arg);
//                     ^^ Identifier
//                         ^^ Identifier
//                             ^ IdentifierOperator
//                               ^^ Identifier
//                                    ^^ Identifier
//                                        ^^^^ Identifier
                      #print "  - $_ ==> $c $o\n";
//                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment
                      last if $c;
//                    ^^^^ Keyword
//                         ^^ Keyword
//                            ^^ Identifier
                  }
                  next ITEM unless $c;
//                ^^^^ Keyword
//                          ^^^^^^ Keyword
//                                 ^^ Identifier
                  $order->[$o || 0] += $c;
//                ^^^^^^ Identifier
//                      ^^ Identifier
//                        ^ Identifier
//                         ^^ Identifier
//                               ^ NumericLiteral
//                                ^ Identifier
//                                     ^^ Identifier
              }
          }
          $order->[7] ||= 0;
//        ^^^^^^ Identifier
//              ^^ Identifier
//                ^ Identifier
//                 ^ NumericLiteral
//                  ^ Identifier
//                        ^ NumericLiteral
          $item->{_order} = join(".", reverse map sprintf("%03d", $_ || 0), @$order);
//        ^^^^^ Identifier
//             ^^ Identifier
//               ^ Identifier
//                ^^^^^^ StringLiteral
//                      ^ Identifier
//                        ^ IdentifierOperator
//                          ^^^^ IdentifierFunction
//                               ^^^ StringLiteral
//                                                ^^^^^^^ IdentifierFunction
//                                                        ^^^^^^ StringLiteral
//                                                                ^^ Identifier
//                                                                      ^ NumericLiteral
//                                                                          ^ Identifier
//                                                                           ^^^^^^ Identifier
          push(@m, $item);
//        ^^^^ IdentifierFunction
//             ^^ Identifier
//                 ^^^^^ Identifier
      }
      @m = sort { $b->{_order} cmp $a->{_order} } @m;
//    ^^ Identifier
//       ^ IdentifierOperator
//                ^^ Identifier
//                  ^^ Identifier
//                    ^ Identifier
//                     ^^^^^^ StringLiteral
//                           ^ Identifier
//                             ^^^ IdentifierOperator
//                                 ^^ Identifier
//                                   ^^ Identifier
//                                     ^ Identifier
//                                      ^^^^^^ StringLiteral
//                                            ^ Identifier
//                                                ^^ Identifier
      delete $_->{_order} for @m;
//    ^^^^^^ IdentifierBuiltin
//           ^^ Identifier
//             ^^ Identifier
//               ^ Identifier
//                ^^^^^^ StringLiteral
//                      ^ Identifier
//                        ^^^ Keyword
//                            ^^ Identifier
      return @m if wantarray;
//    ^^^^^^ Keyword
//           ^^ Identifier
//              ^^ Keyword
//                 ^^^^^^^^^ IdentifierBuiltin
      return $m[0];
//    ^^^^^^ Keyword
//           ^^ Identifier
//             ^ Identifier
//              ^ NumericLiteral
//               ^ Identifier
  }
  
  sub add_item {
//^^^ Keyword
//    ^^^^^^^^ IdentifierFunction
      my $self = shift;
//    ^^ Keyword
//       ^^^^^ Identifier
//             ^ IdentifierOperator
//               ^^^^^ IdentifierBuiltin
      my $item = shift;
//    ^^ Keyword
//       ^^^^^ Identifier
//             ^ IdentifierOperator
//               ^^^^^ IdentifierBuiltin
      return $self->add(item => $item, @_);
//    ^^^^^^ Keyword
//           ^^^^^ Identifier
//                  ^^^ IdentifierFunction
//                      ^^^^^ StringLiteral
//                           ^^ IdentifierOperator
//                              ^^^^^ Identifier
//                                     ^^ Identifier
  }
  
  sub remove_items {
//^^^ Keyword
//    ^^^^^^^^^^^^ IdentifierFunction
      my $self = shift;
//    ^^ Keyword
//       ^^^^^ Identifier
//             ^ IdentifierOperator
//               ^^^^^ IdentifierBuiltin
      return map $_->{item}, $self->remove(@_);
//    ^^^^^^ Keyword
//               ^^ Identifier
//                 ^^ Identifier
//                   ^ Identifier
//                    ^^^^ StringLiteral
//                        ^ Identifier
//                           ^^^^^ Identifier
//                                  ^^^^^^ IdentifierFunction
//                                         ^^ Identifier
  }
  
  sub matching_items {
//^^^ Keyword
//    ^^^^^^^^^^^^^^ IdentifierFunction
      my $self = shift;
//    ^^ Keyword
//       ^^^^^ Identifier
//             ^ IdentifierOperator
//               ^^^^^ IdentifierBuiltin
      return map $_->{item}, $self->matching(@_);
//    ^^^^^^ Keyword
//               ^^ Identifier
//                 ^^ Identifier
//                   ^ Identifier
//                    ^^^^ StringLiteral
//                        ^ Identifier
//                           ^^^^^ Identifier
//                                  ^^^^^^^^ IdentifierFunction
//                                           ^^ Identifier
  }
  
  1;
//^ NumericLiteral
  
  __END__
  
  =head1 NAME
//^^^^^^ Keyword
  
  HTTP::Config - Configuration for request and response objects
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 239:0..240:0
  
  =head1 SYNOPSIS
//^^^^^^ Keyword
  
   use HTTP::Config;
// ^^^ Keyword
//     ^^^^^^^^^^^^ IdentifierType
   my $c = HTTP::Config->new;
// ^^ Keyword
//    ^^ Identifier
//       ^ IdentifierOperator
//         ^^^^^^^^^^^^ IdentifierType
//                       ^^^ IdentifierFunction
   $c->add(m_domain => ".example.com", m_scheme => "http", verbose => 1);
// ^^ Identifier
//     ^^^ IdentifierFunction
//         ^^^^^^^^^ StringLiteral
//                  ^^ IdentifierOperator
//                     ^^^^^^^^^^^^^^ StringLiteral
//                                     ^^^^^^^^^ StringLiteral
//                                              ^^ IdentifierOperator
//                                                 ^^^^^^ StringLiteral
//                                                         ^^^^^^^^ StringLiteral
//                                                                 ^^ IdentifierOperator
//                                                                    ^ NumericLiteral
  
   use HTTP::Request;
// ^^^ Keyword
//     ^^^^^^^^^^^^^ IdentifierType
   my $request = HTTP::Request->new(GET => "http://www.example.com");
// ^^ Keyword
//    ^^^^^^^^ Identifier
//             ^ IdentifierOperator
//               ^^^^^^^^^^^^^ IdentifierType
//                              ^^^ IdentifierFunction
//                                  ^^^^ StringLiteral
//                                      ^^ IdentifierOperator
//                                         ^^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
   if (my @m = $c->matching($request)) {
// ^^ Keyword
//     ^^ Keyword
//        ^^ Identifier
//           ^ IdentifierOperator
//             ^^ Identifier
//                 ^^^^^^^^ IdentifierFunction
//                          ^^^^^^^^ Identifier
      print "Yadayada\n" if $m[0]->{verbose};
//          ^^^^^^^^^ StringLiteral
//                   ^^ StringLiteral
//                     ^ StringLiteral
//                       ^^ Keyword
//                          ^^ Identifier
//                            ^ Identifier
//                             ^ NumericLiteral
//                              ^ Identifier
//                               ^^ Identifier
//                                 ^ Identifier
//                                  ^^^^^^^ StringLiteral
//                                         ^ Identifier
   }
  
  =head1 DESCRIPTION
//^^^^^^ Keyword
  
  An C<HTTP::Config> object is a list of entries that
//^^^ Comment
//   ^^^^^^^^^^^^^^^ Identifier
//                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 256:18..260:0
  can be matched against request or request/response pairs.  Its
  purpose is to hold configuration data that can be looked up given a
  request or response object.
  
  Each configuration entry is a hash.  Some keys specify matching to
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 261:0..264:0
  occur against attributes of request/response objects.  Other keys can
  be used to hold user data.
  
  The following methods are provided:
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 265:0..266:0
  
  =over 4
//^^^^^ Keyword
//     ^^ StringLiteral
  
  =item $conf = HTTP::Config->new
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  Constructs a new empty C<HTTP::Config> object and returns it.
//^^^^^^^^^^^^^^^^^^^^^^^ Comment
//                       ^^^^^^^^^^^^^^^ Identifier
//                                      ^^^^^^^^^^^^^^^^^^^^^^^ Comment 271:38..272:0
  
  =item $conf->entries
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^ StringLiteral
  
  Returns the list of entries in the configuration object.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 275:0..277:0
  In scalar context returns the number of entries.
  
  =item $conf->empty
//^^^^^ Keyword
//     ^^^^^^^^^^^^^ StringLiteral
  
  Return true if there are no entries in the configuration object.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 280:0..281:29
  This is just a shorthand for C<< not $conf->entries >>.
//                             ^^^^^^^^^^^^^^^ Identifier
//                                            ^^^^^^^^^^^ Comment 281:44..282:0
  
  =item $conf->add( %matchspec, %other )
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  =item $conf->add( \%entry )
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  Adds a new entry to the configuration.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 287:0..289:0
  You can either pass separate key/value pairs or a hash reference.
  
  =item $conf->remove( %spec )
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  Removes (and returns) the entries that have matches for all the key/value pairs in %spec.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 292:0..294:0
  If %spec is empty this will match all entries; so it will empty the configuation object.
  
  =item $conf->matching( $uri, $request, $response )
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  =item $conf->matching( $uri )
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  =item $conf->matching( $request )
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  =item $conf->matching( $response )
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  Returns the entries that match the given $uri, $request and $response triplet.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 303:0..304:0
  
  If called with a single $request object then the $uri is obtained by calling its 'uri_canonical' method.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 305:0..308:0
  If called with a single $response object, then the request object is obtained by calling its 'request' method;
  and then the $uri is obtained as if a single $request was provided.
  
  The entries are returned with the most specific matches first.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 309:0..310:53
  In scalar context returns the most specific match or C<undef> in none match.
//                                                     ^^^^^^^^ Identifier
//                                                             ^^^^^^^^^^^^^^^ Comment 310:61..311:0
  
  =item $conf->add_item( $item, %matchspec )
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  =item $conf->remove_items( %spec )
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  =item $conf->matching_items( $uri, $request, $response )
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  Wrappers that hides the entries themselves.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 318:0..319:0
  
  =back
//^^^^^ Keyword
  
  =head2 Matching
//^^^^^^ Keyword
  
  The following keys on a configuration entry specify matching.  For all
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 324:0..327:0
  of these you can provide an array of values instead of a single value.
  The entry matches if at least one of the values in the array matches.
  
  Entries that require match against a response object attribute will never match
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 328:0..330:0
  unless a response object was provided.
  
  =over
//^^^^^ Keyword
  
  =item m_scheme => $scheme
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  Matches if the URI uses the specified scheme; e.g. "http".
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 335:0..336:0
  
  =item m_secure => $bool
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^ StringLiteral
  
  If $bool is TRUE; matches if the URI uses a secure scheme.  If $bool
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 339:0..342:0
  is FALSE; matches if the URI does not use a secure scheme.  An example
  of a secure scheme is "https".
  
  =item m_host_port => "$hostname:$port"
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  Matches if the URI's host_port method return the specified value.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 345:0..346:0
  
  =item m_host => $hostname
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  Matches if the URI's host method returns the specified value.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 349:0..350:0
  
  =item m_port => $port
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^ StringLiteral
  
  Matches if the URI's port method returns the specified value.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 353:0..354:0
  
  =item m_domain => ".$domain"
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  Matches if the URI's host method return a value that within the given
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 357:0..360:0
  domain.  The hostname "www.example.com" will for instance match the
  domain ".com".
  
  =item m_path => $path
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^ StringLiteral
  
  Matches if the URI's path method returns the specified value.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 363:0..364:0
  
  =item m_path_prefix => $path
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  Matches if the URI's path is the specified path or has the specified
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 367:0..369:0
  path as prefix.
  
  =item m_path_match => $Regexp
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  Matches if the regular expression matches the URI's path.  Eg. qr/\.html$/.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 372:0..373:0
  
  =item m_method => $method
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  Matches if the request method matches the specified value. Eg. "GET" or "POST".
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 376:0..377:0
  
  =item m_code => $digit
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^ StringLiteral
  
  =item m_code => $status_code
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  Matches if the response status code matches.  If a single digit is
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 382:0..384:0
  specified; matches for all response status codes beginning with that digit.
  
  =item m_proxy => $url
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^ StringLiteral
  
  Matches if the request is to be sent to the given Proxy server.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 387:0..388:0
  
  =item m_media_type => "*/*"
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  =item m_media_type => "text/*"
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  =item m_media_type => "html"
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  =item m_media_type => "xhtml"
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  =item m_media_type => "text/html"
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ StringLiteral
  
  Matches if the response media type matches.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 399:0..400:0
  
  With a value of "html" matches if $response->content_is_html returns TRUE.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 401:0..403:0
  With a value of "xhtml" matches if $response->content_is_xhtml returns TRUE.
  
  =item m_uri__I<$method> => undef
//^^^^^ Keyword
//     ^^^^^^^^ StringLiteral
//             ^^^^^^^^^^ Identifier
//                       ^^^^^^^^^ StringLiteral
  
  Matches if the URI object provides the method.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 406:0..407:0
  
  =item m_uri__I<$method> => $string
//^^^^^ Keyword
//     ^^^^^^^^ StringLiteral
//             ^^^^^^^^^^ Identifier
//                       ^^^^^^^^^^^ StringLiteral
  
  Matches if the URI's $method method returns the given value.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 410:0..411:0
  
  =item m_header__I<$field> => $string
//^^^^^ Keyword
//     ^^^^^^^^^^^ StringLiteral
//                ^^^^^^^^^ Identifier
//                         ^^^^^^^^^^^ StringLiteral
  
  Matches if either the request or the response have a header $field with the given value.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 414:0..415:0
  
  =item m_response_attr__I<$key> => undef
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^ StringLiteral
//                       ^^^^^^^ Identifier
//                              ^^^^^^^^^ StringLiteral
  
  =item m_response_attr__I<$key> => $string
//^^^^^ Keyword
//     ^^^^^^^^^^^^^^^^^^ StringLiteral
//                       ^^^^^^^ Identifier
//                              ^^^^^^^^^^^ StringLiteral
  
  Matches if the response object has that key, or the entry has the given value.
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 420:0..421:0
  
  =back
//^^^^^ Keyword
  
  =head1 SEE ALSO
//^^^^^^ Keyword
  
  L<URI>, L<HTTP::Request>, L<HTTP::Response>
//^^^^^^ Identifier
//      ^^ Comment
//        ^^^^^^^^^^^^^^^^ Identifier
//                        ^^ Comment
//                          ^^^^^^^^^^^^^^^^^ Identifier
//                                            Comment 426:43..427:0
  
  =head1 COPYRIGHT
//^^^^^^ Keyword
  
  Copyright 2008, Gisle Aas
//^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 430:0..431:0
  
  This library is free software; you can redistribute it and/or
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Comment 432:0..434:0
  modify it under the same terms as Perl itself.
  
  =cut
//^^^^ Keyword
//    ^ Comment

