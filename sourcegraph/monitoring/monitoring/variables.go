package monitoring

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/grafana-tools/sdk"
	"github.com/grafana/regexp"
	"github.com/prometheus/prometheus/model/labels"

	"github.com/sourcegraph/sourcegraph/lib/errors"
	"github.com/sourcegraph/sourcegraph/monitoring/monitoring/internal/promql"
)

type ContainerVariableOptionType string

const (
	OptionTypeInterval = "interval"
)

type ContainerVariableOptions struct {
	Options []string
	// DefaultOption is the option that should be selected by default.
	DefaultOption string
	// Type of the options. You can usually leave this unset.
	Type ContainerVariableOptionType
}

type ContainerVariableOptionsLabelValues struct {
	// Query, the result of which is used to find Label.
	Query string
	// LabelName denotes the name of the label whose values to use as options.
	LabelName string
	// ExampleOption is an example of a valid option for this variable that may be
	// generated by Query, and must be provided if using Query.
	ExampleOption string
}

// ContainerVariable describes a template variable that can be applied container dashboard
// for filtering purposes.
type ContainerVariable struct {
	// Name is the name of the variable to substitute the value for, e.g. "alert_level"
	// to replace "$alert_level" in queries
	Name string
	// Label is a human-readable name for the variable, e.g. "Alert level"
	Label string

	// OptionsLabelValues defines label values to generate the possible options for this
	// variable (equivalent to 'label_values(.Query, .Label)'). Cannot be used in
	// conjunction with Options.
	OptionsLabelValues ContainerVariableOptionsLabelValues
	// Options are the pre-defined possible options for this variable. Cannot be used in
	// conjunction with OptionsLabel
	Options ContainerVariableOptions

	// WildcardAllValue indicates to Grafana that is should NOT use OptionsQuery or Options to
	// generate a concatonated 'All' value for the variable, and use a '.*' wildcard
	// instead. Setting this to true primarily useful if you use Query and expect it to be
	// a large enough result set to cause issues when viewing the dashboard.
	//
	// We allow Grafana to generate a value by default because simply using '.*' wildcard
	// can pull in unintended metrics if adequate filtering is not performed on the query,
	// for example if multiple services export the same metric. If set to true, make sure
	// the queries that use this variable perform adequate filtering to avoid pulling in
	// unintended metrics.
	WildcardAllValue bool

	// Multi indicates whether or not to allow multi-selection for this variable filter
	Multi bool
}

func (c *ContainerVariable) validate() error {
	if c.Name == "" {
		return errors.New("ContainerVariable.Name is required")
	}
	if c.Label == "" {
		return errors.New("ContainerVariable.Label is required")
	}
	if c.OptionsLabelValues.Query == "" && len(c.Options.Options) == 0 {
		return errors.New("one of ContainerVariable.OptionsQuery and ContainerVariable.Options must be set")
	}
	if c.OptionsLabelValues.Query != "" {
		if len(c.Options.Options) > 0 {
			return errors.New("ContainerVariable.OptionsQuery and ContainerVariable.Options cannot both be set")
		}
		if c.OptionsLabelValues.LabelName == "" {
			return errors.New("ContainerVariable.OptionsQuery.LabelName must be set")
		}
		if c.OptionsLabelValues.ExampleOption == "" {
			return errors.New("ContainerVariable.OptionsQuery.ExampleOption must be set")
		}
	}
	return nil
}

// toGrafanaTemplateVar generates the Grafana template variable configuration for this
// container variable.
func (c *ContainerVariable) toGrafanaTemplateVar(injectLabelMatchers []*labels.Matcher) (sdk.TemplateVar, error) {
	variable := sdk.TemplateVar{
		Name:  c.Name,
		Label: c.Label,
		Multi: c.Multi,

		Datasource: StringPtr("Prometheus"),
		IncludeAll: true,

		// Apply the AllValue to a template variable by default
		Current: sdk.Current{Text: &sdk.StringSliceString{Value: []string{"all"}, Valid: true}, Value: "$__all"},
	}

	if c.WildcardAllValue {
		variable.AllValue = ".*"
	} else {
		// Rely on Grafana to create a union of only the values
		// generated by the specified query.
		//
		// See https://grafana.com/docs/grafana/latest/variables/formatting-multi-value-variables/#multi-value-variables-with-a-prometheus-or-influxdb-data-source
		// for more information.
		variable.AllValue = ""
	}

	switch {
	case c.OptionsLabelValues.Query != "":
		variable.Type = "query"
		expr, err := promql.InjectMatchers(c.OptionsLabelValues.Query, injectLabelMatchers, nil)
		if err != nil {
			return variable, errors.Wrap(err, "OptionsLabelValues.Query")
		}
		variable.Query = fmt.Sprintf("label_values(%s, %s)", expr, c.OptionsLabelValues.LabelName)
		variable.Refresh = sdk.BoolInt{
			Flag:  true,
			Value: Int64Ptr(2), // Refresh on time range change
		}
		variable.Sort = 3
		variable.Options = []sdk.Option{} // Cannot be null in later versions of Grafana

	case len(c.Options.Options) > 0:
		// Set the type
		variable.Type = "custom"
		if c.Options.Type != "" {
			variable.Type = string(c.Options.Type)
		}
		// Generate our options
		variable.Query = strings.Join(c.Options.Options, ",")

		// On interval options, don't allow the selection of 'all' intervals, since
		// this is a one-of-many selection
		var hasAllOption bool
		if c.Options.Type != OptionTypeInterval {
			// Add the AllValue as a default, only selected if a default is not configured
			hasAllOption = true
			selected := c.Options.DefaultOption == ""
			variable.Options = append(variable.Options, sdk.Option{Text: "all", Value: "$__all", Selected: selected})
		}
		// Generate options
		for i, option := range c.Options.Options {
			// Whether this option should be selected
			var selected bool
			if c.Options.DefaultOption != "" {
				// If an default option is provided, select that
				selected = option == c.Options.DefaultOption
			} else if !hasAllOption {
				// Otherwise if there is no 'all' option generated, select the first
				selected = i == 0
			}

			variable.Options = append(variable.Options, sdk.Option{Text: option, Value: option, Selected: selected})
			if selected {
				// Also configure current
				variable.Current = sdk.Current{
					Text: &sdk.StringSliceString{
						Value: []string{option},
						Valid: true,
					},
					Value: option,
				}
			}
		}
	}

	return variable, nil
}

var numbers = regexp.MustCompile(`^\d+`)

// getSentinelValue provides an easily distuingishable sentinel example value for this
// variable that allows a query with variables to be converted into a valid Prometheus
// query.
func (c *ContainerVariable) getSentinelValue() string {
	var example string
	switch {
	case len(c.Options.Options) > 0:
		example = c.Options.Options[0]
	case c.OptionsLabelValues.Query != "":
		example = c.OptionsLabelValues.ExampleOption
	default:
		return ""
	}
	// Scramble numerics - replace with a number that is very unlikely to conflict with
	// some other existing number in the query, this helps us distinguish what values
	// were replaced. It also must be less than 60, since we don't want it to be
	// reformatted as hours if it is a duration-based thing.
	//
	// To help prevent 2 variables from colliding, we do a simple heuristic where the
	// variable name contributes to the generated number.
	sentinelNumber := strconv.Itoa(60 - len(c.Name))
	return numbers.ReplaceAllString(example, sentinelNumber)
}

// newVariableApplier returns a VariableApplier with intervals.
func newVariableApplier(vars []ContainerVariable) promql.VariableApplier {
	return newVariableApplierWith(vars, true)
}

func newVariableApplierWith(vars []ContainerVariable, intervalVariables bool) promql.VariableApplier {
	if intervalVariables {
		// Make sure Grafana's '$__rate_interval' is interpolated with valid PromQL
		vars = append(vars,
			ContainerVariable{
				// https://grafana.com/docs/grafana/latest/datasources/prometheus/#using-__rate_interval
				Name: "__rate_interval",
				Options: ContainerVariableOptions{
					// We need a strange value here for getSentinelValue to reliably
					// reverse the replacement to convert this into valid PromQL - it's a
					// it hack, but not sure if we have a better option here.
					Options: []string{"123m"},
				},
			})
	}

	applier := promql.VariableApplier{}
	for _, v := range vars {
		sentinel := v.getSentinelValue()

		// If we are not allowing intervals, do not allow variables that are numeric.
		if !intervalVariables && numbers.Match([]byte(sentinel)) {
			continue
		}

		applier[v.Name] = sentinel
	}
	return applier
}
