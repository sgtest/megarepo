// Code generated by go-mockgen 1.1.2; DO NOT EDIT.

package dbmock

import (
	"context"
	"sync"
	"time"

	database "github.com/sourcegraph/sourcegraph/internal/database"
	basestore "github.com/sourcegraph/sourcegraph/internal/database/basestore"
	types "github.com/sourcegraph/sourcegraph/internal/types"
)

// MockEventLogStore is a mock implementation of the EventLogStore interface
// (from the package github.com/sourcegraph/sourcegraph/internal/database)
// used for unit testing.
type MockEventLogStore struct {
	// AggregatedCodeIntelEventsFunc is an instance of a mock function
	// object controlling the behavior of the method
	// AggregatedCodeIntelEvents.
	AggregatedCodeIntelEventsFunc *EventLogStoreAggregatedCodeIntelEventsFunc
	// AggregatedSearchEventsFunc is an instance of a mock function object
	// controlling the behavior of the method AggregatedSearchEvents.
	AggregatedSearchEventsFunc *EventLogStoreAggregatedSearchEventsFunc
	// BulkInsertFunc is an instance of a mock function object controlling
	// the behavior of the method BulkInsert.
	BulkInsertFunc *EventLogStoreBulkInsertFunc
	// CodeIntelligenceCrossRepositoryWAUsFunc is an instance of a mock
	// function object controlling the behavior of the method
	// CodeIntelligenceCrossRepositoryWAUs.
	CodeIntelligenceCrossRepositoryWAUsFunc *EventLogStoreCodeIntelligenceCrossRepositoryWAUsFunc
	// CodeIntelligencePreciseCrossRepositoryWAUsFunc is an instance of a
	// mock function object controlling the behavior of the method
	// CodeIntelligencePreciseCrossRepositoryWAUs.
	CodeIntelligencePreciseCrossRepositoryWAUsFunc *EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFunc
	// CodeIntelligencePreciseWAUsFunc is an instance of a mock function
	// object controlling the behavior of the method
	// CodeIntelligencePreciseWAUs.
	CodeIntelligencePreciseWAUsFunc *EventLogStoreCodeIntelligencePreciseWAUsFunc
	// CodeIntelligenceRepositoryCountsFunc is an instance of a mock
	// function object controlling the behavior of the method
	// CodeIntelligenceRepositoryCounts.
	CodeIntelligenceRepositoryCountsFunc *EventLogStoreCodeIntelligenceRepositoryCountsFunc
	// CodeIntelligenceRepositoryCountsByLanguageFunc is an instance of a
	// mock function object controlling the behavior of the method
	// CodeIntelligenceRepositoryCountsByLanguage.
	CodeIntelligenceRepositoryCountsByLanguageFunc *EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFunc
	// CodeIntelligenceSearchBasedCrossRepositoryWAUsFunc is an instance of
	// a mock function object controlling the behavior of the method
	// CodeIntelligenceSearchBasedCrossRepositoryWAUs.
	CodeIntelligenceSearchBasedCrossRepositoryWAUsFunc *EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFunc
	// CodeIntelligenceSearchBasedWAUsFunc is an instance of a mock function
	// object controlling the behavior of the method
	// CodeIntelligenceSearchBasedWAUs.
	CodeIntelligenceSearchBasedWAUsFunc *EventLogStoreCodeIntelligenceSearchBasedWAUsFunc
	// CodeIntelligenceSettingsPageViewCountFunc is an instance of a mock
	// function object controlling the behavior of the method
	// CodeIntelligenceSettingsPageViewCount.
	CodeIntelligenceSettingsPageViewCountFunc *EventLogStoreCodeIntelligenceSettingsPageViewCountFunc
	// CodeIntelligenceWAUsFunc is an instance of a mock function object
	// controlling the behavior of the method CodeIntelligenceWAUs.
	CodeIntelligenceWAUsFunc *EventLogStoreCodeIntelligenceWAUsFunc
	// CountByUserIDFunc is an instance of a mock function object
	// controlling the behavior of the method CountByUserID.
	CountByUserIDFunc *EventLogStoreCountByUserIDFunc
	// CountByUserIDAndEventNameFunc is an instance of a mock function
	// object controlling the behavior of the method
	// CountByUserIDAndEventName.
	CountByUserIDAndEventNameFunc *EventLogStoreCountByUserIDAndEventNameFunc
	// CountByUserIDAndEventNamePrefixFunc is an instance of a mock function
	// object controlling the behavior of the method
	// CountByUserIDAndEventNamePrefix.
	CountByUserIDAndEventNamePrefixFunc *EventLogStoreCountByUserIDAndEventNamePrefixFunc
	// CountByUserIDAndEventNamesFunc is an instance of a mock function
	// object controlling the behavior of the method
	// CountByUserIDAndEventNames.
	CountByUserIDAndEventNamesFunc *EventLogStoreCountByUserIDAndEventNamesFunc
	// CountUniqueUsersAllFunc is an instance of a mock function object
	// controlling the behavior of the method CountUniqueUsersAll.
	CountUniqueUsersAllFunc *EventLogStoreCountUniqueUsersAllFunc
	// CountUniqueUsersByEventNameFunc is an instance of a mock function
	// object controlling the behavior of the method
	// CountUniqueUsersByEventName.
	CountUniqueUsersByEventNameFunc *EventLogStoreCountUniqueUsersByEventNameFunc
	// CountUniqueUsersByEventNamePrefixFunc is an instance of a mock
	// function object controlling the behavior of the method
	// CountUniqueUsersByEventNamePrefix.
	CountUniqueUsersByEventNamePrefixFunc *EventLogStoreCountUniqueUsersByEventNamePrefixFunc
	// CountUniqueUsersByEventNamesFunc is an instance of a mock function
	// object controlling the behavior of the method
	// CountUniqueUsersByEventNames.
	CountUniqueUsersByEventNamesFunc *EventLogStoreCountUniqueUsersByEventNamesFunc
	// CountUniqueUsersPerPeriodFunc is an instance of a mock function
	// object controlling the behavior of the method
	// CountUniqueUsersPerPeriod.
	CountUniqueUsersPerPeriodFunc *EventLogStoreCountUniqueUsersPerPeriodFunc
	// DoneFunc is an instance of a mock function object controlling the
	// behavior of the method Done.
	DoneFunc *EventLogStoreDoneFunc
	// HandleFunc is an instance of a mock function object controlling the
	// behavior of the method Handle.
	HandleFunc *EventLogStoreHandleFunc
	// InsertFunc is an instance of a mock function object controlling the
	// behavior of the method Insert.
	InsertFunc *EventLogStoreInsertFunc
	// LatestPingFunc is an instance of a mock function object controlling
	// the behavior of the method LatestPing.
	LatestPingFunc *EventLogStoreLatestPingFunc
	// ListAllFunc is an instance of a mock function object controlling the
	// behavior of the method ListAll.
	ListAllFunc *EventLogStoreListAllFunc
	// ListUniqueUsersAllFunc is an instance of a mock function object
	// controlling the behavior of the method ListUniqueUsersAll.
	ListUniqueUsersAllFunc *EventLogStoreListUniqueUsersAllFunc
	// MaxTimestampByUserIDFunc is an instance of a mock function object
	// controlling the behavior of the method MaxTimestampByUserID.
	MaxTimestampByUserIDFunc *EventLogStoreMaxTimestampByUserIDFunc
	// MaxTimestampByUserIDAndSourceFunc is an instance of a mock function
	// object controlling the behavior of the method
	// MaxTimestampByUserIDAndSource.
	MaxTimestampByUserIDAndSourceFunc *EventLogStoreMaxTimestampByUserIDAndSourceFunc
	// SiteUsageFunc is an instance of a mock function object controlling
	// the behavior of the method SiteUsage.
	SiteUsageFunc *EventLogStoreSiteUsageFunc
	// TransactFunc is an instance of a mock function object controlling the
	// behavior of the method Transact.
	TransactFunc *EventLogStoreTransactFunc
	// UsersUsageCountsFunc is an instance of a mock function object
	// controlling the behavior of the method UsersUsageCounts.
	UsersUsageCountsFunc *EventLogStoreUsersUsageCountsFunc
	// WithFunc is an instance of a mock function object controlling the
	// behavior of the method With.
	WithFunc *EventLogStoreWithFunc
}

// NewMockEventLogStore creates a new mock of the EventLogStore interface.
// All methods return zero values for all results, unless overwritten.
func NewMockEventLogStore() *MockEventLogStore {
	return &MockEventLogStore{
		AggregatedCodeIntelEventsFunc: &EventLogStoreAggregatedCodeIntelEventsFunc{
			defaultHook: func(context.Context) ([]types.CodeIntelAggregatedEvent, error) {
				return nil, nil
			},
		},
		AggregatedSearchEventsFunc: &EventLogStoreAggregatedSearchEventsFunc{
			defaultHook: func(context.Context, time.Time) ([]types.SearchAggregatedEvent, error) {
				return nil, nil
			},
		},
		BulkInsertFunc: &EventLogStoreBulkInsertFunc{
			defaultHook: func(context.Context, []*database.Event) error {
				return nil
			},
		},
		CodeIntelligenceCrossRepositoryWAUsFunc: &EventLogStoreCodeIntelligenceCrossRepositoryWAUsFunc{
			defaultHook: func(context.Context) (int, error) {
				return 0, nil
			},
		},
		CodeIntelligencePreciseCrossRepositoryWAUsFunc: &EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFunc{
			defaultHook: func(context.Context) (int, error) {
				return 0, nil
			},
		},
		CodeIntelligencePreciseWAUsFunc: &EventLogStoreCodeIntelligencePreciseWAUsFunc{
			defaultHook: func(context.Context) (int, error) {
				return 0, nil
			},
		},
		CodeIntelligenceRepositoryCountsFunc: &EventLogStoreCodeIntelligenceRepositoryCountsFunc{
			defaultHook: func(context.Context) (database.CodeIntelligenceRepositoryCounts, error) {
				return database.CodeIntelligenceRepositoryCounts{}, nil
			},
		},
		CodeIntelligenceRepositoryCountsByLanguageFunc: &EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFunc{
			defaultHook: func(context.Context) (map[string]database.CodeIntelligenceRepositoryCountsForLanguage, error) {
				return nil, nil
			},
		},
		CodeIntelligenceSearchBasedCrossRepositoryWAUsFunc: &EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFunc{
			defaultHook: func(context.Context) (int, error) {
				return 0, nil
			},
		},
		CodeIntelligenceSearchBasedWAUsFunc: &EventLogStoreCodeIntelligenceSearchBasedWAUsFunc{
			defaultHook: func(context.Context) (int, error) {
				return 0, nil
			},
		},
		CodeIntelligenceSettingsPageViewCountFunc: &EventLogStoreCodeIntelligenceSettingsPageViewCountFunc{
			defaultHook: func(context.Context) (int, error) {
				return 0, nil
			},
		},
		CodeIntelligenceWAUsFunc: &EventLogStoreCodeIntelligenceWAUsFunc{
			defaultHook: func(context.Context) (int, error) {
				return 0, nil
			},
		},
		CountByUserIDFunc: &EventLogStoreCountByUserIDFunc{
			defaultHook: func(context.Context, int32) (int, error) {
				return 0, nil
			},
		},
		CountByUserIDAndEventNameFunc: &EventLogStoreCountByUserIDAndEventNameFunc{
			defaultHook: func(context.Context, int32, string) (int, error) {
				return 0, nil
			},
		},
		CountByUserIDAndEventNamePrefixFunc: &EventLogStoreCountByUserIDAndEventNamePrefixFunc{
			defaultHook: func(context.Context, int32, string) (int, error) {
				return 0, nil
			},
		},
		CountByUserIDAndEventNamesFunc: &EventLogStoreCountByUserIDAndEventNamesFunc{
			defaultHook: func(context.Context, int32, []string) (int, error) {
				return 0, nil
			},
		},
		CountUniqueUsersAllFunc: &EventLogStoreCountUniqueUsersAllFunc{
			defaultHook: func(context.Context, time.Time, time.Time) (int, error) {
				return 0, nil
			},
		},
		CountUniqueUsersByEventNameFunc: &EventLogStoreCountUniqueUsersByEventNameFunc{
			defaultHook: func(context.Context, time.Time, time.Time, string) (int, error) {
				return 0, nil
			},
		},
		CountUniqueUsersByEventNamePrefixFunc: &EventLogStoreCountUniqueUsersByEventNamePrefixFunc{
			defaultHook: func(context.Context, time.Time, time.Time, string) (int, error) {
				return 0, nil
			},
		},
		CountUniqueUsersByEventNamesFunc: &EventLogStoreCountUniqueUsersByEventNamesFunc{
			defaultHook: func(context.Context, time.Time, time.Time, []string) (int, error) {
				return 0, nil
			},
		},
		CountUniqueUsersPerPeriodFunc: &EventLogStoreCountUniqueUsersPerPeriodFunc{
			defaultHook: func(context.Context, database.PeriodType, time.Time, int, *database.CountUniqueUsersOptions) ([]database.UsageValue, error) {
				return nil, nil
			},
		},
		DoneFunc: &EventLogStoreDoneFunc{
			defaultHook: func(error) error {
				return nil
			},
		},
		HandleFunc: &EventLogStoreHandleFunc{
			defaultHook: func() *basestore.TransactableHandle {
				return nil
			},
		},
		InsertFunc: &EventLogStoreInsertFunc{
			defaultHook: func(context.Context, *database.Event) error {
				return nil
			},
		},
		LatestPingFunc: &EventLogStoreLatestPingFunc{
			defaultHook: func(context.Context) (*types.Event, error) {
				return nil, nil
			},
		},
		ListAllFunc: &EventLogStoreListAllFunc{
			defaultHook: func(context.Context, database.EventLogsListOptions) ([]*types.Event, error) {
				return nil, nil
			},
		},
		ListUniqueUsersAllFunc: &EventLogStoreListUniqueUsersAllFunc{
			defaultHook: func(context.Context, time.Time, time.Time) ([]int32, error) {
				return nil, nil
			},
		},
		MaxTimestampByUserIDFunc: &EventLogStoreMaxTimestampByUserIDFunc{
			defaultHook: func(context.Context, int32) (*time.Time, error) {
				return nil, nil
			},
		},
		MaxTimestampByUserIDAndSourceFunc: &EventLogStoreMaxTimestampByUserIDAndSourceFunc{
			defaultHook: func(context.Context, int32, string) (*time.Time, error) {
				return nil, nil
			},
		},
		SiteUsageFunc: &EventLogStoreSiteUsageFunc{
			defaultHook: func(context.Context) (types.SiteUsageSummary, error) {
				return types.SiteUsageSummary{}, nil
			},
		},
		TransactFunc: &EventLogStoreTransactFunc{
			defaultHook: func(context.Context) (database.EventLogStore, error) {
				return nil, nil
			},
		},
		UsersUsageCountsFunc: &EventLogStoreUsersUsageCountsFunc{
			defaultHook: func(context.Context) ([]types.UserUsageCounts, error) {
				return nil, nil
			},
		},
		WithFunc: &EventLogStoreWithFunc{
			defaultHook: func(basestore.ShareableStore) database.EventLogStore {
				return nil
			},
		},
	}
}

// NewMockEventLogStoreFrom creates a new mock of the MockEventLogStore
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockEventLogStoreFrom(i database.EventLogStore) *MockEventLogStore {
	return &MockEventLogStore{
		AggregatedCodeIntelEventsFunc: &EventLogStoreAggregatedCodeIntelEventsFunc{
			defaultHook: i.AggregatedCodeIntelEvents,
		},
		AggregatedSearchEventsFunc: &EventLogStoreAggregatedSearchEventsFunc{
			defaultHook: i.AggregatedSearchEvents,
		},
		BulkInsertFunc: &EventLogStoreBulkInsertFunc{
			defaultHook: i.BulkInsert,
		},
		CodeIntelligenceCrossRepositoryWAUsFunc: &EventLogStoreCodeIntelligenceCrossRepositoryWAUsFunc{
			defaultHook: i.CodeIntelligenceCrossRepositoryWAUs,
		},
		CodeIntelligencePreciseCrossRepositoryWAUsFunc: &EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFunc{
			defaultHook: i.CodeIntelligencePreciseCrossRepositoryWAUs,
		},
		CodeIntelligencePreciseWAUsFunc: &EventLogStoreCodeIntelligencePreciseWAUsFunc{
			defaultHook: i.CodeIntelligencePreciseWAUs,
		},
		CodeIntelligenceRepositoryCountsFunc: &EventLogStoreCodeIntelligenceRepositoryCountsFunc{
			defaultHook: i.CodeIntelligenceRepositoryCounts,
		},
		CodeIntelligenceRepositoryCountsByLanguageFunc: &EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFunc{
			defaultHook: i.CodeIntelligenceRepositoryCountsByLanguage,
		},
		CodeIntelligenceSearchBasedCrossRepositoryWAUsFunc: &EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFunc{
			defaultHook: i.CodeIntelligenceSearchBasedCrossRepositoryWAUs,
		},
		CodeIntelligenceSearchBasedWAUsFunc: &EventLogStoreCodeIntelligenceSearchBasedWAUsFunc{
			defaultHook: i.CodeIntelligenceSearchBasedWAUs,
		},
		CodeIntelligenceSettingsPageViewCountFunc: &EventLogStoreCodeIntelligenceSettingsPageViewCountFunc{
			defaultHook: i.CodeIntelligenceSettingsPageViewCount,
		},
		CodeIntelligenceWAUsFunc: &EventLogStoreCodeIntelligenceWAUsFunc{
			defaultHook: i.CodeIntelligenceWAUs,
		},
		CountByUserIDFunc: &EventLogStoreCountByUserIDFunc{
			defaultHook: i.CountByUserID,
		},
		CountByUserIDAndEventNameFunc: &EventLogStoreCountByUserIDAndEventNameFunc{
			defaultHook: i.CountByUserIDAndEventName,
		},
		CountByUserIDAndEventNamePrefixFunc: &EventLogStoreCountByUserIDAndEventNamePrefixFunc{
			defaultHook: i.CountByUserIDAndEventNamePrefix,
		},
		CountByUserIDAndEventNamesFunc: &EventLogStoreCountByUserIDAndEventNamesFunc{
			defaultHook: i.CountByUserIDAndEventNames,
		},
		CountUniqueUsersAllFunc: &EventLogStoreCountUniqueUsersAllFunc{
			defaultHook: i.CountUniqueUsersAll,
		},
		CountUniqueUsersByEventNameFunc: &EventLogStoreCountUniqueUsersByEventNameFunc{
			defaultHook: i.CountUniqueUsersByEventName,
		},
		CountUniqueUsersByEventNamePrefixFunc: &EventLogStoreCountUniqueUsersByEventNamePrefixFunc{
			defaultHook: i.CountUniqueUsersByEventNamePrefix,
		},
		CountUniqueUsersByEventNamesFunc: &EventLogStoreCountUniqueUsersByEventNamesFunc{
			defaultHook: i.CountUniqueUsersByEventNames,
		},
		CountUniqueUsersPerPeriodFunc: &EventLogStoreCountUniqueUsersPerPeriodFunc{
			defaultHook: i.CountUniqueUsersPerPeriod,
		},
		DoneFunc: &EventLogStoreDoneFunc{
			defaultHook: i.Done,
		},
		HandleFunc: &EventLogStoreHandleFunc{
			defaultHook: i.Handle,
		},
		InsertFunc: &EventLogStoreInsertFunc{
			defaultHook: i.Insert,
		},
		LatestPingFunc: &EventLogStoreLatestPingFunc{
			defaultHook: i.LatestPing,
		},
		ListAllFunc: &EventLogStoreListAllFunc{
			defaultHook: i.ListAll,
		},
		ListUniqueUsersAllFunc: &EventLogStoreListUniqueUsersAllFunc{
			defaultHook: i.ListUniqueUsersAll,
		},
		MaxTimestampByUserIDFunc: &EventLogStoreMaxTimestampByUserIDFunc{
			defaultHook: i.MaxTimestampByUserID,
		},
		MaxTimestampByUserIDAndSourceFunc: &EventLogStoreMaxTimestampByUserIDAndSourceFunc{
			defaultHook: i.MaxTimestampByUserIDAndSource,
		},
		SiteUsageFunc: &EventLogStoreSiteUsageFunc{
			defaultHook: i.SiteUsage,
		},
		TransactFunc: &EventLogStoreTransactFunc{
			defaultHook: i.Transact,
		},
		UsersUsageCountsFunc: &EventLogStoreUsersUsageCountsFunc{
			defaultHook: i.UsersUsageCounts,
		},
		WithFunc: &EventLogStoreWithFunc{
			defaultHook: i.With,
		},
	}
}

// EventLogStoreAggregatedCodeIntelEventsFunc describes the behavior when
// the AggregatedCodeIntelEvents method of the parent MockEventLogStore
// instance is invoked.
type EventLogStoreAggregatedCodeIntelEventsFunc struct {
	defaultHook func(context.Context) ([]types.CodeIntelAggregatedEvent, error)
	hooks       []func(context.Context) ([]types.CodeIntelAggregatedEvent, error)
	history     []EventLogStoreAggregatedCodeIntelEventsFuncCall
	mutex       sync.Mutex
}

// AggregatedCodeIntelEvents delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockEventLogStore) AggregatedCodeIntelEvents(v0 context.Context) ([]types.CodeIntelAggregatedEvent, error) {
	r0, r1 := m.AggregatedCodeIntelEventsFunc.nextHook()(v0)
	m.AggregatedCodeIntelEventsFunc.appendCall(EventLogStoreAggregatedCodeIntelEventsFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// AggregatedCodeIntelEvents method of the parent MockEventLogStore instance
// is invoked and the hook queue is empty.
func (f *EventLogStoreAggregatedCodeIntelEventsFunc) SetDefaultHook(hook func(context.Context) ([]types.CodeIntelAggregatedEvent, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// AggregatedCodeIntelEvents method of the parent MockEventLogStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *EventLogStoreAggregatedCodeIntelEventsFunc) PushHook(hook func(context.Context) ([]types.CodeIntelAggregatedEvent, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreAggregatedCodeIntelEventsFunc) SetDefaultReturn(r0 []types.CodeIntelAggregatedEvent, r1 error) {
	f.SetDefaultHook(func(context.Context) ([]types.CodeIntelAggregatedEvent, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreAggregatedCodeIntelEventsFunc) PushReturn(r0 []types.CodeIntelAggregatedEvent, r1 error) {
	f.PushHook(func(context.Context) ([]types.CodeIntelAggregatedEvent, error) {
		return r0, r1
	})
}

func (f *EventLogStoreAggregatedCodeIntelEventsFunc) nextHook() func(context.Context) ([]types.CodeIntelAggregatedEvent, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreAggregatedCodeIntelEventsFunc) appendCall(r0 EventLogStoreAggregatedCodeIntelEventsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EventLogStoreAggregatedCodeIntelEventsFuncCall objects describing the
// invocations of this function.
func (f *EventLogStoreAggregatedCodeIntelEventsFunc) History() []EventLogStoreAggregatedCodeIntelEventsFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreAggregatedCodeIntelEventsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreAggregatedCodeIntelEventsFuncCall is an object that
// describes an invocation of method AggregatedCodeIntelEvents on an
// instance of MockEventLogStore.
type EventLogStoreAggregatedCodeIntelEventsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types.CodeIntelAggregatedEvent
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreAggregatedCodeIntelEventsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreAggregatedCodeIntelEventsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreAggregatedSearchEventsFunc describes the behavior when the
// AggregatedSearchEvents method of the parent MockEventLogStore instance is
// invoked.
type EventLogStoreAggregatedSearchEventsFunc struct {
	defaultHook func(context.Context, time.Time) ([]types.SearchAggregatedEvent, error)
	hooks       []func(context.Context, time.Time) ([]types.SearchAggregatedEvent, error)
	history     []EventLogStoreAggregatedSearchEventsFuncCall
	mutex       sync.Mutex
}

// AggregatedSearchEvents delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockEventLogStore) AggregatedSearchEvents(v0 context.Context, v1 time.Time) ([]types.SearchAggregatedEvent, error) {
	r0, r1 := m.AggregatedSearchEventsFunc.nextHook()(v0, v1)
	m.AggregatedSearchEventsFunc.appendCall(EventLogStoreAggregatedSearchEventsFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// AggregatedSearchEvents method of the parent MockEventLogStore instance is
// invoked and the hook queue is empty.
func (f *EventLogStoreAggregatedSearchEventsFunc) SetDefaultHook(hook func(context.Context, time.Time) ([]types.SearchAggregatedEvent, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// AggregatedSearchEvents method of the parent MockEventLogStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *EventLogStoreAggregatedSearchEventsFunc) PushHook(hook func(context.Context, time.Time) ([]types.SearchAggregatedEvent, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreAggregatedSearchEventsFunc) SetDefaultReturn(r0 []types.SearchAggregatedEvent, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Time) ([]types.SearchAggregatedEvent, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreAggregatedSearchEventsFunc) PushReturn(r0 []types.SearchAggregatedEvent, r1 error) {
	f.PushHook(func(context.Context, time.Time) ([]types.SearchAggregatedEvent, error) {
		return r0, r1
	})
}

func (f *EventLogStoreAggregatedSearchEventsFunc) nextHook() func(context.Context, time.Time) ([]types.SearchAggregatedEvent, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreAggregatedSearchEventsFunc) appendCall(r0 EventLogStoreAggregatedSearchEventsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EventLogStoreAggregatedSearchEventsFuncCall
// objects describing the invocations of this function.
func (f *EventLogStoreAggregatedSearchEventsFunc) History() []EventLogStoreAggregatedSearchEventsFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreAggregatedSearchEventsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreAggregatedSearchEventsFuncCall is an object that describes
// an invocation of method AggregatedSearchEvents on an instance of
// MockEventLogStore.
type EventLogStoreAggregatedSearchEventsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types.SearchAggregatedEvent
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreAggregatedSearchEventsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreAggregatedSearchEventsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreBulkInsertFunc describes the behavior when the BulkInsert
// method of the parent MockEventLogStore instance is invoked.
type EventLogStoreBulkInsertFunc struct {
	defaultHook func(context.Context, []*database.Event) error
	hooks       []func(context.Context, []*database.Event) error
	history     []EventLogStoreBulkInsertFuncCall
	mutex       sync.Mutex
}

// BulkInsert delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockEventLogStore) BulkInsert(v0 context.Context, v1 []*database.Event) error {
	r0 := m.BulkInsertFunc.nextHook()(v0, v1)
	m.BulkInsertFunc.appendCall(EventLogStoreBulkInsertFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the BulkInsert method of
// the parent MockEventLogStore instance is invoked and the hook queue is
// empty.
func (f *EventLogStoreBulkInsertFunc) SetDefaultHook(hook func(context.Context, []*database.Event) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// BulkInsert method of the parent MockEventLogStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *EventLogStoreBulkInsertFunc) PushHook(hook func(context.Context, []*database.Event) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreBulkInsertFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, []*database.Event) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreBulkInsertFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, []*database.Event) error {
		return r0
	})
}

func (f *EventLogStoreBulkInsertFunc) nextHook() func(context.Context, []*database.Event) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreBulkInsertFunc) appendCall(r0 EventLogStoreBulkInsertFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EventLogStoreBulkInsertFuncCall objects
// describing the invocations of this function.
func (f *EventLogStoreBulkInsertFunc) History() []EventLogStoreBulkInsertFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreBulkInsertFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreBulkInsertFuncCall is an object that describes an invocation
// of method BulkInsert on an instance of MockEventLogStore.
type EventLogStoreBulkInsertFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []*database.Event
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreBulkInsertFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreBulkInsertFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// EventLogStoreCodeIntelligenceCrossRepositoryWAUsFunc describes the
// behavior when the CodeIntelligenceCrossRepositoryWAUs method of the
// parent MockEventLogStore instance is invoked.
type EventLogStoreCodeIntelligenceCrossRepositoryWAUsFunc struct {
	defaultHook func(context.Context) (int, error)
	hooks       []func(context.Context) (int, error)
	history     []EventLogStoreCodeIntelligenceCrossRepositoryWAUsFuncCall
	mutex       sync.Mutex
}

// CodeIntelligenceCrossRepositoryWAUs delegates to the next hook function
// in the queue and stores the parameter and result values of this
// invocation.
func (m *MockEventLogStore) CodeIntelligenceCrossRepositoryWAUs(v0 context.Context) (int, error) {
	r0, r1 := m.CodeIntelligenceCrossRepositoryWAUsFunc.nextHook()(v0)
	m.CodeIntelligenceCrossRepositoryWAUsFunc.appendCall(EventLogStoreCodeIntelligenceCrossRepositoryWAUsFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CodeIntelligenceCrossRepositoryWAUs method of the parent
// MockEventLogStore instance is invoked and the hook queue is empty.
func (f *EventLogStoreCodeIntelligenceCrossRepositoryWAUsFunc) SetDefaultHook(hook func(context.Context) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CodeIntelligenceCrossRepositoryWAUs method of the parent
// MockEventLogStore instance invokes the hook at the front of the queue and
// discards it. After the queue is empty, the default hook function is
// invoked for any future action.
func (f *EventLogStoreCodeIntelligenceCrossRepositoryWAUsFunc) PushHook(hook func(context.Context) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCodeIntelligenceCrossRepositoryWAUsFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCodeIntelligenceCrossRepositoryWAUsFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCodeIntelligenceCrossRepositoryWAUsFunc) nextHook() func(context.Context) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCodeIntelligenceCrossRepositoryWAUsFunc) appendCall(r0 EventLogStoreCodeIntelligenceCrossRepositoryWAUsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EventLogStoreCodeIntelligenceCrossRepositoryWAUsFuncCall objects
// describing the invocations of this function.
func (f *EventLogStoreCodeIntelligenceCrossRepositoryWAUsFunc) History() []EventLogStoreCodeIntelligenceCrossRepositoryWAUsFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCodeIntelligenceCrossRepositoryWAUsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCodeIntelligenceCrossRepositoryWAUsFuncCall is an object
// that describes an invocation of method
// CodeIntelligenceCrossRepositoryWAUs on an instance of MockEventLogStore.
type EventLogStoreCodeIntelligenceCrossRepositoryWAUsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCodeIntelligenceCrossRepositoryWAUsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCodeIntelligenceCrossRepositoryWAUsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFunc describes the
// behavior when the CodeIntelligencePreciseCrossRepositoryWAUs method of
// the parent MockEventLogStore instance is invoked.
type EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFunc struct {
	defaultHook func(context.Context) (int, error)
	hooks       []func(context.Context) (int, error)
	history     []EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFuncCall
	mutex       sync.Mutex
}

// CodeIntelligencePreciseCrossRepositoryWAUs delegates to the next hook
// function in the queue and stores the parameter and result values of this
// invocation.
func (m *MockEventLogStore) CodeIntelligencePreciseCrossRepositoryWAUs(v0 context.Context) (int, error) {
	r0, r1 := m.CodeIntelligencePreciseCrossRepositoryWAUsFunc.nextHook()(v0)
	m.CodeIntelligencePreciseCrossRepositoryWAUsFunc.appendCall(EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CodeIntelligencePreciseCrossRepositoryWAUs method of the parent
// MockEventLogStore instance is invoked and the hook queue is empty.
func (f *EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFunc) SetDefaultHook(hook func(context.Context) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CodeIntelligencePreciseCrossRepositoryWAUs method of the parent
// MockEventLogStore instance invokes the hook at the front of the queue and
// discards it. After the queue is empty, the default hook function is
// invoked for any future action.
func (f *EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFunc) PushHook(hook func(context.Context) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFunc) nextHook() func(context.Context) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFunc) appendCall(r0 EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFuncCall objects
// describing the invocations of this function.
func (f *EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFunc) History() []EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFuncCall is an
// object that describes an invocation of method
// CodeIntelligencePreciseCrossRepositoryWAUs on an instance of
// MockEventLogStore.
type EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCodeIntelligencePreciseCrossRepositoryWAUsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreCodeIntelligencePreciseWAUsFunc describes the behavior when
// the CodeIntelligencePreciseWAUs method of the parent MockEventLogStore
// instance is invoked.
type EventLogStoreCodeIntelligencePreciseWAUsFunc struct {
	defaultHook func(context.Context) (int, error)
	hooks       []func(context.Context) (int, error)
	history     []EventLogStoreCodeIntelligencePreciseWAUsFuncCall
	mutex       sync.Mutex
}

// CodeIntelligencePreciseWAUs delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockEventLogStore) CodeIntelligencePreciseWAUs(v0 context.Context) (int, error) {
	r0, r1 := m.CodeIntelligencePreciseWAUsFunc.nextHook()(v0)
	m.CodeIntelligencePreciseWAUsFunc.appendCall(EventLogStoreCodeIntelligencePreciseWAUsFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CodeIntelligencePreciseWAUs method of the parent MockEventLogStore
// instance is invoked and the hook queue is empty.
func (f *EventLogStoreCodeIntelligencePreciseWAUsFunc) SetDefaultHook(hook func(context.Context) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CodeIntelligencePreciseWAUs method of the parent MockEventLogStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *EventLogStoreCodeIntelligencePreciseWAUsFunc) PushHook(hook func(context.Context) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCodeIntelligencePreciseWAUsFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCodeIntelligencePreciseWAUsFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCodeIntelligencePreciseWAUsFunc) nextHook() func(context.Context) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCodeIntelligencePreciseWAUsFunc) appendCall(r0 EventLogStoreCodeIntelligencePreciseWAUsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EventLogStoreCodeIntelligencePreciseWAUsFuncCall objects describing the
// invocations of this function.
func (f *EventLogStoreCodeIntelligencePreciseWAUsFunc) History() []EventLogStoreCodeIntelligencePreciseWAUsFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCodeIntelligencePreciseWAUsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCodeIntelligencePreciseWAUsFuncCall is an object that
// describes an invocation of method CodeIntelligencePreciseWAUs on an
// instance of MockEventLogStore.
type EventLogStoreCodeIntelligencePreciseWAUsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCodeIntelligencePreciseWAUsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCodeIntelligencePreciseWAUsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreCodeIntelligenceRepositoryCountsFunc describes the behavior
// when the CodeIntelligenceRepositoryCounts method of the parent
// MockEventLogStore instance is invoked.
type EventLogStoreCodeIntelligenceRepositoryCountsFunc struct {
	defaultHook func(context.Context) (database.CodeIntelligenceRepositoryCounts, error)
	hooks       []func(context.Context) (database.CodeIntelligenceRepositoryCounts, error)
	history     []EventLogStoreCodeIntelligenceRepositoryCountsFuncCall
	mutex       sync.Mutex
}

// CodeIntelligenceRepositoryCounts delegates to the next hook function in
// the queue and stores the parameter and result values of this invocation.
func (m *MockEventLogStore) CodeIntelligenceRepositoryCounts(v0 context.Context) (database.CodeIntelligenceRepositoryCounts, error) {
	r0, r1 := m.CodeIntelligenceRepositoryCountsFunc.nextHook()(v0)
	m.CodeIntelligenceRepositoryCountsFunc.appendCall(EventLogStoreCodeIntelligenceRepositoryCountsFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CodeIntelligenceRepositoryCounts method of the parent MockEventLogStore
// instance is invoked and the hook queue is empty.
func (f *EventLogStoreCodeIntelligenceRepositoryCountsFunc) SetDefaultHook(hook func(context.Context) (database.CodeIntelligenceRepositoryCounts, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CodeIntelligenceRepositoryCounts method of the parent MockEventLogStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *EventLogStoreCodeIntelligenceRepositoryCountsFunc) PushHook(hook func(context.Context) (database.CodeIntelligenceRepositoryCounts, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCodeIntelligenceRepositoryCountsFunc) SetDefaultReturn(r0 database.CodeIntelligenceRepositoryCounts, r1 error) {
	f.SetDefaultHook(func(context.Context) (database.CodeIntelligenceRepositoryCounts, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCodeIntelligenceRepositoryCountsFunc) PushReturn(r0 database.CodeIntelligenceRepositoryCounts, r1 error) {
	f.PushHook(func(context.Context) (database.CodeIntelligenceRepositoryCounts, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCodeIntelligenceRepositoryCountsFunc) nextHook() func(context.Context) (database.CodeIntelligenceRepositoryCounts, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCodeIntelligenceRepositoryCountsFunc) appendCall(r0 EventLogStoreCodeIntelligenceRepositoryCountsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EventLogStoreCodeIntelligenceRepositoryCountsFuncCall objects describing
// the invocations of this function.
func (f *EventLogStoreCodeIntelligenceRepositoryCountsFunc) History() []EventLogStoreCodeIntelligenceRepositoryCountsFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCodeIntelligenceRepositoryCountsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCodeIntelligenceRepositoryCountsFuncCall is an object that
// describes an invocation of method CodeIntelligenceRepositoryCounts on an
// instance of MockEventLogStore.
type EventLogStoreCodeIntelligenceRepositoryCountsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 database.CodeIntelligenceRepositoryCounts
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCodeIntelligenceRepositoryCountsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCodeIntelligenceRepositoryCountsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFunc describes the
// behavior when the CodeIntelligenceRepositoryCountsByLanguage method of
// the parent MockEventLogStore instance is invoked.
type EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFunc struct {
	defaultHook func(context.Context) (map[string]database.CodeIntelligenceRepositoryCountsForLanguage, error)
	hooks       []func(context.Context) (map[string]database.CodeIntelligenceRepositoryCountsForLanguage, error)
	history     []EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFuncCall
	mutex       sync.Mutex
}

// CodeIntelligenceRepositoryCountsByLanguage delegates to the next hook
// function in the queue and stores the parameter and result values of this
// invocation.
func (m *MockEventLogStore) CodeIntelligenceRepositoryCountsByLanguage(v0 context.Context) (map[string]database.CodeIntelligenceRepositoryCountsForLanguage, error) {
	r0, r1 := m.CodeIntelligenceRepositoryCountsByLanguageFunc.nextHook()(v0)
	m.CodeIntelligenceRepositoryCountsByLanguageFunc.appendCall(EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CodeIntelligenceRepositoryCountsByLanguage method of the parent
// MockEventLogStore instance is invoked and the hook queue is empty.
func (f *EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFunc) SetDefaultHook(hook func(context.Context) (map[string]database.CodeIntelligenceRepositoryCountsForLanguage, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CodeIntelligenceRepositoryCountsByLanguage method of the parent
// MockEventLogStore instance invokes the hook at the front of the queue and
// discards it. After the queue is empty, the default hook function is
// invoked for any future action.
func (f *EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFunc) PushHook(hook func(context.Context) (map[string]database.CodeIntelligenceRepositoryCountsForLanguage, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFunc) SetDefaultReturn(r0 map[string]database.CodeIntelligenceRepositoryCountsForLanguage, r1 error) {
	f.SetDefaultHook(func(context.Context) (map[string]database.CodeIntelligenceRepositoryCountsForLanguage, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFunc) PushReturn(r0 map[string]database.CodeIntelligenceRepositoryCountsForLanguage, r1 error) {
	f.PushHook(func(context.Context) (map[string]database.CodeIntelligenceRepositoryCountsForLanguage, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFunc) nextHook() func(context.Context) (map[string]database.CodeIntelligenceRepositoryCountsForLanguage, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFunc) appendCall(r0 EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFuncCall objects
// describing the invocations of this function.
func (f *EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFunc) History() []EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFuncCall is an
// object that describes an invocation of method
// CodeIntelligenceRepositoryCountsByLanguage on an instance of
// MockEventLogStore.
type EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[string]database.CodeIntelligenceRepositoryCountsForLanguage
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCodeIntelligenceRepositoryCountsByLanguageFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFunc describes
// the behavior when the CodeIntelligenceSearchBasedCrossRepositoryWAUs
// method of the parent MockEventLogStore instance is invoked.
type EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFunc struct {
	defaultHook func(context.Context) (int, error)
	hooks       []func(context.Context) (int, error)
	history     []EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFuncCall
	mutex       sync.Mutex
}

// CodeIntelligenceSearchBasedCrossRepositoryWAUs delegates to the next hook
// function in the queue and stores the parameter and result values of this
// invocation.
func (m *MockEventLogStore) CodeIntelligenceSearchBasedCrossRepositoryWAUs(v0 context.Context) (int, error) {
	r0, r1 := m.CodeIntelligenceSearchBasedCrossRepositoryWAUsFunc.nextHook()(v0)
	m.CodeIntelligenceSearchBasedCrossRepositoryWAUsFunc.appendCall(EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CodeIntelligenceSearchBasedCrossRepositoryWAUs method of the parent
// MockEventLogStore instance is invoked and the hook queue is empty.
func (f *EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFunc) SetDefaultHook(hook func(context.Context) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CodeIntelligenceSearchBasedCrossRepositoryWAUs method of the parent
// MockEventLogStore instance invokes the hook at the front of the queue and
// discards it. After the queue is empty, the default hook function is
// invoked for any future action.
func (f *EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFunc) PushHook(hook func(context.Context) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFunc) nextHook() func(context.Context) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFunc) appendCall(r0 EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFuncCall
// objects describing the invocations of this function.
func (f *EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFunc) History() []EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFuncCall is an
// object that describes an invocation of method
// CodeIntelligenceSearchBasedCrossRepositoryWAUs on an instance of
// MockEventLogStore.
type EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCodeIntelligenceSearchBasedCrossRepositoryWAUsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreCodeIntelligenceSearchBasedWAUsFunc describes the behavior
// when the CodeIntelligenceSearchBasedWAUs method of the parent
// MockEventLogStore instance is invoked.
type EventLogStoreCodeIntelligenceSearchBasedWAUsFunc struct {
	defaultHook func(context.Context) (int, error)
	hooks       []func(context.Context) (int, error)
	history     []EventLogStoreCodeIntelligenceSearchBasedWAUsFuncCall
	mutex       sync.Mutex
}

// CodeIntelligenceSearchBasedWAUs delegates to the next hook function in
// the queue and stores the parameter and result values of this invocation.
func (m *MockEventLogStore) CodeIntelligenceSearchBasedWAUs(v0 context.Context) (int, error) {
	r0, r1 := m.CodeIntelligenceSearchBasedWAUsFunc.nextHook()(v0)
	m.CodeIntelligenceSearchBasedWAUsFunc.appendCall(EventLogStoreCodeIntelligenceSearchBasedWAUsFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CodeIntelligenceSearchBasedWAUs method of the parent MockEventLogStore
// instance is invoked and the hook queue is empty.
func (f *EventLogStoreCodeIntelligenceSearchBasedWAUsFunc) SetDefaultHook(hook func(context.Context) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CodeIntelligenceSearchBasedWAUs method of the parent MockEventLogStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *EventLogStoreCodeIntelligenceSearchBasedWAUsFunc) PushHook(hook func(context.Context) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCodeIntelligenceSearchBasedWAUsFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCodeIntelligenceSearchBasedWAUsFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCodeIntelligenceSearchBasedWAUsFunc) nextHook() func(context.Context) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCodeIntelligenceSearchBasedWAUsFunc) appendCall(r0 EventLogStoreCodeIntelligenceSearchBasedWAUsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EventLogStoreCodeIntelligenceSearchBasedWAUsFuncCall objects describing
// the invocations of this function.
func (f *EventLogStoreCodeIntelligenceSearchBasedWAUsFunc) History() []EventLogStoreCodeIntelligenceSearchBasedWAUsFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCodeIntelligenceSearchBasedWAUsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCodeIntelligenceSearchBasedWAUsFuncCall is an object that
// describes an invocation of method CodeIntelligenceSearchBasedWAUs on an
// instance of MockEventLogStore.
type EventLogStoreCodeIntelligenceSearchBasedWAUsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCodeIntelligenceSearchBasedWAUsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCodeIntelligenceSearchBasedWAUsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreCodeIntelligenceSettingsPageViewCountFunc describes the
// behavior when the CodeIntelligenceSettingsPageViewCount method of the
// parent MockEventLogStore instance is invoked.
type EventLogStoreCodeIntelligenceSettingsPageViewCountFunc struct {
	defaultHook func(context.Context) (int, error)
	hooks       []func(context.Context) (int, error)
	history     []EventLogStoreCodeIntelligenceSettingsPageViewCountFuncCall
	mutex       sync.Mutex
}

// CodeIntelligenceSettingsPageViewCount delegates to the next hook function
// in the queue and stores the parameter and result values of this
// invocation.
func (m *MockEventLogStore) CodeIntelligenceSettingsPageViewCount(v0 context.Context) (int, error) {
	r0, r1 := m.CodeIntelligenceSettingsPageViewCountFunc.nextHook()(v0)
	m.CodeIntelligenceSettingsPageViewCountFunc.appendCall(EventLogStoreCodeIntelligenceSettingsPageViewCountFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CodeIntelligenceSettingsPageViewCount method of the parent
// MockEventLogStore instance is invoked and the hook queue is empty.
func (f *EventLogStoreCodeIntelligenceSettingsPageViewCountFunc) SetDefaultHook(hook func(context.Context) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CodeIntelligenceSettingsPageViewCount method of the parent
// MockEventLogStore instance invokes the hook at the front of the queue and
// discards it. After the queue is empty, the default hook function is
// invoked for any future action.
func (f *EventLogStoreCodeIntelligenceSettingsPageViewCountFunc) PushHook(hook func(context.Context) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCodeIntelligenceSettingsPageViewCountFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCodeIntelligenceSettingsPageViewCountFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCodeIntelligenceSettingsPageViewCountFunc) nextHook() func(context.Context) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCodeIntelligenceSettingsPageViewCountFunc) appendCall(r0 EventLogStoreCodeIntelligenceSettingsPageViewCountFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EventLogStoreCodeIntelligenceSettingsPageViewCountFuncCall objects
// describing the invocations of this function.
func (f *EventLogStoreCodeIntelligenceSettingsPageViewCountFunc) History() []EventLogStoreCodeIntelligenceSettingsPageViewCountFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCodeIntelligenceSettingsPageViewCountFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCodeIntelligenceSettingsPageViewCountFuncCall is an object
// that describes an invocation of method
// CodeIntelligenceSettingsPageViewCount on an instance of
// MockEventLogStore.
type EventLogStoreCodeIntelligenceSettingsPageViewCountFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCodeIntelligenceSettingsPageViewCountFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCodeIntelligenceSettingsPageViewCountFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreCodeIntelligenceWAUsFunc describes the behavior when the
// CodeIntelligenceWAUs method of the parent MockEventLogStore instance is
// invoked.
type EventLogStoreCodeIntelligenceWAUsFunc struct {
	defaultHook func(context.Context) (int, error)
	hooks       []func(context.Context) (int, error)
	history     []EventLogStoreCodeIntelligenceWAUsFuncCall
	mutex       sync.Mutex
}

// CodeIntelligenceWAUs delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockEventLogStore) CodeIntelligenceWAUs(v0 context.Context) (int, error) {
	r0, r1 := m.CodeIntelligenceWAUsFunc.nextHook()(v0)
	m.CodeIntelligenceWAUsFunc.appendCall(EventLogStoreCodeIntelligenceWAUsFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the CodeIntelligenceWAUs
// method of the parent MockEventLogStore instance is invoked and the hook
// queue is empty.
func (f *EventLogStoreCodeIntelligenceWAUsFunc) SetDefaultHook(hook func(context.Context) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CodeIntelligenceWAUs method of the parent MockEventLogStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *EventLogStoreCodeIntelligenceWAUsFunc) PushHook(hook func(context.Context) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCodeIntelligenceWAUsFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCodeIntelligenceWAUsFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCodeIntelligenceWAUsFunc) nextHook() func(context.Context) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCodeIntelligenceWAUsFunc) appendCall(r0 EventLogStoreCodeIntelligenceWAUsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EventLogStoreCodeIntelligenceWAUsFuncCall
// objects describing the invocations of this function.
func (f *EventLogStoreCodeIntelligenceWAUsFunc) History() []EventLogStoreCodeIntelligenceWAUsFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCodeIntelligenceWAUsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCodeIntelligenceWAUsFuncCall is an object that describes an
// invocation of method CodeIntelligenceWAUs on an instance of
// MockEventLogStore.
type EventLogStoreCodeIntelligenceWAUsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCodeIntelligenceWAUsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCodeIntelligenceWAUsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreCountByUserIDFunc describes the behavior when the
// CountByUserID method of the parent MockEventLogStore instance is invoked.
type EventLogStoreCountByUserIDFunc struct {
	defaultHook func(context.Context, int32) (int, error)
	hooks       []func(context.Context, int32) (int, error)
	history     []EventLogStoreCountByUserIDFuncCall
	mutex       sync.Mutex
}

// CountByUserID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockEventLogStore) CountByUserID(v0 context.Context, v1 int32) (int, error) {
	r0, r1 := m.CountByUserIDFunc.nextHook()(v0, v1)
	m.CountByUserIDFunc.appendCall(EventLogStoreCountByUserIDFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the CountByUserID method
// of the parent MockEventLogStore instance is invoked and the hook queue is
// empty.
func (f *EventLogStoreCountByUserIDFunc) SetDefaultHook(hook func(context.Context, int32) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CountByUserID method of the parent MockEventLogStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *EventLogStoreCountByUserIDFunc) PushHook(hook func(context.Context, int32) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCountByUserIDFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int32) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCountByUserIDFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int32) (int, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCountByUserIDFunc) nextHook() func(context.Context, int32) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCountByUserIDFunc) appendCall(r0 EventLogStoreCountByUserIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EventLogStoreCountByUserIDFuncCall objects
// describing the invocations of this function.
func (f *EventLogStoreCountByUserIDFunc) History() []EventLogStoreCountByUserIDFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCountByUserIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCountByUserIDFuncCall is an object that describes an
// invocation of method CountByUserID on an instance of MockEventLogStore.
type EventLogStoreCountByUserIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int32
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCountByUserIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCountByUserIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreCountByUserIDAndEventNameFunc describes the behavior when
// the CountByUserIDAndEventName method of the parent MockEventLogStore
// instance is invoked.
type EventLogStoreCountByUserIDAndEventNameFunc struct {
	defaultHook func(context.Context, int32, string) (int, error)
	hooks       []func(context.Context, int32, string) (int, error)
	history     []EventLogStoreCountByUserIDAndEventNameFuncCall
	mutex       sync.Mutex
}

// CountByUserIDAndEventName delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockEventLogStore) CountByUserIDAndEventName(v0 context.Context, v1 int32, v2 string) (int, error) {
	r0, r1 := m.CountByUserIDAndEventNameFunc.nextHook()(v0, v1, v2)
	m.CountByUserIDAndEventNameFunc.appendCall(EventLogStoreCountByUserIDAndEventNameFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CountByUserIDAndEventName method of the parent MockEventLogStore instance
// is invoked and the hook queue is empty.
func (f *EventLogStoreCountByUserIDAndEventNameFunc) SetDefaultHook(hook func(context.Context, int32, string) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CountByUserIDAndEventName method of the parent MockEventLogStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *EventLogStoreCountByUserIDAndEventNameFunc) PushHook(hook func(context.Context, int32, string) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCountByUserIDAndEventNameFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int32, string) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCountByUserIDAndEventNameFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int32, string) (int, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCountByUserIDAndEventNameFunc) nextHook() func(context.Context, int32, string) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCountByUserIDAndEventNameFunc) appendCall(r0 EventLogStoreCountByUserIDAndEventNameFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EventLogStoreCountByUserIDAndEventNameFuncCall objects describing the
// invocations of this function.
func (f *EventLogStoreCountByUserIDAndEventNameFunc) History() []EventLogStoreCountByUserIDAndEventNameFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCountByUserIDAndEventNameFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCountByUserIDAndEventNameFuncCall is an object that
// describes an invocation of method CountByUserIDAndEventName on an
// instance of MockEventLogStore.
type EventLogStoreCountByUserIDAndEventNameFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int32
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCountByUserIDAndEventNameFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCountByUserIDAndEventNameFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreCountByUserIDAndEventNamePrefixFunc describes the behavior
// when the CountByUserIDAndEventNamePrefix method of the parent
// MockEventLogStore instance is invoked.
type EventLogStoreCountByUserIDAndEventNamePrefixFunc struct {
	defaultHook func(context.Context, int32, string) (int, error)
	hooks       []func(context.Context, int32, string) (int, error)
	history     []EventLogStoreCountByUserIDAndEventNamePrefixFuncCall
	mutex       sync.Mutex
}

// CountByUserIDAndEventNamePrefix delegates to the next hook function in
// the queue and stores the parameter and result values of this invocation.
func (m *MockEventLogStore) CountByUserIDAndEventNamePrefix(v0 context.Context, v1 int32, v2 string) (int, error) {
	r0, r1 := m.CountByUserIDAndEventNamePrefixFunc.nextHook()(v0, v1, v2)
	m.CountByUserIDAndEventNamePrefixFunc.appendCall(EventLogStoreCountByUserIDAndEventNamePrefixFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CountByUserIDAndEventNamePrefix method of the parent MockEventLogStore
// instance is invoked and the hook queue is empty.
func (f *EventLogStoreCountByUserIDAndEventNamePrefixFunc) SetDefaultHook(hook func(context.Context, int32, string) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CountByUserIDAndEventNamePrefix method of the parent MockEventLogStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *EventLogStoreCountByUserIDAndEventNamePrefixFunc) PushHook(hook func(context.Context, int32, string) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCountByUserIDAndEventNamePrefixFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int32, string) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCountByUserIDAndEventNamePrefixFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int32, string) (int, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCountByUserIDAndEventNamePrefixFunc) nextHook() func(context.Context, int32, string) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCountByUserIDAndEventNamePrefixFunc) appendCall(r0 EventLogStoreCountByUserIDAndEventNamePrefixFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EventLogStoreCountByUserIDAndEventNamePrefixFuncCall objects describing
// the invocations of this function.
func (f *EventLogStoreCountByUserIDAndEventNamePrefixFunc) History() []EventLogStoreCountByUserIDAndEventNamePrefixFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCountByUserIDAndEventNamePrefixFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCountByUserIDAndEventNamePrefixFuncCall is an object that
// describes an invocation of method CountByUserIDAndEventNamePrefix on an
// instance of MockEventLogStore.
type EventLogStoreCountByUserIDAndEventNamePrefixFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int32
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCountByUserIDAndEventNamePrefixFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCountByUserIDAndEventNamePrefixFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreCountByUserIDAndEventNamesFunc describes the behavior when
// the CountByUserIDAndEventNames method of the parent MockEventLogStore
// instance is invoked.
type EventLogStoreCountByUserIDAndEventNamesFunc struct {
	defaultHook func(context.Context, int32, []string) (int, error)
	hooks       []func(context.Context, int32, []string) (int, error)
	history     []EventLogStoreCountByUserIDAndEventNamesFuncCall
	mutex       sync.Mutex
}

// CountByUserIDAndEventNames delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockEventLogStore) CountByUserIDAndEventNames(v0 context.Context, v1 int32, v2 []string) (int, error) {
	r0, r1 := m.CountByUserIDAndEventNamesFunc.nextHook()(v0, v1, v2)
	m.CountByUserIDAndEventNamesFunc.appendCall(EventLogStoreCountByUserIDAndEventNamesFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CountByUserIDAndEventNames method of the parent MockEventLogStore
// instance is invoked and the hook queue is empty.
func (f *EventLogStoreCountByUserIDAndEventNamesFunc) SetDefaultHook(hook func(context.Context, int32, []string) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CountByUserIDAndEventNames method of the parent MockEventLogStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *EventLogStoreCountByUserIDAndEventNamesFunc) PushHook(hook func(context.Context, int32, []string) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCountByUserIDAndEventNamesFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int32, []string) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCountByUserIDAndEventNamesFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int32, []string) (int, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCountByUserIDAndEventNamesFunc) nextHook() func(context.Context, int32, []string) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCountByUserIDAndEventNamesFunc) appendCall(r0 EventLogStoreCountByUserIDAndEventNamesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EventLogStoreCountByUserIDAndEventNamesFuncCall objects describing the
// invocations of this function.
func (f *EventLogStoreCountByUserIDAndEventNamesFunc) History() []EventLogStoreCountByUserIDAndEventNamesFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCountByUserIDAndEventNamesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCountByUserIDAndEventNamesFuncCall is an object that
// describes an invocation of method CountByUserIDAndEventNames on an
// instance of MockEventLogStore.
type EventLogStoreCountByUserIDAndEventNamesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int32
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCountByUserIDAndEventNamesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCountByUserIDAndEventNamesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreCountUniqueUsersAllFunc describes the behavior when the
// CountUniqueUsersAll method of the parent MockEventLogStore instance is
// invoked.
type EventLogStoreCountUniqueUsersAllFunc struct {
	defaultHook func(context.Context, time.Time, time.Time) (int, error)
	hooks       []func(context.Context, time.Time, time.Time) (int, error)
	history     []EventLogStoreCountUniqueUsersAllFuncCall
	mutex       sync.Mutex
}

// CountUniqueUsersAll delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockEventLogStore) CountUniqueUsersAll(v0 context.Context, v1 time.Time, v2 time.Time) (int, error) {
	r0, r1 := m.CountUniqueUsersAllFunc.nextHook()(v0, v1, v2)
	m.CountUniqueUsersAllFunc.appendCall(EventLogStoreCountUniqueUsersAllFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the CountUniqueUsersAll
// method of the parent MockEventLogStore instance is invoked and the hook
// queue is empty.
func (f *EventLogStoreCountUniqueUsersAllFunc) SetDefaultHook(hook func(context.Context, time.Time, time.Time) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CountUniqueUsersAll method of the parent MockEventLogStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *EventLogStoreCountUniqueUsersAllFunc) PushHook(hook func(context.Context, time.Time, time.Time) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCountUniqueUsersAllFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Time, time.Time) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCountUniqueUsersAllFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, time.Time, time.Time) (int, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCountUniqueUsersAllFunc) nextHook() func(context.Context, time.Time, time.Time) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCountUniqueUsersAllFunc) appendCall(r0 EventLogStoreCountUniqueUsersAllFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EventLogStoreCountUniqueUsersAllFuncCall
// objects describing the invocations of this function.
func (f *EventLogStoreCountUniqueUsersAllFunc) History() []EventLogStoreCountUniqueUsersAllFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCountUniqueUsersAllFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCountUniqueUsersAllFuncCall is an object that describes an
// invocation of method CountUniqueUsersAll on an instance of
// MockEventLogStore.
type EventLogStoreCountUniqueUsersAllFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Time
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCountUniqueUsersAllFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCountUniqueUsersAllFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreCountUniqueUsersByEventNameFunc describes the behavior when
// the CountUniqueUsersByEventName method of the parent MockEventLogStore
// instance is invoked.
type EventLogStoreCountUniqueUsersByEventNameFunc struct {
	defaultHook func(context.Context, time.Time, time.Time, string) (int, error)
	hooks       []func(context.Context, time.Time, time.Time, string) (int, error)
	history     []EventLogStoreCountUniqueUsersByEventNameFuncCall
	mutex       sync.Mutex
}

// CountUniqueUsersByEventName delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockEventLogStore) CountUniqueUsersByEventName(v0 context.Context, v1 time.Time, v2 time.Time, v3 string) (int, error) {
	r0, r1 := m.CountUniqueUsersByEventNameFunc.nextHook()(v0, v1, v2, v3)
	m.CountUniqueUsersByEventNameFunc.appendCall(EventLogStoreCountUniqueUsersByEventNameFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CountUniqueUsersByEventName method of the parent MockEventLogStore
// instance is invoked and the hook queue is empty.
func (f *EventLogStoreCountUniqueUsersByEventNameFunc) SetDefaultHook(hook func(context.Context, time.Time, time.Time, string) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CountUniqueUsersByEventName method of the parent MockEventLogStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *EventLogStoreCountUniqueUsersByEventNameFunc) PushHook(hook func(context.Context, time.Time, time.Time, string) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCountUniqueUsersByEventNameFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Time, time.Time, string) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCountUniqueUsersByEventNameFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, time.Time, time.Time, string) (int, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCountUniqueUsersByEventNameFunc) nextHook() func(context.Context, time.Time, time.Time, string) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCountUniqueUsersByEventNameFunc) appendCall(r0 EventLogStoreCountUniqueUsersByEventNameFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EventLogStoreCountUniqueUsersByEventNameFuncCall objects describing the
// invocations of this function.
func (f *EventLogStoreCountUniqueUsersByEventNameFunc) History() []EventLogStoreCountUniqueUsersByEventNameFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCountUniqueUsersByEventNameFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCountUniqueUsersByEventNameFuncCall is an object that
// describes an invocation of method CountUniqueUsersByEventName on an
// instance of MockEventLogStore.
type EventLogStoreCountUniqueUsersByEventNameFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Time
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCountUniqueUsersByEventNameFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCountUniqueUsersByEventNameFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreCountUniqueUsersByEventNamePrefixFunc describes the behavior
// when the CountUniqueUsersByEventNamePrefix method of the parent
// MockEventLogStore instance is invoked.
type EventLogStoreCountUniqueUsersByEventNamePrefixFunc struct {
	defaultHook func(context.Context, time.Time, time.Time, string) (int, error)
	hooks       []func(context.Context, time.Time, time.Time, string) (int, error)
	history     []EventLogStoreCountUniqueUsersByEventNamePrefixFuncCall
	mutex       sync.Mutex
}

// CountUniqueUsersByEventNamePrefix delegates to the next hook function in
// the queue and stores the parameter and result values of this invocation.
func (m *MockEventLogStore) CountUniqueUsersByEventNamePrefix(v0 context.Context, v1 time.Time, v2 time.Time, v3 string) (int, error) {
	r0, r1 := m.CountUniqueUsersByEventNamePrefixFunc.nextHook()(v0, v1, v2, v3)
	m.CountUniqueUsersByEventNamePrefixFunc.appendCall(EventLogStoreCountUniqueUsersByEventNamePrefixFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CountUniqueUsersByEventNamePrefix method of the parent MockEventLogStore
// instance is invoked and the hook queue is empty.
func (f *EventLogStoreCountUniqueUsersByEventNamePrefixFunc) SetDefaultHook(hook func(context.Context, time.Time, time.Time, string) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CountUniqueUsersByEventNamePrefix method of the parent MockEventLogStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *EventLogStoreCountUniqueUsersByEventNamePrefixFunc) PushHook(hook func(context.Context, time.Time, time.Time, string) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCountUniqueUsersByEventNamePrefixFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Time, time.Time, string) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCountUniqueUsersByEventNamePrefixFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, time.Time, time.Time, string) (int, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCountUniqueUsersByEventNamePrefixFunc) nextHook() func(context.Context, time.Time, time.Time, string) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCountUniqueUsersByEventNamePrefixFunc) appendCall(r0 EventLogStoreCountUniqueUsersByEventNamePrefixFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EventLogStoreCountUniqueUsersByEventNamePrefixFuncCall objects describing
// the invocations of this function.
func (f *EventLogStoreCountUniqueUsersByEventNamePrefixFunc) History() []EventLogStoreCountUniqueUsersByEventNamePrefixFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCountUniqueUsersByEventNamePrefixFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCountUniqueUsersByEventNamePrefixFuncCall is an object that
// describes an invocation of method CountUniqueUsersByEventNamePrefix on an
// instance of MockEventLogStore.
type EventLogStoreCountUniqueUsersByEventNamePrefixFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Time
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCountUniqueUsersByEventNamePrefixFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCountUniqueUsersByEventNamePrefixFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreCountUniqueUsersByEventNamesFunc describes the behavior when
// the CountUniqueUsersByEventNames method of the parent MockEventLogStore
// instance is invoked.
type EventLogStoreCountUniqueUsersByEventNamesFunc struct {
	defaultHook func(context.Context, time.Time, time.Time, []string) (int, error)
	hooks       []func(context.Context, time.Time, time.Time, []string) (int, error)
	history     []EventLogStoreCountUniqueUsersByEventNamesFuncCall
	mutex       sync.Mutex
}

// CountUniqueUsersByEventNames delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockEventLogStore) CountUniqueUsersByEventNames(v0 context.Context, v1 time.Time, v2 time.Time, v3 []string) (int, error) {
	r0, r1 := m.CountUniqueUsersByEventNamesFunc.nextHook()(v0, v1, v2, v3)
	m.CountUniqueUsersByEventNamesFunc.appendCall(EventLogStoreCountUniqueUsersByEventNamesFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CountUniqueUsersByEventNames method of the parent MockEventLogStore
// instance is invoked and the hook queue is empty.
func (f *EventLogStoreCountUniqueUsersByEventNamesFunc) SetDefaultHook(hook func(context.Context, time.Time, time.Time, []string) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CountUniqueUsersByEventNames method of the parent MockEventLogStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *EventLogStoreCountUniqueUsersByEventNamesFunc) PushHook(hook func(context.Context, time.Time, time.Time, []string) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCountUniqueUsersByEventNamesFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Time, time.Time, []string) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCountUniqueUsersByEventNamesFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, time.Time, time.Time, []string) (int, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCountUniqueUsersByEventNamesFunc) nextHook() func(context.Context, time.Time, time.Time, []string) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCountUniqueUsersByEventNamesFunc) appendCall(r0 EventLogStoreCountUniqueUsersByEventNamesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EventLogStoreCountUniqueUsersByEventNamesFuncCall objects describing the
// invocations of this function.
func (f *EventLogStoreCountUniqueUsersByEventNamesFunc) History() []EventLogStoreCountUniqueUsersByEventNamesFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCountUniqueUsersByEventNamesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCountUniqueUsersByEventNamesFuncCall is an object that
// describes an invocation of method CountUniqueUsersByEventNames on an
// instance of MockEventLogStore.
type EventLogStoreCountUniqueUsersByEventNamesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Time
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 []string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCountUniqueUsersByEventNamesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCountUniqueUsersByEventNamesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreCountUniqueUsersPerPeriodFunc describes the behavior when
// the CountUniqueUsersPerPeriod method of the parent MockEventLogStore
// instance is invoked.
type EventLogStoreCountUniqueUsersPerPeriodFunc struct {
	defaultHook func(context.Context, database.PeriodType, time.Time, int, *database.CountUniqueUsersOptions) ([]database.UsageValue, error)
	hooks       []func(context.Context, database.PeriodType, time.Time, int, *database.CountUniqueUsersOptions) ([]database.UsageValue, error)
	history     []EventLogStoreCountUniqueUsersPerPeriodFuncCall
	mutex       sync.Mutex
}

// CountUniqueUsersPerPeriod delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockEventLogStore) CountUniqueUsersPerPeriod(v0 context.Context, v1 database.PeriodType, v2 time.Time, v3 int, v4 *database.CountUniqueUsersOptions) ([]database.UsageValue, error) {
	r0, r1 := m.CountUniqueUsersPerPeriodFunc.nextHook()(v0, v1, v2, v3, v4)
	m.CountUniqueUsersPerPeriodFunc.appendCall(EventLogStoreCountUniqueUsersPerPeriodFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CountUniqueUsersPerPeriod method of the parent MockEventLogStore instance
// is invoked and the hook queue is empty.
func (f *EventLogStoreCountUniqueUsersPerPeriodFunc) SetDefaultHook(hook func(context.Context, database.PeriodType, time.Time, int, *database.CountUniqueUsersOptions) ([]database.UsageValue, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CountUniqueUsersPerPeriod method of the parent MockEventLogStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *EventLogStoreCountUniqueUsersPerPeriodFunc) PushHook(hook func(context.Context, database.PeriodType, time.Time, int, *database.CountUniqueUsersOptions) ([]database.UsageValue, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreCountUniqueUsersPerPeriodFunc) SetDefaultReturn(r0 []database.UsageValue, r1 error) {
	f.SetDefaultHook(func(context.Context, database.PeriodType, time.Time, int, *database.CountUniqueUsersOptions) ([]database.UsageValue, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreCountUniqueUsersPerPeriodFunc) PushReturn(r0 []database.UsageValue, r1 error) {
	f.PushHook(func(context.Context, database.PeriodType, time.Time, int, *database.CountUniqueUsersOptions) ([]database.UsageValue, error) {
		return r0, r1
	})
}

func (f *EventLogStoreCountUniqueUsersPerPeriodFunc) nextHook() func(context.Context, database.PeriodType, time.Time, int, *database.CountUniqueUsersOptions) ([]database.UsageValue, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreCountUniqueUsersPerPeriodFunc) appendCall(r0 EventLogStoreCountUniqueUsersPerPeriodFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EventLogStoreCountUniqueUsersPerPeriodFuncCall objects describing the
// invocations of this function.
func (f *EventLogStoreCountUniqueUsersPerPeriodFunc) History() []EventLogStoreCountUniqueUsersPerPeriodFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreCountUniqueUsersPerPeriodFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreCountUniqueUsersPerPeriodFuncCall is an object that
// describes an invocation of method CountUniqueUsersPerPeriod on an
// instance of MockEventLogStore.
type EventLogStoreCountUniqueUsersPerPeriodFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 database.PeriodType
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 *database.CountUniqueUsersOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []database.UsageValue
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreCountUniqueUsersPerPeriodFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreCountUniqueUsersPerPeriodFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreDoneFunc describes the behavior when the Done method of the
// parent MockEventLogStore instance is invoked.
type EventLogStoreDoneFunc struct {
	defaultHook func(error) error
	hooks       []func(error) error
	history     []EventLogStoreDoneFuncCall
	mutex       sync.Mutex
}

// Done delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockEventLogStore) Done(v0 error) error {
	r0 := m.DoneFunc.nextHook()(v0)
	m.DoneFunc.appendCall(EventLogStoreDoneFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Done method of the
// parent MockEventLogStore instance is invoked and the hook queue is empty.
func (f *EventLogStoreDoneFunc) SetDefaultHook(hook func(error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Done method of the parent MockEventLogStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *EventLogStoreDoneFunc) PushHook(hook func(error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreDoneFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(error) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreDoneFunc) PushReturn(r0 error) {
	f.PushHook(func(error) error {
		return r0
	})
}

func (f *EventLogStoreDoneFunc) nextHook() func(error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreDoneFunc) appendCall(r0 EventLogStoreDoneFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EventLogStoreDoneFuncCall objects
// describing the invocations of this function.
func (f *EventLogStoreDoneFunc) History() []EventLogStoreDoneFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreDoneFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreDoneFuncCall is an object that describes an invocation of
// method Done on an instance of MockEventLogStore.
type EventLogStoreDoneFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreDoneFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreDoneFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// EventLogStoreHandleFunc describes the behavior when the Handle method of
// the parent MockEventLogStore instance is invoked.
type EventLogStoreHandleFunc struct {
	defaultHook func() *basestore.TransactableHandle
	hooks       []func() *basestore.TransactableHandle
	history     []EventLogStoreHandleFuncCall
	mutex       sync.Mutex
}

// Handle delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockEventLogStore) Handle() *basestore.TransactableHandle {
	r0 := m.HandleFunc.nextHook()()
	m.HandleFunc.appendCall(EventLogStoreHandleFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the Handle method of the
// parent MockEventLogStore instance is invoked and the hook queue is empty.
func (f *EventLogStoreHandleFunc) SetDefaultHook(hook func() *basestore.TransactableHandle) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Handle method of the parent MockEventLogStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *EventLogStoreHandleFunc) PushHook(hook func() *basestore.TransactableHandle) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreHandleFunc) SetDefaultReturn(r0 *basestore.TransactableHandle) {
	f.SetDefaultHook(func() *basestore.TransactableHandle {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreHandleFunc) PushReturn(r0 *basestore.TransactableHandle) {
	f.PushHook(func() *basestore.TransactableHandle {
		return r0
	})
}

func (f *EventLogStoreHandleFunc) nextHook() func() *basestore.TransactableHandle {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreHandleFunc) appendCall(r0 EventLogStoreHandleFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EventLogStoreHandleFuncCall objects
// describing the invocations of this function.
func (f *EventLogStoreHandleFunc) History() []EventLogStoreHandleFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreHandleFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreHandleFuncCall is an object that describes an invocation of
// method Handle on an instance of MockEventLogStore.
type EventLogStoreHandleFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *basestore.TransactableHandle
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreHandleFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreHandleFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// EventLogStoreInsertFunc describes the behavior when the Insert method of
// the parent MockEventLogStore instance is invoked.
type EventLogStoreInsertFunc struct {
	defaultHook func(context.Context, *database.Event) error
	hooks       []func(context.Context, *database.Event) error
	history     []EventLogStoreInsertFuncCall
	mutex       sync.Mutex
}

// Insert delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockEventLogStore) Insert(v0 context.Context, v1 *database.Event) error {
	r0 := m.InsertFunc.nextHook()(v0, v1)
	m.InsertFunc.appendCall(EventLogStoreInsertFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Insert method of the
// parent MockEventLogStore instance is invoked and the hook queue is empty.
func (f *EventLogStoreInsertFunc) SetDefaultHook(hook func(context.Context, *database.Event) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Insert method of the parent MockEventLogStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *EventLogStoreInsertFunc) PushHook(hook func(context.Context, *database.Event) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreInsertFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, *database.Event) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreInsertFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, *database.Event) error {
		return r0
	})
}

func (f *EventLogStoreInsertFunc) nextHook() func(context.Context, *database.Event) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreInsertFunc) appendCall(r0 EventLogStoreInsertFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EventLogStoreInsertFuncCall objects
// describing the invocations of this function.
func (f *EventLogStoreInsertFunc) History() []EventLogStoreInsertFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreInsertFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreInsertFuncCall is an object that describes an invocation of
// method Insert on an instance of MockEventLogStore.
type EventLogStoreInsertFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 *database.Event
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreInsertFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreInsertFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// EventLogStoreLatestPingFunc describes the behavior when the LatestPing
// method of the parent MockEventLogStore instance is invoked.
type EventLogStoreLatestPingFunc struct {
	defaultHook func(context.Context) (*types.Event, error)
	hooks       []func(context.Context) (*types.Event, error)
	history     []EventLogStoreLatestPingFuncCall
	mutex       sync.Mutex
}

// LatestPing delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockEventLogStore) LatestPing(v0 context.Context) (*types.Event, error) {
	r0, r1 := m.LatestPingFunc.nextHook()(v0)
	m.LatestPingFunc.appendCall(EventLogStoreLatestPingFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the LatestPing method of
// the parent MockEventLogStore instance is invoked and the hook queue is
// empty.
func (f *EventLogStoreLatestPingFunc) SetDefaultHook(hook func(context.Context) (*types.Event, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// LatestPing method of the parent MockEventLogStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *EventLogStoreLatestPingFunc) PushHook(hook func(context.Context) (*types.Event, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreLatestPingFunc) SetDefaultReturn(r0 *types.Event, r1 error) {
	f.SetDefaultHook(func(context.Context) (*types.Event, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreLatestPingFunc) PushReturn(r0 *types.Event, r1 error) {
	f.PushHook(func(context.Context) (*types.Event, error) {
		return r0, r1
	})
}

func (f *EventLogStoreLatestPingFunc) nextHook() func(context.Context) (*types.Event, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreLatestPingFunc) appendCall(r0 EventLogStoreLatestPingFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EventLogStoreLatestPingFuncCall objects
// describing the invocations of this function.
func (f *EventLogStoreLatestPingFunc) History() []EventLogStoreLatestPingFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreLatestPingFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreLatestPingFuncCall is an object that describes an invocation
// of method LatestPing on an instance of MockEventLogStore.
type EventLogStoreLatestPingFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *types.Event
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreLatestPingFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreLatestPingFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreListAllFunc describes the behavior when the ListAll method
// of the parent MockEventLogStore instance is invoked.
type EventLogStoreListAllFunc struct {
	defaultHook func(context.Context, database.EventLogsListOptions) ([]*types.Event, error)
	hooks       []func(context.Context, database.EventLogsListOptions) ([]*types.Event, error)
	history     []EventLogStoreListAllFuncCall
	mutex       sync.Mutex
}

// ListAll delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockEventLogStore) ListAll(v0 context.Context, v1 database.EventLogsListOptions) ([]*types.Event, error) {
	r0, r1 := m.ListAllFunc.nextHook()(v0, v1)
	m.ListAllFunc.appendCall(EventLogStoreListAllFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ListAll method of
// the parent MockEventLogStore instance is invoked and the hook queue is
// empty.
func (f *EventLogStoreListAllFunc) SetDefaultHook(hook func(context.Context, database.EventLogsListOptions) ([]*types.Event, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ListAll method of the parent MockEventLogStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *EventLogStoreListAllFunc) PushHook(hook func(context.Context, database.EventLogsListOptions) ([]*types.Event, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreListAllFunc) SetDefaultReturn(r0 []*types.Event, r1 error) {
	f.SetDefaultHook(func(context.Context, database.EventLogsListOptions) ([]*types.Event, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreListAllFunc) PushReturn(r0 []*types.Event, r1 error) {
	f.PushHook(func(context.Context, database.EventLogsListOptions) ([]*types.Event, error) {
		return r0, r1
	})
}

func (f *EventLogStoreListAllFunc) nextHook() func(context.Context, database.EventLogsListOptions) ([]*types.Event, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreListAllFunc) appendCall(r0 EventLogStoreListAllFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EventLogStoreListAllFuncCall objects
// describing the invocations of this function.
func (f *EventLogStoreListAllFunc) History() []EventLogStoreListAllFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreListAllFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreListAllFuncCall is an object that describes an invocation of
// method ListAll on an instance of MockEventLogStore.
type EventLogStoreListAllFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 database.EventLogsListOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []*types.Event
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreListAllFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreListAllFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreListUniqueUsersAllFunc describes the behavior when the
// ListUniqueUsersAll method of the parent MockEventLogStore instance is
// invoked.
type EventLogStoreListUniqueUsersAllFunc struct {
	defaultHook func(context.Context, time.Time, time.Time) ([]int32, error)
	hooks       []func(context.Context, time.Time, time.Time) ([]int32, error)
	history     []EventLogStoreListUniqueUsersAllFuncCall
	mutex       sync.Mutex
}

// ListUniqueUsersAll delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockEventLogStore) ListUniqueUsersAll(v0 context.Context, v1 time.Time, v2 time.Time) ([]int32, error) {
	r0, r1 := m.ListUniqueUsersAllFunc.nextHook()(v0, v1, v2)
	m.ListUniqueUsersAllFunc.appendCall(EventLogStoreListUniqueUsersAllFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ListUniqueUsersAll
// method of the parent MockEventLogStore instance is invoked and the hook
// queue is empty.
func (f *EventLogStoreListUniqueUsersAllFunc) SetDefaultHook(hook func(context.Context, time.Time, time.Time) ([]int32, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ListUniqueUsersAll method of the parent MockEventLogStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *EventLogStoreListUniqueUsersAllFunc) PushHook(hook func(context.Context, time.Time, time.Time) ([]int32, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreListUniqueUsersAllFunc) SetDefaultReturn(r0 []int32, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Time, time.Time) ([]int32, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreListUniqueUsersAllFunc) PushReturn(r0 []int32, r1 error) {
	f.PushHook(func(context.Context, time.Time, time.Time) ([]int32, error) {
		return r0, r1
	})
}

func (f *EventLogStoreListUniqueUsersAllFunc) nextHook() func(context.Context, time.Time, time.Time) ([]int32, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreListUniqueUsersAllFunc) appendCall(r0 EventLogStoreListUniqueUsersAllFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EventLogStoreListUniqueUsersAllFuncCall
// objects describing the invocations of this function.
func (f *EventLogStoreListUniqueUsersAllFunc) History() []EventLogStoreListUniqueUsersAllFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreListUniqueUsersAllFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreListUniqueUsersAllFuncCall is an object that describes an
// invocation of method ListUniqueUsersAll on an instance of
// MockEventLogStore.
type EventLogStoreListUniqueUsersAllFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Time
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int32
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreListUniqueUsersAllFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreListUniqueUsersAllFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreMaxTimestampByUserIDFunc describes the behavior when the
// MaxTimestampByUserID method of the parent MockEventLogStore instance is
// invoked.
type EventLogStoreMaxTimestampByUserIDFunc struct {
	defaultHook func(context.Context, int32) (*time.Time, error)
	hooks       []func(context.Context, int32) (*time.Time, error)
	history     []EventLogStoreMaxTimestampByUserIDFuncCall
	mutex       sync.Mutex
}

// MaxTimestampByUserID delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockEventLogStore) MaxTimestampByUserID(v0 context.Context, v1 int32) (*time.Time, error) {
	r0, r1 := m.MaxTimestampByUserIDFunc.nextHook()(v0, v1)
	m.MaxTimestampByUserIDFunc.appendCall(EventLogStoreMaxTimestampByUserIDFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MaxTimestampByUserID
// method of the parent MockEventLogStore instance is invoked and the hook
// queue is empty.
func (f *EventLogStoreMaxTimestampByUserIDFunc) SetDefaultHook(hook func(context.Context, int32) (*time.Time, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MaxTimestampByUserID method of the parent MockEventLogStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *EventLogStoreMaxTimestampByUserIDFunc) PushHook(hook func(context.Context, int32) (*time.Time, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreMaxTimestampByUserIDFunc) SetDefaultReturn(r0 *time.Time, r1 error) {
	f.SetDefaultHook(func(context.Context, int32) (*time.Time, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreMaxTimestampByUserIDFunc) PushReturn(r0 *time.Time, r1 error) {
	f.PushHook(func(context.Context, int32) (*time.Time, error) {
		return r0, r1
	})
}

func (f *EventLogStoreMaxTimestampByUserIDFunc) nextHook() func(context.Context, int32) (*time.Time, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreMaxTimestampByUserIDFunc) appendCall(r0 EventLogStoreMaxTimestampByUserIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EventLogStoreMaxTimestampByUserIDFuncCall
// objects describing the invocations of this function.
func (f *EventLogStoreMaxTimestampByUserIDFunc) History() []EventLogStoreMaxTimestampByUserIDFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreMaxTimestampByUserIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreMaxTimestampByUserIDFuncCall is an object that describes an
// invocation of method MaxTimestampByUserID on an instance of
// MockEventLogStore.
type EventLogStoreMaxTimestampByUserIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int32
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *time.Time
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreMaxTimestampByUserIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreMaxTimestampByUserIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreMaxTimestampByUserIDAndSourceFunc describes the behavior
// when the MaxTimestampByUserIDAndSource method of the parent
// MockEventLogStore instance is invoked.
type EventLogStoreMaxTimestampByUserIDAndSourceFunc struct {
	defaultHook func(context.Context, int32, string) (*time.Time, error)
	hooks       []func(context.Context, int32, string) (*time.Time, error)
	history     []EventLogStoreMaxTimestampByUserIDAndSourceFuncCall
	mutex       sync.Mutex
}

// MaxTimestampByUserIDAndSource delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockEventLogStore) MaxTimestampByUserIDAndSource(v0 context.Context, v1 int32, v2 string) (*time.Time, error) {
	r0, r1 := m.MaxTimestampByUserIDAndSourceFunc.nextHook()(v0, v1, v2)
	m.MaxTimestampByUserIDAndSourceFunc.appendCall(EventLogStoreMaxTimestampByUserIDAndSourceFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// MaxTimestampByUserIDAndSource method of the parent MockEventLogStore
// instance is invoked and the hook queue is empty.
func (f *EventLogStoreMaxTimestampByUserIDAndSourceFunc) SetDefaultHook(hook func(context.Context, int32, string) (*time.Time, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MaxTimestampByUserIDAndSource method of the parent MockEventLogStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *EventLogStoreMaxTimestampByUserIDAndSourceFunc) PushHook(hook func(context.Context, int32, string) (*time.Time, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreMaxTimestampByUserIDAndSourceFunc) SetDefaultReturn(r0 *time.Time, r1 error) {
	f.SetDefaultHook(func(context.Context, int32, string) (*time.Time, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreMaxTimestampByUserIDAndSourceFunc) PushReturn(r0 *time.Time, r1 error) {
	f.PushHook(func(context.Context, int32, string) (*time.Time, error) {
		return r0, r1
	})
}

func (f *EventLogStoreMaxTimestampByUserIDAndSourceFunc) nextHook() func(context.Context, int32, string) (*time.Time, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreMaxTimestampByUserIDAndSourceFunc) appendCall(r0 EventLogStoreMaxTimestampByUserIDAndSourceFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EventLogStoreMaxTimestampByUserIDAndSourceFuncCall objects describing the
// invocations of this function.
func (f *EventLogStoreMaxTimestampByUserIDAndSourceFunc) History() []EventLogStoreMaxTimestampByUserIDAndSourceFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreMaxTimestampByUserIDAndSourceFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreMaxTimestampByUserIDAndSourceFuncCall is an object that
// describes an invocation of method MaxTimestampByUserIDAndSource on an
// instance of MockEventLogStore.
type EventLogStoreMaxTimestampByUserIDAndSourceFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int32
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *time.Time
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreMaxTimestampByUserIDAndSourceFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreMaxTimestampByUserIDAndSourceFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreSiteUsageFunc describes the behavior when the SiteUsage
// method of the parent MockEventLogStore instance is invoked.
type EventLogStoreSiteUsageFunc struct {
	defaultHook func(context.Context) (types.SiteUsageSummary, error)
	hooks       []func(context.Context) (types.SiteUsageSummary, error)
	history     []EventLogStoreSiteUsageFuncCall
	mutex       sync.Mutex
}

// SiteUsage delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockEventLogStore) SiteUsage(v0 context.Context) (types.SiteUsageSummary, error) {
	r0, r1 := m.SiteUsageFunc.nextHook()(v0)
	m.SiteUsageFunc.appendCall(EventLogStoreSiteUsageFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the SiteUsage method of
// the parent MockEventLogStore instance is invoked and the hook queue is
// empty.
func (f *EventLogStoreSiteUsageFunc) SetDefaultHook(hook func(context.Context) (types.SiteUsageSummary, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SiteUsage method of the parent MockEventLogStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *EventLogStoreSiteUsageFunc) PushHook(hook func(context.Context) (types.SiteUsageSummary, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreSiteUsageFunc) SetDefaultReturn(r0 types.SiteUsageSummary, r1 error) {
	f.SetDefaultHook(func(context.Context) (types.SiteUsageSummary, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreSiteUsageFunc) PushReturn(r0 types.SiteUsageSummary, r1 error) {
	f.PushHook(func(context.Context) (types.SiteUsageSummary, error) {
		return r0, r1
	})
}

func (f *EventLogStoreSiteUsageFunc) nextHook() func(context.Context) (types.SiteUsageSummary, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreSiteUsageFunc) appendCall(r0 EventLogStoreSiteUsageFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EventLogStoreSiteUsageFuncCall objects
// describing the invocations of this function.
func (f *EventLogStoreSiteUsageFunc) History() []EventLogStoreSiteUsageFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreSiteUsageFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreSiteUsageFuncCall is an object that describes an invocation
// of method SiteUsage on an instance of MockEventLogStore.
type EventLogStoreSiteUsageFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 types.SiteUsageSummary
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreSiteUsageFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreSiteUsageFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreTransactFunc describes the behavior when the Transact method
// of the parent MockEventLogStore instance is invoked.
type EventLogStoreTransactFunc struct {
	defaultHook func(context.Context) (database.EventLogStore, error)
	hooks       []func(context.Context) (database.EventLogStore, error)
	history     []EventLogStoreTransactFuncCall
	mutex       sync.Mutex
}

// Transact delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockEventLogStore) Transact(v0 context.Context) (database.EventLogStore, error) {
	r0, r1 := m.TransactFunc.nextHook()(v0)
	m.TransactFunc.appendCall(EventLogStoreTransactFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Transact method of
// the parent MockEventLogStore instance is invoked and the hook queue is
// empty.
func (f *EventLogStoreTransactFunc) SetDefaultHook(hook func(context.Context) (database.EventLogStore, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Transact method of the parent MockEventLogStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *EventLogStoreTransactFunc) PushHook(hook func(context.Context) (database.EventLogStore, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreTransactFunc) SetDefaultReturn(r0 database.EventLogStore, r1 error) {
	f.SetDefaultHook(func(context.Context) (database.EventLogStore, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreTransactFunc) PushReturn(r0 database.EventLogStore, r1 error) {
	f.PushHook(func(context.Context) (database.EventLogStore, error) {
		return r0, r1
	})
}

func (f *EventLogStoreTransactFunc) nextHook() func(context.Context) (database.EventLogStore, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreTransactFunc) appendCall(r0 EventLogStoreTransactFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EventLogStoreTransactFuncCall objects
// describing the invocations of this function.
func (f *EventLogStoreTransactFunc) History() []EventLogStoreTransactFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreTransactFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreTransactFuncCall is an object that describes an invocation
// of method Transact on an instance of MockEventLogStore.
type EventLogStoreTransactFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 database.EventLogStore
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreTransactFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreTransactFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreUsersUsageCountsFunc describes the behavior when the
// UsersUsageCounts method of the parent MockEventLogStore instance is
// invoked.
type EventLogStoreUsersUsageCountsFunc struct {
	defaultHook func(context.Context) ([]types.UserUsageCounts, error)
	hooks       []func(context.Context) ([]types.UserUsageCounts, error)
	history     []EventLogStoreUsersUsageCountsFuncCall
	mutex       sync.Mutex
}

// UsersUsageCounts delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockEventLogStore) UsersUsageCounts(v0 context.Context) ([]types.UserUsageCounts, error) {
	r0, r1 := m.UsersUsageCountsFunc.nextHook()(v0)
	m.UsersUsageCountsFunc.appendCall(EventLogStoreUsersUsageCountsFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the UsersUsageCounts
// method of the parent MockEventLogStore instance is invoked and the hook
// queue is empty.
func (f *EventLogStoreUsersUsageCountsFunc) SetDefaultHook(hook func(context.Context) ([]types.UserUsageCounts, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UsersUsageCounts method of the parent MockEventLogStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *EventLogStoreUsersUsageCountsFunc) PushHook(hook func(context.Context) ([]types.UserUsageCounts, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreUsersUsageCountsFunc) SetDefaultReturn(r0 []types.UserUsageCounts, r1 error) {
	f.SetDefaultHook(func(context.Context) ([]types.UserUsageCounts, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreUsersUsageCountsFunc) PushReturn(r0 []types.UserUsageCounts, r1 error) {
	f.PushHook(func(context.Context) ([]types.UserUsageCounts, error) {
		return r0, r1
	})
}

func (f *EventLogStoreUsersUsageCountsFunc) nextHook() func(context.Context) ([]types.UserUsageCounts, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreUsersUsageCountsFunc) appendCall(r0 EventLogStoreUsersUsageCountsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EventLogStoreUsersUsageCountsFuncCall
// objects describing the invocations of this function.
func (f *EventLogStoreUsersUsageCountsFunc) History() []EventLogStoreUsersUsageCountsFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreUsersUsageCountsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreUsersUsageCountsFuncCall is an object that describes an
// invocation of method UsersUsageCounts on an instance of
// MockEventLogStore.
type EventLogStoreUsersUsageCountsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types.UserUsageCounts
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreUsersUsageCountsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreUsersUsageCountsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EventLogStoreWithFunc describes the behavior when the With method of the
// parent MockEventLogStore instance is invoked.
type EventLogStoreWithFunc struct {
	defaultHook func(basestore.ShareableStore) database.EventLogStore
	hooks       []func(basestore.ShareableStore) database.EventLogStore
	history     []EventLogStoreWithFuncCall
	mutex       sync.Mutex
}

// With delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockEventLogStore) With(v0 basestore.ShareableStore) database.EventLogStore {
	r0 := m.WithFunc.nextHook()(v0)
	m.WithFunc.appendCall(EventLogStoreWithFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the With method of the
// parent MockEventLogStore instance is invoked and the hook queue is empty.
func (f *EventLogStoreWithFunc) SetDefaultHook(hook func(basestore.ShareableStore) database.EventLogStore) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// With method of the parent MockEventLogStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *EventLogStoreWithFunc) PushHook(hook func(basestore.ShareableStore) database.EventLogStore) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *EventLogStoreWithFunc) SetDefaultReturn(r0 database.EventLogStore) {
	f.SetDefaultHook(func(basestore.ShareableStore) database.EventLogStore {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *EventLogStoreWithFunc) PushReturn(r0 database.EventLogStore) {
	f.PushHook(func(basestore.ShareableStore) database.EventLogStore {
		return r0
	})
}

func (f *EventLogStoreWithFunc) nextHook() func(basestore.ShareableStore) database.EventLogStore {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EventLogStoreWithFunc) appendCall(r0 EventLogStoreWithFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EventLogStoreWithFuncCall objects
// describing the invocations of this function.
func (f *EventLogStoreWithFunc) History() []EventLogStoreWithFuncCall {
	f.mutex.Lock()
	history := make([]EventLogStoreWithFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EventLogStoreWithFuncCall is an object that describes an invocation of
// method With on an instance of MockEventLogStore.
type EventLogStoreWithFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 basestore.ShareableStore
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 database.EventLogStore
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EventLogStoreWithFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EventLogStoreWithFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}
