// Code generated by go-mockgen 1.3.3; DO NOT EDIT.
//
// This file was generated by running `sg generate` (or `go-mockgen`) at the root of
// this repository. To add additional mocks to this or another package, add a new entry
// to the mockgen.yaml file in the root of this repository.

package transport

import (
	"context"
	"sync"

	shared "github.com/sourcegraph/sourcegraph/internal/codeintel/codenav/shared"
	graphql "github.com/sourcegraph/sourcegraph/internal/codeintel/codenav/transport/graphql"
)

// MockGitBlobLSIFDataResolver is a mock implementation of the
// GitBlobLSIFDataResolver interface (from the package
// github.com/sourcegraph/sourcegraph/internal/codeintel/codenav/transport/graphql)
// used for unit testing.
type MockGitBlobLSIFDataResolver struct {
	// DefinitionsFunc is an instance of a mock function object controlling
	// the behavior of the method Definitions.
	DefinitionsFunc *GitBlobLSIFDataResolverDefinitionsFunc
	// DiagnosticsFunc is an instance of a mock function object controlling
	// the behavior of the method Diagnostics.
	DiagnosticsFunc *GitBlobLSIFDataResolverDiagnosticsFunc
	// HoverFunc is an instance of a mock function object controlling the
	// behavior of the method Hover.
	HoverFunc *GitBlobLSIFDataResolverHoverFunc
	// ImplementationsFunc is an instance of a mock function object
	// controlling the behavior of the method Implementations.
	ImplementationsFunc *GitBlobLSIFDataResolverImplementationsFunc
	// LSIFUploadsFunc is an instance of a mock function object controlling
	// the behavior of the method LSIFUploads.
	LSIFUploadsFunc *GitBlobLSIFDataResolverLSIFUploadsFunc
	// RangesFunc is an instance of a mock function object controlling the
	// behavior of the method Ranges.
	RangesFunc *GitBlobLSIFDataResolverRangesFunc
	// ReferencesFunc is an instance of a mock function object controlling
	// the behavior of the method References.
	ReferencesFunc *GitBlobLSIFDataResolverReferencesFunc
	// StencilFunc is an instance of a mock function object controlling the
	// behavior of the method Stencil.
	StencilFunc *GitBlobLSIFDataResolverStencilFunc
}

// NewMockGitBlobLSIFDataResolver creates a new mock of the
// GitBlobLSIFDataResolver interface. All methods return zero values for all
// results, unless overwritten.
func NewMockGitBlobLSIFDataResolver() *MockGitBlobLSIFDataResolver {
	return &MockGitBlobLSIFDataResolver{
		DefinitionsFunc: &GitBlobLSIFDataResolverDefinitionsFunc{
			defaultHook: func(context.Context, int, int) (r0 []shared.UploadLocation, r1 error) {
				return
			},
		},
		DiagnosticsFunc: &GitBlobLSIFDataResolverDiagnosticsFunc{
			defaultHook: func(context.Context, int) (r0 []shared.DiagnosticAtUpload, r1 int, r2 error) {
				return
			},
		},
		HoverFunc: &GitBlobLSIFDataResolverHoverFunc{
			defaultHook: func(context.Context, int, int) (r0 string, r1 shared.Range, r2 bool, r3 error) {
				return
			},
		},
		ImplementationsFunc: &GitBlobLSIFDataResolverImplementationsFunc{
			defaultHook: func(context.Context, int, int, int, string) (r0 []shared.UploadLocation, r1 string, r2 error) {
				return
			},
		},
		LSIFUploadsFunc: &GitBlobLSIFDataResolverLSIFUploadsFunc{
			defaultHook: func(context.Context) (r0 []shared.Dump, r1 error) {
				return
			},
		},
		RangesFunc: &GitBlobLSIFDataResolverRangesFunc{
			defaultHook: func(context.Context, int, int) (r0 []shared.AdjustedCodeIntelligenceRange, r1 error) {
				return
			},
		},
		ReferencesFunc: &GitBlobLSIFDataResolverReferencesFunc{
			defaultHook: func(context.Context, int, int, int, string) (r0 []shared.UploadLocation, r1 string, r2 error) {
				return
			},
		},
		StencilFunc: &GitBlobLSIFDataResolverStencilFunc{
			defaultHook: func(context.Context) (r0 []shared.Range, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockGitBlobLSIFDataResolver creates a new mock of the
// GitBlobLSIFDataResolver interface. All methods panic on invocation,
// unless overwritten.
func NewStrictMockGitBlobLSIFDataResolver() *MockGitBlobLSIFDataResolver {
	return &MockGitBlobLSIFDataResolver{
		DefinitionsFunc: &GitBlobLSIFDataResolverDefinitionsFunc{
			defaultHook: func(context.Context, int, int) ([]shared.UploadLocation, error) {
				panic("unexpected invocation of MockGitBlobLSIFDataResolver.Definitions")
			},
		},
		DiagnosticsFunc: &GitBlobLSIFDataResolverDiagnosticsFunc{
			defaultHook: func(context.Context, int) ([]shared.DiagnosticAtUpload, int, error) {
				panic("unexpected invocation of MockGitBlobLSIFDataResolver.Diagnostics")
			},
		},
		HoverFunc: &GitBlobLSIFDataResolverHoverFunc{
			defaultHook: func(context.Context, int, int) (string, shared.Range, bool, error) {
				panic("unexpected invocation of MockGitBlobLSIFDataResolver.Hover")
			},
		},
		ImplementationsFunc: &GitBlobLSIFDataResolverImplementationsFunc{
			defaultHook: func(context.Context, int, int, int, string) ([]shared.UploadLocation, string, error) {
				panic("unexpected invocation of MockGitBlobLSIFDataResolver.Implementations")
			},
		},
		LSIFUploadsFunc: &GitBlobLSIFDataResolverLSIFUploadsFunc{
			defaultHook: func(context.Context) ([]shared.Dump, error) {
				panic("unexpected invocation of MockGitBlobLSIFDataResolver.LSIFUploads")
			},
		},
		RangesFunc: &GitBlobLSIFDataResolverRangesFunc{
			defaultHook: func(context.Context, int, int) ([]shared.AdjustedCodeIntelligenceRange, error) {
				panic("unexpected invocation of MockGitBlobLSIFDataResolver.Ranges")
			},
		},
		ReferencesFunc: &GitBlobLSIFDataResolverReferencesFunc{
			defaultHook: func(context.Context, int, int, int, string) ([]shared.UploadLocation, string, error) {
				panic("unexpected invocation of MockGitBlobLSIFDataResolver.References")
			},
		},
		StencilFunc: &GitBlobLSIFDataResolverStencilFunc{
			defaultHook: func(context.Context) ([]shared.Range, error) {
				panic("unexpected invocation of MockGitBlobLSIFDataResolver.Stencil")
			},
		},
	}
}

// NewMockGitBlobLSIFDataResolverFrom creates a new mock of the
// MockGitBlobLSIFDataResolver interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockGitBlobLSIFDataResolverFrom(i graphql.GitBlobLSIFDataResolver) *MockGitBlobLSIFDataResolver {
	return &MockGitBlobLSIFDataResolver{
		DefinitionsFunc: &GitBlobLSIFDataResolverDefinitionsFunc{
			defaultHook: i.Definitions,
		},
		DiagnosticsFunc: &GitBlobLSIFDataResolverDiagnosticsFunc{
			defaultHook: i.Diagnostics,
		},
		HoverFunc: &GitBlobLSIFDataResolverHoverFunc{
			defaultHook: i.Hover,
		},
		ImplementationsFunc: &GitBlobLSIFDataResolverImplementationsFunc{
			defaultHook: i.Implementations,
		},
		LSIFUploadsFunc: &GitBlobLSIFDataResolverLSIFUploadsFunc{
			defaultHook: i.LSIFUploads,
		},
		RangesFunc: &GitBlobLSIFDataResolverRangesFunc{
			defaultHook: i.Ranges,
		},
		ReferencesFunc: &GitBlobLSIFDataResolverReferencesFunc{
			defaultHook: i.References,
		},
		StencilFunc: &GitBlobLSIFDataResolverStencilFunc{
			defaultHook: i.Stencil,
		},
	}
}

// GitBlobLSIFDataResolverDefinitionsFunc describes the behavior when the
// Definitions method of the parent MockGitBlobLSIFDataResolver instance is
// invoked.
type GitBlobLSIFDataResolverDefinitionsFunc struct {
	defaultHook func(context.Context, int, int) ([]shared.UploadLocation, error)
	hooks       []func(context.Context, int, int) ([]shared.UploadLocation, error)
	history     []GitBlobLSIFDataResolverDefinitionsFuncCall
	mutex       sync.Mutex
}

// Definitions delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitBlobLSIFDataResolver) Definitions(v0 context.Context, v1 int, v2 int) ([]shared.UploadLocation, error) {
	r0, r1 := m.DefinitionsFunc.nextHook()(v0, v1, v2)
	m.DefinitionsFunc.appendCall(GitBlobLSIFDataResolverDefinitionsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Definitions method
// of the parent MockGitBlobLSIFDataResolver instance is invoked and the
// hook queue is empty.
func (f *GitBlobLSIFDataResolverDefinitionsFunc) SetDefaultHook(hook func(context.Context, int, int) ([]shared.UploadLocation, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Definitions method of the parent MockGitBlobLSIFDataResolver instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *GitBlobLSIFDataResolverDefinitionsFunc) PushHook(hook func(context.Context, int, int) ([]shared.UploadLocation, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitBlobLSIFDataResolverDefinitionsFunc) SetDefaultReturn(r0 []shared.UploadLocation, r1 error) {
	f.SetDefaultHook(func(context.Context, int, int) ([]shared.UploadLocation, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitBlobLSIFDataResolverDefinitionsFunc) PushReturn(r0 []shared.UploadLocation, r1 error) {
	f.PushHook(func(context.Context, int, int) ([]shared.UploadLocation, error) {
		return r0, r1
	})
}

func (f *GitBlobLSIFDataResolverDefinitionsFunc) nextHook() func(context.Context, int, int) ([]shared.UploadLocation, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitBlobLSIFDataResolverDefinitionsFunc) appendCall(r0 GitBlobLSIFDataResolverDefinitionsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitBlobLSIFDataResolverDefinitionsFuncCall
// objects describing the invocations of this function.
func (f *GitBlobLSIFDataResolverDefinitionsFunc) History() []GitBlobLSIFDataResolverDefinitionsFuncCall {
	f.mutex.Lock()
	history := make([]GitBlobLSIFDataResolverDefinitionsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitBlobLSIFDataResolverDefinitionsFuncCall is an object that describes an
// invocation of method Definitions on an instance of
// MockGitBlobLSIFDataResolver.
type GitBlobLSIFDataResolverDefinitionsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared.UploadLocation
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitBlobLSIFDataResolverDefinitionsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitBlobLSIFDataResolverDefinitionsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitBlobLSIFDataResolverDiagnosticsFunc describes the behavior when the
// Diagnostics method of the parent MockGitBlobLSIFDataResolver instance is
// invoked.
type GitBlobLSIFDataResolverDiagnosticsFunc struct {
	defaultHook func(context.Context, int) ([]shared.DiagnosticAtUpload, int, error)
	hooks       []func(context.Context, int) ([]shared.DiagnosticAtUpload, int, error)
	history     []GitBlobLSIFDataResolverDiagnosticsFuncCall
	mutex       sync.Mutex
}

// Diagnostics delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitBlobLSIFDataResolver) Diagnostics(v0 context.Context, v1 int) ([]shared.DiagnosticAtUpload, int, error) {
	r0, r1, r2 := m.DiagnosticsFunc.nextHook()(v0, v1)
	m.DiagnosticsFunc.appendCall(GitBlobLSIFDataResolverDiagnosticsFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Diagnostics method
// of the parent MockGitBlobLSIFDataResolver instance is invoked and the
// hook queue is empty.
func (f *GitBlobLSIFDataResolverDiagnosticsFunc) SetDefaultHook(hook func(context.Context, int) ([]shared.DiagnosticAtUpload, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Diagnostics method of the parent MockGitBlobLSIFDataResolver instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *GitBlobLSIFDataResolverDiagnosticsFunc) PushHook(hook func(context.Context, int) ([]shared.DiagnosticAtUpload, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitBlobLSIFDataResolverDiagnosticsFunc) SetDefaultReturn(r0 []shared.DiagnosticAtUpload, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int) ([]shared.DiagnosticAtUpload, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitBlobLSIFDataResolverDiagnosticsFunc) PushReturn(r0 []shared.DiagnosticAtUpload, r1 int, r2 error) {
	f.PushHook(func(context.Context, int) ([]shared.DiagnosticAtUpload, int, error) {
		return r0, r1, r2
	})
}

func (f *GitBlobLSIFDataResolverDiagnosticsFunc) nextHook() func(context.Context, int) ([]shared.DiagnosticAtUpload, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitBlobLSIFDataResolverDiagnosticsFunc) appendCall(r0 GitBlobLSIFDataResolverDiagnosticsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitBlobLSIFDataResolverDiagnosticsFuncCall
// objects describing the invocations of this function.
func (f *GitBlobLSIFDataResolverDiagnosticsFunc) History() []GitBlobLSIFDataResolverDiagnosticsFuncCall {
	f.mutex.Lock()
	history := make([]GitBlobLSIFDataResolverDiagnosticsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitBlobLSIFDataResolverDiagnosticsFuncCall is an object that describes an
// invocation of method Diagnostics on an instance of
// MockGitBlobLSIFDataResolver.
type GitBlobLSIFDataResolverDiagnosticsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared.DiagnosticAtUpload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitBlobLSIFDataResolverDiagnosticsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitBlobLSIFDataResolverDiagnosticsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// GitBlobLSIFDataResolverHoverFunc describes the behavior when the Hover
// method of the parent MockGitBlobLSIFDataResolver instance is invoked.
type GitBlobLSIFDataResolverHoverFunc struct {
	defaultHook func(context.Context, int, int) (string, shared.Range, bool, error)
	hooks       []func(context.Context, int, int) (string, shared.Range, bool, error)
	history     []GitBlobLSIFDataResolverHoverFuncCall
	mutex       sync.Mutex
}

// Hover delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockGitBlobLSIFDataResolver) Hover(v0 context.Context, v1 int, v2 int) (string, shared.Range, bool, error) {
	r0, r1, r2, r3 := m.HoverFunc.nextHook()(v0, v1, v2)
	m.HoverFunc.appendCall(GitBlobLSIFDataResolverHoverFuncCall{v0, v1, v2, r0, r1, r2, r3})
	return r0, r1, r2, r3
}

// SetDefaultHook sets function that is called when the Hover method of the
// parent MockGitBlobLSIFDataResolver instance is invoked and the hook queue
// is empty.
func (f *GitBlobLSIFDataResolverHoverFunc) SetDefaultHook(hook func(context.Context, int, int) (string, shared.Range, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Hover method of the parent MockGitBlobLSIFDataResolver instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitBlobLSIFDataResolverHoverFunc) PushHook(hook func(context.Context, int, int) (string, shared.Range, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitBlobLSIFDataResolverHoverFunc) SetDefaultReturn(r0 string, r1 shared.Range, r2 bool, r3 error) {
	f.SetDefaultHook(func(context.Context, int, int) (string, shared.Range, bool, error) {
		return r0, r1, r2, r3
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitBlobLSIFDataResolverHoverFunc) PushReturn(r0 string, r1 shared.Range, r2 bool, r3 error) {
	f.PushHook(func(context.Context, int, int) (string, shared.Range, bool, error) {
		return r0, r1, r2, r3
	})
}

func (f *GitBlobLSIFDataResolverHoverFunc) nextHook() func(context.Context, int, int) (string, shared.Range, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitBlobLSIFDataResolverHoverFunc) appendCall(r0 GitBlobLSIFDataResolverHoverFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitBlobLSIFDataResolverHoverFuncCall
// objects describing the invocations of this function.
func (f *GitBlobLSIFDataResolverHoverFunc) History() []GitBlobLSIFDataResolverHoverFuncCall {
	f.mutex.Lock()
	history := make([]GitBlobLSIFDataResolverHoverFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitBlobLSIFDataResolverHoverFuncCall is an object that describes an
// invocation of method Hover on an instance of MockGitBlobLSIFDataResolver.
type GitBlobLSIFDataResolverHoverFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 shared.Range
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 bool
	// Result3 is the value of the 4th result returned from this method
	// invocation.
	Result3 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitBlobLSIFDataResolverHoverFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitBlobLSIFDataResolverHoverFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2, c.Result3}
}

// GitBlobLSIFDataResolverImplementationsFunc describes the behavior when
// the Implementations method of the parent MockGitBlobLSIFDataResolver
// instance is invoked.
type GitBlobLSIFDataResolverImplementationsFunc struct {
	defaultHook func(context.Context, int, int, int, string) ([]shared.UploadLocation, string, error)
	hooks       []func(context.Context, int, int, int, string) ([]shared.UploadLocation, string, error)
	history     []GitBlobLSIFDataResolverImplementationsFuncCall
	mutex       sync.Mutex
}

// Implementations delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockGitBlobLSIFDataResolver) Implementations(v0 context.Context, v1 int, v2 int, v3 int, v4 string) ([]shared.UploadLocation, string, error) {
	r0, r1, r2 := m.ImplementationsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.ImplementationsFunc.appendCall(GitBlobLSIFDataResolverImplementationsFuncCall{v0, v1, v2, v3, v4, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Implementations
// method of the parent MockGitBlobLSIFDataResolver instance is invoked and
// the hook queue is empty.
func (f *GitBlobLSIFDataResolverImplementationsFunc) SetDefaultHook(hook func(context.Context, int, int, int, string) ([]shared.UploadLocation, string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Implementations method of the parent MockGitBlobLSIFDataResolver instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *GitBlobLSIFDataResolverImplementationsFunc) PushHook(hook func(context.Context, int, int, int, string) ([]shared.UploadLocation, string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitBlobLSIFDataResolverImplementationsFunc) SetDefaultReturn(r0 []shared.UploadLocation, r1 string, r2 error) {
	f.SetDefaultHook(func(context.Context, int, int, int, string) ([]shared.UploadLocation, string, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitBlobLSIFDataResolverImplementationsFunc) PushReturn(r0 []shared.UploadLocation, r1 string, r2 error) {
	f.PushHook(func(context.Context, int, int, int, string) ([]shared.UploadLocation, string, error) {
		return r0, r1, r2
	})
}

func (f *GitBlobLSIFDataResolverImplementationsFunc) nextHook() func(context.Context, int, int, int, string) ([]shared.UploadLocation, string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitBlobLSIFDataResolverImplementationsFunc) appendCall(r0 GitBlobLSIFDataResolverImplementationsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// GitBlobLSIFDataResolverImplementationsFuncCall objects describing the
// invocations of this function.
func (f *GitBlobLSIFDataResolverImplementationsFunc) History() []GitBlobLSIFDataResolverImplementationsFuncCall {
	f.mutex.Lock()
	history := make([]GitBlobLSIFDataResolverImplementationsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitBlobLSIFDataResolverImplementationsFuncCall is an object that
// describes an invocation of method Implementations on an instance of
// MockGitBlobLSIFDataResolver.
type GitBlobLSIFDataResolverImplementationsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared.UploadLocation
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 string
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitBlobLSIFDataResolverImplementationsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitBlobLSIFDataResolverImplementationsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// GitBlobLSIFDataResolverLSIFUploadsFunc describes the behavior when the
// LSIFUploads method of the parent MockGitBlobLSIFDataResolver instance is
// invoked.
type GitBlobLSIFDataResolverLSIFUploadsFunc struct {
	defaultHook func(context.Context) ([]shared.Dump, error)
	hooks       []func(context.Context) ([]shared.Dump, error)
	history     []GitBlobLSIFDataResolverLSIFUploadsFuncCall
	mutex       sync.Mutex
}

// LSIFUploads delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitBlobLSIFDataResolver) LSIFUploads(v0 context.Context) ([]shared.Dump, error) {
	r0, r1 := m.LSIFUploadsFunc.nextHook()(v0)
	m.LSIFUploadsFunc.appendCall(GitBlobLSIFDataResolverLSIFUploadsFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the LSIFUploads method
// of the parent MockGitBlobLSIFDataResolver instance is invoked and the
// hook queue is empty.
func (f *GitBlobLSIFDataResolverLSIFUploadsFunc) SetDefaultHook(hook func(context.Context) ([]shared.Dump, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// LSIFUploads method of the parent MockGitBlobLSIFDataResolver instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *GitBlobLSIFDataResolverLSIFUploadsFunc) PushHook(hook func(context.Context) ([]shared.Dump, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitBlobLSIFDataResolverLSIFUploadsFunc) SetDefaultReturn(r0 []shared.Dump, r1 error) {
	f.SetDefaultHook(func(context.Context) ([]shared.Dump, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitBlobLSIFDataResolverLSIFUploadsFunc) PushReturn(r0 []shared.Dump, r1 error) {
	f.PushHook(func(context.Context) ([]shared.Dump, error) {
		return r0, r1
	})
}

func (f *GitBlobLSIFDataResolverLSIFUploadsFunc) nextHook() func(context.Context) ([]shared.Dump, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitBlobLSIFDataResolverLSIFUploadsFunc) appendCall(r0 GitBlobLSIFDataResolverLSIFUploadsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitBlobLSIFDataResolverLSIFUploadsFuncCall
// objects describing the invocations of this function.
func (f *GitBlobLSIFDataResolverLSIFUploadsFunc) History() []GitBlobLSIFDataResolverLSIFUploadsFuncCall {
	f.mutex.Lock()
	history := make([]GitBlobLSIFDataResolverLSIFUploadsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitBlobLSIFDataResolverLSIFUploadsFuncCall is an object that describes an
// invocation of method LSIFUploads on an instance of
// MockGitBlobLSIFDataResolver.
type GitBlobLSIFDataResolverLSIFUploadsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitBlobLSIFDataResolverLSIFUploadsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitBlobLSIFDataResolverLSIFUploadsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitBlobLSIFDataResolverRangesFunc describes the behavior when the Ranges
// method of the parent MockGitBlobLSIFDataResolver instance is invoked.
type GitBlobLSIFDataResolverRangesFunc struct {
	defaultHook func(context.Context, int, int) ([]shared.AdjustedCodeIntelligenceRange, error)
	hooks       []func(context.Context, int, int) ([]shared.AdjustedCodeIntelligenceRange, error)
	history     []GitBlobLSIFDataResolverRangesFuncCall
	mutex       sync.Mutex
}

// Ranges delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockGitBlobLSIFDataResolver) Ranges(v0 context.Context, v1 int, v2 int) ([]shared.AdjustedCodeIntelligenceRange, error) {
	r0, r1 := m.RangesFunc.nextHook()(v0, v1, v2)
	m.RangesFunc.appendCall(GitBlobLSIFDataResolverRangesFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Ranges method of the
// parent MockGitBlobLSIFDataResolver instance is invoked and the hook queue
// is empty.
func (f *GitBlobLSIFDataResolverRangesFunc) SetDefaultHook(hook func(context.Context, int, int) ([]shared.AdjustedCodeIntelligenceRange, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Ranges method of the parent MockGitBlobLSIFDataResolver instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitBlobLSIFDataResolverRangesFunc) PushHook(hook func(context.Context, int, int) ([]shared.AdjustedCodeIntelligenceRange, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitBlobLSIFDataResolverRangesFunc) SetDefaultReturn(r0 []shared.AdjustedCodeIntelligenceRange, r1 error) {
	f.SetDefaultHook(func(context.Context, int, int) ([]shared.AdjustedCodeIntelligenceRange, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitBlobLSIFDataResolverRangesFunc) PushReturn(r0 []shared.AdjustedCodeIntelligenceRange, r1 error) {
	f.PushHook(func(context.Context, int, int) ([]shared.AdjustedCodeIntelligenceRange, error) {
		return r0, r1
	})
}

func (f *GitBlobLSIFDataResolverRangesFunc) nextHook() func(context.Context, int, int) ([]shared.AdjustedCodeIntelligenceRange, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitBlobLSIFDataResolverRangesFunc) appendCall(r0 GitBlobLSIFDataResolverRangesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitBlobLSIFDataResolverRangesFuncCall
// objects describing the invocations of this function.
func (f *GitBlobLSIFDataResolverRangesFunc) History() []GitBlobLSIFDataResolverRangesFuncCall {
	f.mutex.Lock()
	history := make([]GitBlobLSIFDataResolverRangesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitBlobLSIFDataResolverRangesFuncCall is an object that describes an
// invocation of method Ranges on an instance of
// MockGitBlobLSIFDataResolver.
type GitBlobLSIFDataResolverRangesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared.AdjustedCodeIntelligenceRange
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitBlobLSIFDataResolverRangesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitBlobLSIFDataResolverRangesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitBlobLSIFDataResolverReferencesFunc describes the behavior when the
// References method of the parent MockGitBlobLSIFDataResolver instance is
// invoked.
type GitBlobLSIFDataResolverReferencesFunc struct {
	defaultHook func(context.Context, int, int, int, string) ([]shared.UploadLocation, string, error)
	hooks       []func(context.Context, int, int, int, string) ([]shared.UploadLocation, string, error)
	history     []GitBlobLSIFDataResolverReferencesFuncCall
	mutex       sync.Mutex
}

// References delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitBlobLSIFDataResolver) References(v0 context.Context, v1 int, v2 int, v3 int, v4 string) ([]shared.UploadLocation, string, error) {
	r0, r1, r2 := m.ReferencesFunc.nextHook()(v0, v1, v2, v3, v4)
	m.ReferencesFunc.appendCall(GitBlobLSIFDataResolverReferencesFuncCall{v0, v1, v2, v3, v4, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the References method of
// the parent MockGitBlobLSIFDataResolver instance is invoked and the hook
// queue is empty.
func (f *GitBlobLSIFDataResolverReferencesFunc) SetDefaultHook(hook func(context.Context, int, int, int, string) ([]shared.UploadLocation, string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// References method of the parent MockGitBlobLSIFDataResolver instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *GitBlobLSIFDataResolverReferencesFunc) PushHook(hook func(context.Context, int, int, int, string) ([]shared.UploadLocation, string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitBlobLSIFDataResolverReferencesFunc) SetDefaultReturn(r0 []shared.UploadLocation, r1 string, r2 error) {
	f.SetDefaultHook(func(context.Context, int, int, int, string) ([]shared.UploadLocation, string, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitBlobLSIFDataResolverReferencesFunc) PushReturn(r0 []shared.UploadLocation, r1 string, r2 error) {
	f.PushHook(func(context.Context, int, int, int, string) ([]shared.UploadLocation, string, error) {
		return r0, r1, r2
	})
}

func (f *GitBlobLSIFDataResolverReferencesFunc) nextHook() func(context.Context, int, int, int, string) ([]shared.UploadLocation, string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitBlobLSIFDataResolverReferencesFunc) appendCall(r0 GitBlobLSIFDataResolverReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitBlobLSIFDataResolverReferencesFuncCall
// objects describing the invocations of this function.
func (f *GitBlobLSIFDataResolverReferencesFunc) History() []GitBlobLSIFDataResolverReferencesFuncCall {
	f.mutex.Lock()
	history := make([]GitBlobLSIFDataResolverReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitBlobLSIFDataResolverReferencesFuncCall is an object that describes an
// invocation of method References on an instance of
// MockGitBlobLSIFDataResolver.
type GitBlobLSIFDataResolverReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared.UploadLocation
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 string
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitBlobLSIFDataResolverReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitBlobLSIFDataResolverReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// GitBlobLSIFDataResolverStencilFunc describes the behavior when the
// Stencil method of the parent MockGitBlobLSIFDataResolver instance is
// invoked.
type GitBlobLSIFDataResolverStencilFunc struct {
	defaultHook func(context.Context) ([]shared.Range, error)
	hooks       []func(context.Context) ([]shared.Range, error)
	history     []GitBlobLSIFDataResolverStencilFuncCall
	mutex       sync.Mutex
}

// Stencil delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockGitBlobLSIFDataResolver) Stencil(v0 context.Context) ([]shared.Range, error) {
	r0, r1 := m.StencilFunc.nextHook()(v0)
	m.StencilFunc.appendCall(GitBlobLSIFDataResolverStencilFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Stencil method of
// the parent MockGitBlobLSIFDataResolver instance is invoked and the hook
// queue is empty.
func (f *GitBlobLSIFDataResolverStencilFunc) SetDefaultHook(hook func(context.Context) ([]shared.Range, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Stencil method of the parent MockGitBlobLSIFDataResolver instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitBlobLSIFDataResolverStencilFunc) PushHook(hook func(context.Context) ([]shared.Range, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitBlobLSIFDataResolverStencilFunc) SetDefaultReturn(r0 []shared.Range, r1 error) {
	f.SetDefaultHook(func(context.Context) ([]shared.Range, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitBlobLSIFDataResolverStencilFunc) PushReturn(r0 []shared.Range, r1 error) {
	f.PushHook(func(context.Context) ([]shared.Range, error) {
		return r0, r1
	})
}

func (f *GitBlobLSIFDataResolverStencilFunc) nextHook() func(context.Context) ([]shared.Range, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitBlobLSIFDataResolverStencilFunc) appendCall(r0 GitBlobLSIFDataResolverStencilFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitBlobLSIFDataResolverStencilFuncCall
// objects describing the invocations of this function.
func (f *GitBlobLSIFDataResolverStencilFunc) History() []GitBlobLSIFDataResolverStencilFuncCall {
	f.mutex.Lock()
	history := make([]GitBlobLSIFDataResolverStencilFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitBlobLSIFDataResolverStencilFuncCall is an object that describes an
// invocation of method Stencil on an instance of
// MockGitBlobLSIFDataResolver.
type GitBlobLSIFDataResolverStencilFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared.Range
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitBlobLSIFDataResolverStencilFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitBlobLSIFDataResolverStencilFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}
