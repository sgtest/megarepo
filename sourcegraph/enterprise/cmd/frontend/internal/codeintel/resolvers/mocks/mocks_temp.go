// Code generated by go-mockgen 1.3.4; DO NOT EDIT.
//
// This file was generated by running `sg generate` (or `go-mockgen`) at the root of
// this repository. To add additional mocks to this or another package, add a new entry
// to the mockgen.yaml file in the root of this repository.

package mocks

import (
	"context"
	"sync"

	resolvers "github.com/sourcegraph/sourcegraph/enterprise/cmd/frontend/internal/codeintel/resolvers"
	api "github.com/sourcegraph/sourcegraph/internal/api"
	graphql "github.com/sourcegraph/sourcegraph/internal/services/executors/transport/graphql"
)

// MockResolver is a mock implementation of the Resolver interface (from the
// package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/frontend/internal/codeintel/resolvers)
// used for unit testing.
type MockResolver struct {
	// AutoIndexingResolverFunc is an instance of a mock function object
	// controlling the behavior of the method AutoIndexingResolver.
	AutoIndexingResolverFunc *ResolverAutoIndexingResolverFunc
	// CodeNavResolverFunc is an instance of a mock function object
	// controlling the behavior of the method CodeNavResolver.
	CodeNavResolverFunc *ResolverCodeNavResolverFunc
	// ExecutorResolverFunc is an instance of a mock function object
	// controlling the behavior of the method ExecutorResolver.
	ExecutorResolverFunc *ResolverExecutorResolverFunc
	// PoliciesResolverFunc is an instance of a mock function object
	// controlling the behavior of the method PoliciesResolver.
	PoliciesResolverFunc *ResolverPoliciesResolverFunc
	// RequestLanguageSupportFunc is an instance of a mock function object
	// controlling the behavior of the method RequestLanguageSupport.
	RequestLanguageSupportFunc *ResolverRequestLanguageSupportFunc
	// RequestedLanguageSupportFunc is an instance of a mock function object
	// controlling the behavior of the method RequestedLanguageSupport.
	RequestedLanguageSupportFunc *ResolverRequestedLanguageSupportFunc
	// SupportedByCtagsFunc is an instance of a mock function object
	// controlling the behavior of the method SupportedByCtags.
	SupportedByCtagsFunc *ResolverSupportedByCtagsFunc
	// UploadsResolverFunc is an instance of a mock function object
	// controlling the behavior of the method UploadsResolver.
	UploadsResolverFunc *ResolverUploadsResolverFunc
}

// NewMockResolver creates a new mock of the Resolver interface. All methods
// return zero values for all results, unless overwritten.
func NewMockResolver() *MockResolver {
	return &MockResolver{
		AutoIndexingResolverFunc: &ResolverAutoIndexingResolverFunc{
			defaultHook: func() (r0 resolvers.AutoIndexingResolver) {
				return
			},
		},
		CodeNavResolverFunc: &ResolverCodeNavResolverFunc{
			defaultHook: func() (r0 resolvers.CodeNavResolver) {
				return
			},
		},
		ExecutorResolverFunc: &ResolverExecutorResolverFunc{
			defaultHook: func() (r0 graphql.Resolver) {
				return
			},
		},
		PoliciesResolverFunc: &ResolverPoliciesResolverFunc{
			defaultHook: func() (r0 resolvers.PoliciesResolver) {
				return
			},
		},
		RequestLanguageSupportFunc: &ResolverRequestLanguageSupportFunc{
			defaultHook: func(context.Context, int, string) (r0 error) {
				return
			},
		},
		RequestedLanguageSupportFunc: &ResolverRequestedLanguageSupportFunc{
			defaultHook: func(context.Context, int) (r0 []string, r1 error) {
				return
			},
		},
		SupportedByCtagsFunc: &ResolverSupportedByCtagsFunc{
			defaultHook: func(context.Context, string, api.RepoName) (r0 bool, r1 string, r2 error) {
				return
			},
		},
		UploadsResolverFunc: &ResolverUploadsResolverFunc{
			defaultHook: func() (r0 resolvers.UploadsResolver) {
				return
			},
		},
	}
}

// NewStrictMockResolver creates a new mock of the Resolver interface. All
// methods panic on invocation, unless overwritten.
func NewStrictMockResolver() *MockResolver {
	return &MockResolver{
		AutoIndexingResolverFunc: &ResolverAutoIndexingResolverFunc{
			defaultHook: func() resolvers.AutoIndexingResolver {
				panic("unexpected invocation of MockResolver.AutoIndexingResolver")
			},
		},
		CodeNavResolverFunc: &ResolverCodeNavResolverFunc{
			defaultHook: func() resolvers.CodeNavResolver {
				panic("unexpected invocation of MockResolver.CodeNavResolver")
			},
		},
		ExecutorResolverFunc: &ResolverExecutorResolverFunc{
			defaultHook: func() graphql.Resolver {
				panic("unexpected invocation of MockResolver.ExecutorResolver")
			},
		},
		PoliciesResolverFunc: &ResolverPoliciesResolverFunc{
			defaultHook: func() resolvers.PoliciesResolver {
				panic("unexpected invocation of MockResolver.PoliciesResolver")
			},
		},
		RequestLanguageSupportFunc: &ResolverRequestLanguageSupportFunc{
			defaultHook: func(context.Context, int, string) error {
				panic("unexpected invocation of MockResolver.RequestLanguageSupport")
			},
		},
		RequestedLanguageSupportFunc: &ResolverRequestedLanguageSupportFunc{
			defaultHook: func(context.Context, int) ([]string, error) {
				panic("unexpected invocation of MockResolver.RequestedLanguageSupport")
			},
		},
		SupportedByCtagsFunc: &ResolverSupportedByCtagsFunc{
			defaultHook: func(context.Context, string, api.RepoName) (bool, string, error) {
				panic("unexpected invocation of MockResolver.SupportedByCtags")
			},
		},
		UploadsResolverFunc: &ResolverUploadsResolverFunc{
			defaultHook: func() resolvers.UploadsResolver {
				panic("unexpected invocation of MockResolver.UploadsResolver")
			},
		},
	}
}

// NewMockResolverFrom creates a new mock of the MockResolver interface. All
// methods delegate to the given implementation, unless overwritten.
func NewMockResolverFrom(i resolvers.Resolver) *MockResolver {
	return &MockResolver{
		AutoIndexingResolverFunc: &ResolverAutoIndexingResolverFunc{
			defaultHook: i.AutoIndexingResolver,
		},
		CodeNavResolverFunc: &ResolverCodeNavResolverFunc{
			defaultHook: i.CodeNavResolver,
		},
		ExecutorResolverFunc: &ResolverExecutorResolverFunc{
			defaultHook: i.ExecutorResolver,
		},
		PoliciesResolverFunc: &ResolverPoliciesResolverFunc{
			defaultHook: i.PoliciesResolver,
		},
		RequestLanguageSupportFunc: &ResolverRequestLanguageSupportFunc{
			defaultHook: i.RequestLanguageSupport,
		},
		RequestedLanguageSupportFunc: &ResolverRequestedLanguageSupportFunc{
			defaultHook: i.RequestedLanguageSupport,
		},
		SupportedByCtagsFunc: &ResolverSupportedByCtagsFunc{
			defaultHook: i.SupportedByCtags,
		},
		UploadsResolverFunc: &ResolverUploadsResolverFunc{
			defaultHook: i.UploadsResolver,
		},
	}
}

// ResolverAutoIndexingResolverFunc describes the behavior when the
// AutoIndexingResolver method of the parent MockResolver instance is
// invoked.
type ResolverAutoIndexingResolverFunc struct {
	defaultHook func() resolvers.AutoIndexingResolver
	hooks       []func() resolvers.AutoIndexingResolver
	history     []ResolverAutoIndexingResolverFuncCall
	mutex       sync.Mutex
}

// AutoIndexingResolver delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockResolver) AutoIndexingResolver() resolvers.AutoIndexingResolver {
	r0 := m.AutoIndexingResolverFunc.nextHook()()
	m.AutoIndexingResolverFunc.appendCall(ResolverAutoIndexingResolverFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the AutoIndexingResolver
// method of the parent MockResolver instance is invoked and the hook queue
// is empty.
func (f *ResolverAutoIndexingResolverFunc) SetDefaultHook(hook func() resolvers.AutoIndexingResolver) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// AutoIndexingResolver method of the parent MockResolver instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *ResolverAutoIndexingResolverFunc) PushHook(hook func() resolvers.AutoIndexingResolver) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverAutoIndexingResolverFunc) SetDefaultReturn(r0 resolvers.AutoIndexingResolver) {
	f.SetDefaultHook(func() resolvers.AutoIndexingResolver {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverAutoIndexingResolverFunc) PushReturn(r0 resolvers.AutoIndexingResolver) {
	f.PushHook(func() resolvers.AutoIndexingResolver {
		return r0
	})
}

func (f *ResolverAutoIndexingResolverFunc) nextHook() func() resolvers.AutoIndexingResolver {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverAutoIndexingResolverFunc) appendCall(r0 ResolverAutoIndexingResolverFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverAutoIndexingResolverFuncCall
// objects describing the invocations of this function.
func (f *ResolverAutoIndexingResolverFunc) History() []ResolverAutoIndexingResolverFuncCall {
	f.mutex.Lock()
	history := make([]ResolverAutoIndexingResolverFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverAutoIndexingResolverFuncCall is an object that describes an
// invocation of method AutoIndexingResolver on an instance of MockResolver.
type ResolverAutoIndexingResolverFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 resolvers.AutoIndexingResolver
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverAutoIndexingResolverFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverAutoIndexingResolverFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// ResolverCodeNavResolverFunc describes the behavior when the
// CodeNavResolver method of the parent MockResolver instance is invoked.
type ResolverCodeNavResolverFunc struct {
	defaultHook func() resolvers.CodeNavResolver
	hooks       []func() resolvers.CodeNavResolver
	history     []ResolverCodeNavResolverFuncCall
	mutex       sync.Mutex
}

// CodeNavResolver delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockResolver) CodeNavResolver() resolvers.CodeNavResolver {
	r0 := m.CodeNavResolverFunc.nextHook()()
	m.CodeNavResolverFunc.appendCall(ResolverCodeNavResolverFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the CodeNavResolver
// method of the parent MockResolver instance is invoked and the hook queue
// is empty.
func (f *ResolverCodeNavResolverFunc) SetDefaultHook(hook func() resolvers.CodeNavResolver) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CodeNavResolver method of the parent MockResolver instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ResolverCodeNavResolverFunc) PushHook(hook func() resolvers.CodeNavResolver) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverCodeNavResolverFunc) SetDefaultReturn(r0 resolvers.CodeNavResolver) {
	f.SetDefaultHook(func() resolvers.CodeNavResolver {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverCodeNavResolverFunc) PushReturn(r0 resolvers.CodeNavResolver) {
	f.PushHook(func() resolvers.CodeNavResolver {
		return r0
	})
}

func (f *ResolverCodeNavResolverFunc) nextHook() func() resolvers.CodeNavResolver {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverCodeNavResolverFunc) appendCall(r0 ResolverCodeNavResolverFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverCodeNavResolverFuncCall objects
// describing the invocations of this function.
func (f *ResolverCodeNavResolverFunc) History() []ResolverCodeNavResolverFuncCall {
	f.mutex.Lock()
	history := make([]ResolverCodeNavResolverFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverCodeNavResolverFuncCall is an object that describes an invocation
// of method CodeNavResolver on an instance of MockResolver.
type ResolverCodeNavResolverFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 resolvers.CodeNavResolver
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverCodeNavResolverFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverCodeNavResolverFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// ResolverExecutorResolverFunc describes the behavior when the
// ExecutorResolver method of the parent MockResolver instance is invoked.
type ResolverExecutorResolverFunc struct {
	defaultHook func() graphql.Resolver
	hooks       []func() graphql.Resolver
	history     []ResolverExecutorResolverFuncCall
	mutex       sync.Mutex
}

// ExecutorResolver delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockResolver) ExecutorResolver() graphql.Resolver {
	r0 := m.ExecutorResolverFunc.nextHook()()
	m.ExecutorResolverFunc.appendCall(ResolverExecutorResolverFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the ExecutorResolver
// method of the parent MockResolver instance is invoked and the hook queue
// is empty.
func (f *ResolverExecutorResolverFunc) SetDefaultHook(hook func() graphql.Resolver) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ExecutorResolver method of the parent MockResolver instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ResolverExecutorResolverFunc) PushHook(hook func() graphql.Resolver) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverExecutorResolverFunc) SetDefaultReturn(r0 graphql.Resolver) {
	f.SetDefaultHook(func() graphql.Resolver {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverExecutorResolverFunc) PushReturn(r0 graphql.Resolver) {
	f.PushHook(func() graphql.Resolver {
		return r0
	})
}

func (f *ResolverExecutorResolverFunc) nextHook() func() graphql.Resolver {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverExecutorResolverFunc) appendCall(r0 ResolverExecutorResolverFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverExecutorResolverFuncCall objects
// describing the invocations of this function.
func (f *ResolverExecutorResolverFunc) History() []ResolverExecutorResolverFuncCall {
	f.mutex.Lock()
	history := make([]ResolverExecutorResolverFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverExecutorResolverFuncCall is an object that describes an
// invocation of method ExecutorResolver on an instance of MockResolver.
type ResolverExecutorResolverFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 graphql.Resolver
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverExecutorResolverFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverExecutorResolverFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// ResolverPoliciesResolverFunc describes the behavior when the
// PoliciesResolver method of the parent MockResolver instance is invoked.
type ResolverPoliciesResolverFunc struct {
	defaultHook func() resolvers.PoliciesResolver
	hooks       []func() resolvers.PoliciesResolver
	history     []ResolverPoliciesResolverFuncCall
	mutex       sync.Mutex
}

// PoliciesResolver delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockResolver) PoliciesResolver() resolvers.PoliciesResolver {
	r0 := m.PoliciesResolverFunc.nextHook()()
	m.PoliciesResolverFunc.appendCall(ResolverPoliciesResolverFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the PoliciesResolver
// method of the parent MockResolver instance is invoked and the hook queue
// is empty.
func (f *ResolverPoliciesResolverFunc) SetDefaultHook(hook func() resolvers.PoliciesResolver) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// PoliciesResolver method of the parent MockResolver instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ResolverPoliciesResolverFunc) PushHook(hook func() resolvers.PoliciesResolver) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverPoliciesResolverFunc) SetDefaultReturn(r0 resolvers.PoliciesResolver) {
	f.SetDefaultHook(func() resolvers.PoliciesResolver {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverPoliciesResolverFunc) PushReturn(r0 resolvers.PoliciesResolver) {
	f.PushHook(func() resolvers.PoliciesResolver {
		return r0
	})
}

func (f *ResolverPoliciesResolverFunc) nextHook() func() resolvers.PoliciesResolver {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverPoliciesResolverFunc) appendCall(r0 ResolverPoliciesResolverFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverPoliciesResolverFuncCall objects
// describing the invocations of this function.
func (f *ResolverPoliciesResolverFunc) History() []ResolverPoliciesResolverFuncCall {
	f.mutex.Lock()
	history := make([]ResolverPoliciesResolverFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverPoliciesResolverFuncCall is an object that describes an
// invocation of method PoliciesResolver on an instance of MockResolver.
type ResolverPoliciesResolverFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 resolvers.PoliciesResolver
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverPoliciesResolverFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverPoliciesResolverFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// ResolverRequestLanguageSupportFunc describes the behavior when the
// RequestLanguageSupport method of the parent MockResolver instance is
// invoked.
type ResolverRequestLanguageSupportFunc struct {
	defaultHook func(context.Context, int, string) error
	hooks       []func(context.Context, int, string) error
	history     []ResolverRequestLanguageSupportFuncCall
	mutex       sync.Mutex
}

// RequestLanguageSupport delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockResolver) RequestLanguageSupport(v0 context.Context, v1 int, v2 string) error {
	r0 := m.RequestLanguageSupportFunc.nextHook()(v0, v1, v2)
	m.RequestLanguageSupportFunc.appendCall(ResolverRequestLanguageSupportFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// RequestLanguageSupport method of the parent MockResolver instance is
// invoked and the hook queue is empty.
func (f *ResolverRequestLanguageSupportFunc) SetDefaultHook(hook func(context.Context, int, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RequestLanguageSupport method of the parent MockResolver instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *ResolverRequestLanguageSupportFunc) PushHook(hook func(context.Context, int, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverRequestLanguageSupportFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverRequestLanguageSupportFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string) error {
		return r0
	})
}

func (f *ResolverRequestLanguageSupportFunc) nextHook() func(context.Context, int, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverRequestLanguageSupportFunc) appendCall(r0 ResolverRequestLanguageSupportFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverRequestLanguageSupportFuncCall
// objects describing the invocations of this function.
func (f *ResolverRequestLanguageSupportFunc) History() []ResolverRequestLanguageSupportFuncCall {
	f.mutex.Lock()
	history := make([]ResolverRequestLanguageSupportFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverRequestLanguageSupportFuncCall is an object that describes an
// invocation of method RequestLanguageSupport on an instance of
// MockResolver.
type ResolverRequestLanguageSupportFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverRequestLanguageSupportFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverRequestLanguageSupportFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// ResolverRequestedLanguageSupportFunc describes the behavior when the
// RequestedLanguageSupport method of the parent MockResolver instance is
// invoked.
type ResolverRequestedLanguageSupportFunc struct {
	defaultHook func(context.Context, int) ([]string, error)
	hooks       []func(context.Context, int) ([]string, error)
	history     []ResolverRequestedLanguageSupportFuncCall
	mutex       sync.Mutex
}

// RequestedLanguageSupport delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockResolver) RequestedLanguageSupport(v0 context.Context, v1 int) ([]string, error) {
	r0, r1 := m.RequestedLanguageSupportFunc.nextHook()(v0, v1)
	m.RequestedLanguageSupportFunc.appendCall(ResolverRequestedLanguageSupportFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// RequestedLanguageSupport method of the parent MockResolver instance is
// invoked and the hook queue is empty.
func (f *ResolverRequestedLanguageSupportFunc) SetDefaultHook(hook func(context.Context, int) ([]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RequestedLanguageSupport method of the parent MockResolver instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *ResolverRequestedLanguageSupportFunc) PushHook(hook func(context.Context, int) ([]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverRequestedLanguageSupportFunc) SetDefaultReturn(r0 []string, r1 error) {
	f.SetDefaultHook(func(context.Context, int) ([]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverRequestedLanguageSupportFunc) PushReturn(r0 []string, r1 error) {
	f.PushHook(func(context.Context, int) ([]string, error) {
		return r0, r1
	})
}

func (f *ResolverRequestedLanguageSupportFunc) nextHook() func(context.Context, int) ([]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverRequestedLanguageSupportFunc) appendCall(r0 ResolverRequestedLanguageSupportFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverRequestedLanguageSupportFuncCall
// objects describing the invocations of this function.
func (f *ResolverRequestedLanguageSupportFunc) History() []ResolverRequestedLanguageSupportFuncCall {
	f.mutex.Lock()
	history := make([]ResolverRequestedLanguageSupportFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverRequestedLanguageSupportFuncCall is an object that describes an
// invocation of method RequestedLanguageSupport on an instance of
// MockResolver.
type ResolverRequestedLanguageSupportFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverRequestedLanguageSupportFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverRequestedLanguageSupportFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// ResolverSupportedByCtagsFunc describes the behavior when the
// SupportedByCtags method of the parent MockResolver instance is invoked.
type ResolverSupportedByCtagsFunc struct {
	defaultHook func(context.Context, string, api.RepoName) (bool, string, error)
	hooks       []func(context.Context, string, api.RepoName) (bool, string, error)
	history     []ResolverSupportedByCtagsFuncCall
	mutex       sync.Mutex
}

// SupportedByCtags delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockResolver) SupportedByCtags(v0 context.Context, v1 string, v2 api.RepoName) (bool, string, error) {
	r0, r1, r2 := m.SupportedByCtagsFunc.nextHook()(v0, v1, v2)
	m.SupportedByCtagsFunc.appendCall(ResolverSupportedByCtagsFuncCall{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the SupportedByCtags
// method of the parent MockResolver instance is invoked and the hook queue
// is empty.
func (f *ResolverSupportedByCtagsFunc) SetDefaultHook(hook func(context.Context, string, api.RepoName) (bool, string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SupportedByCtags method of the parent MockResolver instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ResolverSupportedByCtagsFunc) PushHook(hook func(context.Context, string, api.RepoName) (bool, string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverSupportedByCtagsFunc) SetDefaultReturn(r0 bool, r1 string, r2 error) {
	f.SetDefaultHook(func(context.Context, string, api.RepoName) (bool, string, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverSupportedByCtagsFunc) PushReturn(r0 bool, r1 string, r2 error) {
	f.PushHook(func(context.Context, string, api.RepoName) (bool, string, error) {
		return r0, r1, r2
	})
}

func (f *ResolverSupportedByCtagsFunc) nextHook() func(context.Context, string, api.RepoName) (bool, string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverSupportedByCtagsFunc) appendCall(r0 ResolverSupportedByCtagsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverSupportedByCtagsFuncCall objects
// describing the invocations of this function.
func (f *ResolverSupportedByCtagsFunc) History() []ResolverSupportedByCtagsFuncCall {
	f.mutex.Lock()
	history := make([]ResolverSupportedByCtagsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverSupportedByCtagsFuncCall is an object that describes an
// invocation of method SupportedByCtags on an instance of MockResolver.
type ResolverSupportedByCtagsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 api.RepoName
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 string
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverSupportedByCtagsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverSupportedByCtagsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// ResolverUploadsResolverFunc describes the behavior when the
// UploadsResolver method of the parent MockResolver instance is invoked.
type ResolverUploadsResolverFunc struct {
	defaultHook func() resolvers.UploadsResolver
	hooks       []func() resolvers.UploadsResolver
	history     []ResolverUploadsResolverFuncCall
	mutex       sync.Mutex
}

// UploadsResolver delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockResolver) UploadsResolver() resolvers.UploadsResolver {
	r0 := m.UploadsResolverFunc.nextHook()()
	m.UploadsResolverFunc.appendCall(ResolverUploadsResolverFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the UploadsResolver
// method of the parent MockResolver instance is invoked and the hook queue
// is empty.
func (f *ResolverUploadsResolverFunc) SetDefaultHook(hook func() resolvers.UploadsResolver) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UploadsResolver method of the parent MockResolver instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ResolverUploadsResolverFunc) PushHook(hook func() resolvers.UploadsResolver) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverUploadsResolverFunc) SetDefaultReturn(r0 resolvers.UploadsResolver) {
	f.SetDefaultHook(func() resolvers.UploadsResolver {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverUploadsResolverFunc) PushReturn(r0 resolvers.UploadsResolver) {
	f.PushHook(func() resolvers.UploadsResolver {
		return r0
	})
}

func (f *ResolverUploadsResolverFunc) nextHook() func() resolvers.UploadsResolver {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverUploadsResolverFunc) appendCall(r0 ResolverUploadsResolverFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverUploadsResolverFuncCall objects
// describing the invocations of this function.
func (f *ResolverUploadsResolverFunc) History() []ResolverUploadsResolverFuncCall {
	f.mutex.Lock()
	history := make([]ResolverUploadsResolverFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverUploadsResolverFuncCall is an object that describes an invocation
// of method UploadsResolver on an instance of MockResolver.
type ResolverUploadsResolverFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 resolvers.UploadsResolver
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverUploadsResolverFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverUploadsResolverFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}
