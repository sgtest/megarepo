// Code generated by go-mockgen 1.3.4; DO NOT EDIT.
//
// This file was generated by running `sg generate` (or `go-mockgen`) at the root of
// this repository. To add additional mocks to this or another package, add a new entry
// to the mockgen.yaml file in the root of this repository.

package mocks

import (
	"context"
	"sync"

	graphqlbackend "github.com/sourcegraph/sourcegraph/cmd/frontend/graphqlbackend"
	resolvers "github.com/sourcegraph/sourcegraph/enterprise/cmd/frontend/internal/codeintel/resolvers"
	api "github.com/sourcegraph/sourcegraph/internal/api"
	dbstore "github.com/sourcegraph/sourcegraph/internal/codeintel/stores/dbstore"
	graphql "github.com/sourcegraph/sourcegraph/internal/services/executors/transport/graphql"
)

// MockResolver is a mock implementation of the Resolver interface (from the
// package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/frontend/internal/codeintel/resolvers)
// used for unit testing.
type MockResolver struct {
	// AuditLogsForUploadFunc is an instance of a mock function object
	// controlling the behavior of the method AuditLogsForUpload.
	AuditLogsForUploadFunc *ResolverAuditLogsForUploadFunc
	// AutoIndexingResolverFunc is an instance of a mock function object
	// controlling the behavior of the method AutoIndexingResolver.
	AutoIndexingResolverFunc *ResolverAutoIndexingResolverFunc
	// CodeNavResolverFunc is an instance of a mock function object
	// controlling the behavior of the method CodeNavResolver.
	CodeNavResolverFunc *ResolverCodeNavResolverFunc
	// CommitGraphFunc is an instance of a mock function object controlling
	// the behavior of the method CommitGraph.
	CommitGraphFunc *ResolverCommitGraphFunc
	// DeleteUploadByIDFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteUploadByID.
	DeleteUploadByIDFunc *ResolverDeleteUploadByIDFunc
	// ExecutorResolverFunc is an instance of a mock function object
	// controlling the behavior of the method ExecutorResolver.
	ExecutorResolverFunc *ResolverExecutorResolverFunc
	// GetUploadByIDFunc is an instance of a mock function object
	// controlling the behavior of the method GetUploadByID.
	GetUploadByIDFunc *ResolverGetUploadByIDFunc
	// GetUploadDocumentsForPathFunc is an instance of a mock function
	// object controlling the behavior of the method
	// GetUploadDocumentsForPath.
	GetUploadDocumentsForPathFunc *ResolverGetUploadDocumentsForPathFunc
	// GetUploadsByIDsFunc is an instance of a mock function object
	// controlling the behavior of the method GetUploadsByIDs.
	GetUploadsByIDsFunc *ResolverGetUploadsByIDsFunc
	// PoliciesResolverFunc is an instance of a mock function object
	// controlling the behavior of the method PoliciesResolver.
	PoliciesResolverFunc *ResolverPoliciesResolverFunc
	// RepositorySummaryFunc is an instance of a mock function object
	// controlling the behavior of the method RepositorySummary.
	RepositorySummaryFunc *ResolverRepositorySummaryFunc
	// RequestLanguageSupportFunc is an instance of a mock function object
	// controlling the behavior of the method RequestLanguageSupport.
	RequestLanguageSupportFunc *ResolverRequestLanguageSupportFunc
	// RequestedLanguageSupportFunc is an instance of a mock function object
	// controlling the behavior of the method RequestedLanguageSupport.
	RequestedLanguageSupportFunc *ResolverRequestedLanguageSupportFunc
	// SupportedByCtagsFunc is an instance of a mock function object
	// controlling the behavior of the method SupportedByCtags.
	SupportedByCtagsFunc *ResolverSupportedByCtagsFunc
	// UploadConnectionResolverFunc is an instance of a mock function object
	// controlling the behavior of the method UploadConnectionResolver.
	UploadConnectionResolverFunc *ResolverUploadConnectionResolverFunc
}

// NewMockResolver creates a new mock of the Resolver interface. All methods
// return zero values for all results, unless overwritten.
func NewMockResolver() *MockResolver {
	return &MockResolver{
		AuditLogsForUploadFunc: &ResolverAuditLogsForUploadFunc{
			defaultHook: func(context.Context, int) (r0 []dbstore.UploadLog, r1 error) {
				return
			},
		},
		AutoIndexingResolverFunc: &ResolverAutoIndexingResolverFunc{
			defaultHook: func() (r0 resolvers.AutoIndexingResolver) {
				return
			},
		},
		CodeNavResolverFunc: &ResolverCodeNavResolverFunc{
			defaultHook: func() (r0 resolvers.CodeNavResolver) {
				return
			},
		},
		CommitGraphFunc: &ResolverCommitGraphFunc{
			defaultHook: func(context.Context, int) (r0 graphqlbackend.CodeIntelligenceCommitGraphResolver, r1 error) {
				return
			},
		},
		DeleteUploadByIDFunc: &ResolverDeleteUploadByIDFunc{
			defaultHook: func(context.Context, int) (r0 error) {
				return
			},
		},
		ExecutorResolverFunc: &ResolverExecutorResolverFunc{
			defaultHook: func() (r0 graphql.Resolver) {
				return
			},
		},
		GetUploadByIDFunc: &ResolverGetUploadByIDFunc{
			defaultHook: func(context.Context, int) (r0 dbstore.Upload, r1 bool, r2 error) {
				return
			},
		},
		GetUploadDocumentsForPathFunc: &ResolverGetUploadDocumentsForPathFunc{
			defaultHook: func(context.Context, int, string) (r0 []string, r1 int, r2 error) {
				return
			},
		},
		GetUploadsByIDsFunc: &ResolverGetUploadsByIDsFunc{
			defaultHook: func(context.Context, ...int) (r0 []dbstore.Upload, r1 error) {
				return
			},
		},
		PoliciesResolverFunc: &ResolverPoliciesResolverFunc{
			defaultHook: func() (r0 resolvers.PoliciesResolver) {
				return
			},
		},
		RepositorySummaryFunc: &ResolverRepositorySummaryFunc{
			defaultHook: func(context.Context, int) (r0 resolvers.RepositorySummary, r1 error) {
				return
			},
		},
		RequestLanguageSupportFunc: &ResolverRequestLanguageSupportFunc{
			defaultHook: func(context.Context, int, string) (r0 error) {
				return
			},
		},
		RequestedLanguageSupportFunc: &ResolverRequestedLanguageSupportFunc{
			defaultHook: func(context.Context, int) (r0 []string, r1 error) {
				return
			},
		},
		SupportedByCtagsFunc: &ResolverSupportedByCtagsFunc{
			defaultHook: func(context.Context, string, api.RepoName) (r0 bool, r1 string, r2 error) {
				return
			},
		},
		UploadConnectionResolverFunc: &ResolverUploadConnectionResolverFunc{
			defaultHook: func(dbstore.GetUploadsOptions) (r0 *resolvers.UploadsResolver) {
				return
			},
		},
	}
}

// NewStrictMockResolver creates a new mock of the Resolver interface. All
// methods panic on invocation, unless overwritten.
func NewStrictMockResolver() *MockResolver {
	return &MockResolver{
		AuditLogsForUploadFunc: &ResolverAuditLogsForUploadFunc{
			defaultHook: func(context.Context, int) ([]dbstore.UploadLog, error) {
				panic("unexpected invocation of MockResolver.AuditLogsForUpload")
			},
		},
		AutoIndexingResolverFunc: &ResolverAutoIndexingResolverFunc{
			defaultHook: func() resolvers.AutoIndexingResolver {
				panic("unexpected invocation of MockResolver.AutoIndexingResolver")
			},
		},
		CodeNavResolverFunc: &ResolverCodeNavResolverFunc{
			defaultHook: func() resolvers.CodeNavResolver {
				panic("unexpected invocation of MockResolver.CodeNavResolver")
			},
		},
		CommitGraphFunc: &ResolverCommitGraphFunc{
			defaultHook: func(context.Context, int) (graphqlbackend.CodeIntelligenceCommitGraphResolver, error) {
				panic("unexpected invocation of MockResolver.CommitGraph")
			},
		},
		DeleteUploadByIDFunc: &ResolverDeleteUploadByIDFunc{
			defaultHook: func(context.Context, int) error {
				panic("unexpected invocation of MockResolver.DeleteUploadByID")
			},
		},
		ExecutorResolverFunc: &ResolverExecutorResolverFunc{
			defaultHook: func() graphql.Resolver {
				panic("unexpected invocation of MockResolver.ExecutorResolver")
			},
		},
		GetUploadByIDFunc: &ResolverGetUploadByIDFunc{
			defaultHook: func(context.Context, int) (dbstore.Upload, bool, error) {
				panic("unexpected invocation of MockResolver.GetUploadByID")
			},
		},
		GetUploadDocumentsForPathFunc: &ResolverGetUploadDocumentsForPathFunc{
			defaultHook: func(context.Context, int, string) ([]string, int, error) {
				panic("unexpected invocation of MockResolver.GetUploadDocumentsForPath")
			},
		},
		GetUploadsByIDsFunc: &ResolverGetUploadsByIDsFunc{
			defaultHook: func(context.Context, ...int) ([]dbstore.Upload, error) {
				panic("unexpected invocation of MockResolver.GetUploadsByIDs")
			},
		},
		PoliciesResolverFunc: &ResolverPoliciesResolverFunc{
			defaultHook: func() resolvers.PoliciesResolver {
				panic("unexpected invocation of MockResolver.PoliciesResolver")
			},
		},
		RepositorySummaryFunc: &ResolverRepositorySummaryFunc{
			defaultHook: func(context.Context, int) (resolvers.RepositorySummary, error) {
				panic("unexpected invocation of MockResolver.RepositorySummary")
			},
		},
		RequestLanguageSupportFunc: &ResolverRequestLanguageSupportFunc{
			defaultHook: func(context.Context, int, string) error {
				panic("unexpected invocation of MockResolver.RequestLanguageSupport")
			},
		},
		RequestedLanguageSupportFunc: &ResolverRequestedLanguageSupportFunc{
			defaultHook: func(context.Context, int) ([]string, error) {
				panic("unexpected invocation of MockResolver.RequestedLanguageSupport")
			},
		},
		SupportedByCtagsFunc: &ResolverSupportedByCtagsFunc{
			defaultHook: func(context.Context, string, api.RepoName) (bool, string, error) {
				panic("unexpected invocation of MockResolver.SupportedByCtags")
			},
		},
		UploadConnectionResolverFunc: &ResolverUploadConnectionResolverFunc{
			defaultHook: func(dbstore.GetUploadsOptions) *resolvers.UploadsResolver {
				panic("unexpected invocation of MockResolver.UploadConnectionResolver")
			},
		},
	}
}

// NewMockResolverFrom creates a new mock of the MockResolver interface. All
// methods delegate to the given implementation, unless overwritten.
func NewMockResolverFrom(i resolvers.Resolver) *MockResolver {
	return &MockResolver{
		AuditLogsForUploadFunc: &ResolverAuditLogsForUploadFunc{
			defaultHook: i.AuditLogsForUpload,
		},
		AutoIndexingResolverFunc: &ResolverAutoIndexingResolverFunc{
			defaultHook: i.AutoIndexingResolver,
		},
		CodeNavResolverFunc: &ResolverCodeNavResolverFunc{
			defaultHook: i.CodeNavResolver,
		},
		CommitGraphFunc: &ResolverCommitGraphFunc{
			defaultHook: i.CommitGraph,
		},
		DeleteUploadByIDFunc: &ResolverDeleteUploadByIDFunc{
			defaultHook: i.DeleteUploadByID,
		},
		ExecutorResolverFunc: &ResolverExecutorResolverFunc{
			defaultHook: i.ExecutorResolver,
		},
		GetUploadByIDFunc: &ResolverGetUploadByIDFunc{
			defaultHook: i.GetUploadByID,
		},
		GetUploadDocumentsForPathFunc: &ResolverGetUploadDocumentsForPathFunc{
			defaultHook: i.GetUploadDocumentsForPath,
		},
		GetUploadsByIDsFunc: &ResolverGetUploadsByIDsFunc{
			defaultHook: i.GetUploadsByIDs,
		},
		PoliciesResolverFunc: &ResolverPoliciesResolverFunc{
			defaultHook: i.PoliciesResolver,
		},
		RepositorySummaryFunc: &ResolverRepositorySummaryFunc{
			defaultHook: i.RepositorySummary,
		},
		RequestLanguageSupportFunc: &ResolverRequestLanguageSupportFunc{
			defaultHook: i.RequestLanguageSupport,
		},
		RequestedLanguageSupportFunc: &ResolverRequestedLanguageSupportFunc{
			defaultHook: i.RequestedLanguageSupport,
		},
		SupportedByCtagsFunc: &ResolverSupportedByCtagsFunc{
			defaultHook: i.SupportedByCtags,
		},
		UploadConnectionResolverFunc: &ResolverUploadConnectionResolverFunc{
			defaultHook: i.UploadConnectionResolver,
		},
	}
}

// ResolverAuditLogsForUploadFunc describes the behavior when the
// AuditLogsForUpload method of the parent MockResolver instance is invoked.
type ResolverAuditLogsForUploadFunc struct {
	defaultHook func(context.Context, int) ([]dbstore.UploadLog, error)
	hooks       []func(context.Context, int) ([]dbstore.UploadLog, error)
	history     []ResolverAuditLogsForUploadFuncCall
	mutex       sync.Mutex
}

// AuditLogsForUpload delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockResolver) AuditLogsForUpload(v0 context.Context, v1 int) ([]dbstore.UploadLog, error) {
	r0, r1 := m.AuditLogsForUploadFunc.nextHook()(v0, v1)
	m.AuditLogsForUploadFunc.appendCall(ResolverAuditLogsForUploadFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the AuditLogsForUpload
// method of the parent MockResolver instance is invoked and the hook queue
// is empty.
func (f *ResolverAuditLogsForUploadFunc) SetDefaultHook(hook func(context.Context, int) ([]dbstore.UploadLog, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// AuditLogsForUpload method of the parent MockResolver instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ResolverAuditLogsForUploadFunc) PushHook(hook func(context.Context, int) ([]dbstore.UploadLog, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverAuditLogsForUploadFunc) SetDefaultReturn(r0 []dbstore.UploadLog, r1 error) {
	f.SetDefaultHook(func(context.Context, int) ([]dbstore.UploadLog, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverAuditLogsForUploadFunc) PushReturn(r0 []dbstore.UploadLog, r1 error) {
	f.PushHook(func(context.Context, int) ([]dbstore.UploadLog, error) {
		return r0, r1
	})
}

func (f *ResolverAuditLogsForUploadFunc) nextHook() func(context.Context, int) ([]dbstore.UploadLog, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverAuditLogsForUploadFunc) appendCall(r0 ResolverAuditLogsForUploadFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverAuditLogsForUploadFuncCall objects
// describing the invocations of this function.
func (f *ResolverAuditLogsForUploadFunc) History() []ResolverAuditLogsForUploadFuncCall {
	f.mutex.Lock()
	history := make([]ResolverAuditLogsForUploadFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverAuditLogsForUploadFuncCall is an object that describes an
// invocation of method AuditLogsForUpload on an instance of MockResolver.
type ResolverAuditLogsForUploadFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.UploadLog
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverAuditLogsForUploadFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverAuditLogsForUploadFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// ResolverAutoIndexingResolverFunc describes the behavior when the
// AutoIndexingResolver method of the parent MockResolver instance is
// invoked.
type ResolverAutoIndexingResolverFunc struct {
	defaultHook func() resolvers.AutoIndexingResolver
	hooks       []func() resolvers.AutoIndexingResolver
	history     []ResolverAutoIndexingResolverFuncCall
	mutex       sync.Mutex
}

// AutoIndexingResolver delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockResolver) AutoIndexingResolver() resolvers.AutoIndexingResolver {
	r0 := m.AutoIndexingResolverFunc.nextHook()()
	m.AutoIndexingResolverFunc.appendCall(ResolverAutoIndexingResolverFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the AutoIndexingResolver
// method of the parent MockResolver instance is invoked and the hook queue
// is empty.
func (f *ResolverAutoIndexingResolverFunc) SetDefaultHook(hook func() resolvers.AutoIndexingResolver) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// AutoIndexingResolver method of the parent MockResolver instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *ResolverAutoIndexingResolverFunc) PushHook(hook func() resolvers.AutoIndexingResolver) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverAutoIndexingResolverFunc) SetDefaultReturn(r0 resolvers.AutoIndexingResolver) {
	f.SetDefaultHook(func() resolvers.AutoIndexingResolver {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverAutoIndexingResolverFunc) PushReturn(r0 resolvers.AutoIndexingResolver) {
	f.PushHook(func() resolvers.AutoIndexingResolver {
		return r0
	})
}

func (f *ResolverAutoIndexingResolverFunc) nextHook() func() resolvers.AutoIndexingResolver {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverAutoIndexingResolverFunc) appendCall(r0 ResolverAutoIndexingResolverFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverAutoIndexingResolverFuncCall
// objects describing the invocations of this function.
func (f *ResolverAutoIndexingResolverFunc) History() []ResolverAutoIndexingResolverFuncCall {
	f.mutex.Lock()
	history := make([]ResolverAutoIndexingResolverFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverAutoIndexingResolverFuncCall is an object that describes an
// invocation of method AutoIndexingResolver on an instance of MockResolver.
type ResolverAutoIndexingResolverFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 resolvers.AutoIndexingResolver
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverAutoIndexingResolverFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverAutoIndexingResolverFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// ResolverCodeNavResolverFunc describes the behavior when the
// CodeNavResolver method of the parent MockResolver instance is invoked.
type ResolverCodeNavResolverFunc struct {
	defaultHook func() resolvers.CodeNavResolver
	hooks       []func() resolvers.CodeNavResolver
	history     []ResolverCodeNavResolverFuncCall
	mutex       sync.Mutex
}

// CodeNavResolver delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockResolver) CodeNavResolver() resolvers.CodeNavResolver {
	r0 := m.CodeNavResolverFunc.nextHook()()
	m.CodeNavResolverFunc.appendCall(ResolverCodeNavResolverFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the CodeNavResolver
// method of the parent MockResolver instance is invoked and the hook queue
// is empty.
func (f *ResolverCodeNavResolverFunc) SetDefaultHook(hook func() resolvers.CodeNavResolver) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CodeNavResolver method of the parent MockResolver instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ResolverCodeNavResolverFunc) PushHook(hook func() resolvers.CodeNavResolver) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverCodeNavResolverFunc) SetDefaultReturn(r0 resolvers.CodeNavResolver) {
	f.SetDefaultHook(func() resolvers.CodeNavResolver {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverCodeNavResolverFunc) PushReturn(r0 resolvers.CodeNavResolver) {
	f.PushHook(func() resolvers.CodeNavResolver {
		return r0
	})
}

func (f *ResolverCodeNavResolverFunc) nextHook() func() resolvers.CodeNavResolver {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverCodeNavResolverFunc) appendCall(r0 ResolverCodeNavResolverFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverCodeNavResolverFuncCall objects
// describing the invocations of this function.
func (f *ResolverCodeNavResolverFunc) History() []ResolverCodeNavResolverFuncCall {
	f.mutex.Lock()
	history := make([]ResolverCodeNavResolverFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverCodeNavResolverFuncCall is an object that describes an invocation
// of method CodeNavResolver on an instance of MockResolver.
type ResolverCodeNavResolverFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 resolvers.CodeNavResolver
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverCodeNavResolverFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverCodeNavResolverFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// ResolverCommitGraphFunc describes the behavior when the CommitGraph
// method of the parent MockResolver instance is invoked.
type ResolverCommitGraphFunc struct {
	defaultHook func(context.Context, int) (graphqlbackend.CodeIntelligenceCommitGraphResolver, error)
	hooks       []func(context.Context, int) (graphqlbackend.CodeIntelligenceCommitGraphResolver, error)
	history     []ResolverCommitGraphFuncCall
	mutex       sync.Mutex
}

// CommitGraph delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockResolver) CommitGraph(v0 context.Context, v1 int) (graphqlbackend.CodeIntelligenceCommitGraphResolver, error) {
	r0, r1 := m.CommitGraphFunc.nextHook()(v0, v1)
	m.CommitGraphFunc.appendCall(ResolverCommitGraphFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the CommitGraph method
// of the parent MockResolver instance is invoked and the hook queue is
// empty.
func (f *ResolverCommitGraphFunc) SetDefaultHook(hook func(context.Context, int) (graphqlbackend.CodeIntelligenceCommitGraphResolver, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitGraph method of the parent MockResolver instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *ResolverCommitGraphFunc) PushHook(hook func(context.Context, int) (graphqlbackend.CodeIntelligenceCommitGraphResolver, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverCommitGraphFunc) SetDefaultReturn(r0 graphqlbackend.CodeIntelligenceCommitGraphResolver, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (graphqlbackend.CodeIntelligenceCommitGraphResolver, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverCommitGraphFunc) PushReturn(r0 graphqlbackend.CodeIntelligenceCommitGraphResolver, r1 error) {
	f.PushHook(func(context.Context, int) (graphqlbackend.CodeIntelligenceCommitGraphResolver, error) {
		return r0, r1
	})
}

func (f *ResolverCommitGraphFunc) nextHook() func(context.Context, int) (graphqlbackend.CodeIntelligenceCommitGraphResolver, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverCommitGraphFunc) appendCall(r0 ResolverCommitGraphFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverCommitGraphFuncCall objects
// describing the invocations of this function.
func (f *ResolverCommitGraphFunc) History() []ResolverCommitGraphFuncCall {
	f.mutex.Lock()
	history := make([]ResolverCommitGraphFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverCommitGraphFuncCall is an object that describes an invocation of
// method CommitGraph on an instance of MockResolver.
type ResolverCommitGraphFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 graphqlbackend.CodeIntelligenceCommitGraphResolver
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverCommitGraphFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverCommitGraphFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// ResolverDeleteUploadByIDFunc describes the behavior when the
// DeleteUploadByID method of the parent MockResolver instance is invoked.
type ResolverDeleteUploadByIDFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []ResolverDeleteUploadByIDFuncCall
	mutex       sync.Mutex
}

// DeleteUploadByID delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockResolver) DeleteUploadByID(v0 context.Context, v1 int) error {
	r0 := m.DeleteUploadByIDFunc.nextHook()(v0, v1)
	m.DeleteUploadByIDFunc.appendCall(ResolverDeleteUploadByIDFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the DeleteUploadByID
// method of the parent MockResolver instance is invoked and the hook queue
// is empty.
func (f *ResolverDeleteUploadByIDFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteUploadByID method of the parent MockResolver instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ResolverDeleteUploadByIDFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverDeleteUploadByIDFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverDeleteUploadByIDFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *ResolverDeleteUploadByIDFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverDeleteUploadByIDFunc) appendCall(r0 ResolverDeleteUploadByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverDeleteUploadByIDFuncCall objects
// describing the invocations of this function.
func (f *ResolverDeleteUploadByIDFunc) History() []ResolverDeleteUploadByIDFuncCall {
	f.mutex.Lock()
	history := make([]ResolverDeleteUploadByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverDeleteUploadByIDFuncCall is an object that describes an
// invocation of method DeleteUploadByID on an instance of MockResolver.
type ResolverDeleteUploadByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverDeleteUploadByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverDeleteUploadByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// ResolverExecutorResolverFunc describes the behavior when the
// ExecutorResolver method of the parent MockResolver instance is invoked.
type ResolverExecutorResolverFunc struct {
	defaultHook func() graphql.Resolver
	hooks       []func() graphql.Resolver
	history     []ResolverExecutorResolverFuncCall
	mutex       sync.Mutex
}

// ExecutorResolver delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockResolver) ExecutorResolver() graphql.Resolver {
	r0 := m.ExecutorResolverFunc.nextHook()()
	m.ExecutorResolverFunc.appendCall(ResolverExecutorResolverFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the ExecutorResolver
// method of the parent MockResolver instance is invoked and the hook queue
// is empty.
func (f *ResolverExecutorResolverFunc) SetDefaultHook(hook func() graphql.Resolver) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ExecutorResolver method of the parent MockResolver instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ResolverExecutorResolverFunc) PushHook(hook func() graphql.Resolver) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverExecutorResolverFunc) SetDefaultReturn(r0 graphql.Resolver) {
	f.SetDefaultHook(func() graphql.Resolver {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverExecutorResolverFunc) PushReturn(r0 graphql.Resolver) {
	f.PushHook(func() graphql.Resolver {
		return r0
	})
}

func (f *ResolverExecutorResolverFunc) nextHook() func() graphql.Resolver {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverExecutorResolverFunc) appendCall(r0 ResolverExecutorResolverFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverExecutorResolverFuncCall objects
// describing the invocations of this function.
func (f *ResolverExecutorResolverFunc) History() []ResolverExecutorResolverFuncCall {
	f.mutex.Lock()
	history := make([]ResolverExecutorResolverFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverExecutorResolverFuncCall is an object that describes an
// invocation of method ExecutorResolver on an instance of MockResolver.
type ResolverExecutorResolverFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 graphql.Resolver
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverExecutorResolverFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverExecutorResolverFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// ResolverGetUploadByIDFunc describes the behavior when the GetUploadByID
// method of the parent MockResolver instance is invoked.
type ResolverGetUploadByIDFunc struct {
	defaultHook func(context.Context, int) (dbstore.Upload, bool, error)
	hooks       []func(context.Context, int) (dbstore.Upload, bool, error)
	history     []ResolverGetUploadByIDFuncCall
	mutex       sync.Mutex
}

// GetUploadByID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockResolver) GetUploadByID(v0 context.Context, v1 int) (dbstore.Upload, bool, error) {
	r0, r1, r2 := m.GetUploadByIDFunc.nextHook()(v0, v1)
	m.GetUploadByIDFunc.appendCall(ResolverGetUploadByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetUploadByID method
// of the parent MockResolver instance is invoked and the hook queue is
// empty.
func (f *ResolverGetUploadByIDFunc) SetDefaultHook(hook func(context.Context, int) (dbstore.Upload, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadByID method of the parent MockResolver instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *ResolverGetUploadByIDFunc) PushHook(hook func(context.Context, int) (dbstore.Upload, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverGetUploadByIDFunc) SetDefaultReturn(r0 dbstore.Upload, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (dbstore.Upload, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverGetUploadByIDFunc) PushReturn(r0 dbstore.Upload, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (dbstore.Upload, bool, error) {
		return r0, r1, r2
	})
}

func (f *ResolverGetUploadByIDFunc) nextHook() func(context.Context, int) (dbstore.Upload, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverGetUploadByIDFunc) appendCall(r0 ResolverGetUploadByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverGetUploadByIDFuncCall objects
// describing the invocations of this function.
func (f *ResolverGetUploadByIDFunc) History() []ResolverGetUploadByIDFuncCall {
	f.mutex.Lock()
	history := make([]ResolverGetUploadByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverGetUploadByIDFuncCall is an object that describes an invocation
// of method GetUploadByID on an instance of MockResolver.
type ResolverGetUploadByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 dbstore.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverGetUploadByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverGetUploadByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// ResolverGetUploadDocumentsForPathFunc describes the behavior when the
// GetUploadDocumentsForPath method of the parent MockResolver instance is
// invoked.
type ResolverGetUploadDocumentsForPathFunc struct {
	defaultHook func(context.Context, int, string) ([]string, int, error)
	hooks       []func(context.Context, int, string) ([]string, int, error)
	history     []ResolverGetUploadDocumentsForPathFuncCall
	mutex       sync.Mutex
}

// GetUploadDocumentsForPath delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockResolver) GetUploadDocumentsForPath(v0 context.Context, v1 int, v2 string) ([]string, int, error) {
	r0, r1, r2 := m.GetUploadDocumentsForPathFunc.nextHook()(v0, v1, v2)
	m.GetUploadDocumentsForPathFunc.appendCall(ResolverGetUploadDocumentsForPathFuncCall{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// GetUploadDocumentsForPath method of the parent MockResolver instance is
// invoked and the hook queue is empty.
func (f *ResolverGetUploadDocumentsForPathFunc) SetDefaultHook(hook func(context.Context, int, string) ([]string, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadDocumentsForPath method of the parent MockResolver instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *ResolverGetUploadDocumentsForPathFunc) PushHook(hook func(context.Context, int, string) ([]string, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverGetUploadDocumentsForPathFunc) SetDefaultReturn(r0 []string, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string) ([]string, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverGetUploadDocumentsForPathFunc) PushReturn(r0 []string, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string) ([]string, int, error) {
		return r0, r1, r2
	})
}

func (f *ResolverGetUploadDocumentsForPathFunc) nextHook() func(context.Context, int, string) ([]string, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverGetUploadDocumentsForPathFunc) appendCall(r0 ResolverGetUploadDocumentsForPathFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverGetUploadDocumentsForPathFuncCall
// objects describing the invocations of this function.
func (f *ResolverGetUploadDocumentsForPathFunc) History() []ResolverGetUploadDocumentsForPathFuncCall {
	f.mutex.Lock()
	history := make([]ResolverGetUploadDocumentsForPathFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverGetUploadDocumentsForPathFuncCall is an object that describes an
// invocation of method GetUploadDocumentsForPath on an instance of
// MockResolver.
type ResolverGetUploadDocumentsForPathFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverGetUploadDocumentsForPathFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverGetUploadDocumentsForPathFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// ResolverGetUploadsByIDsFunc describes the behavior when the
// GetUploadsByIDs method of the parent MockResolver instance is invoked.
type ResolverGetUploadsByIDsFunc struct {
	defaultHook func(context.Context, ...int) ([]dbstore.Upload, error)
	hooks       []func(context.Context, ...int) ([]dbstore.Upload, error)
	history     []ResolverGetUploadsByIDsFuncCall
	mutex       sync.Mutex
}

// GetUploadsByIDs delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockResolver) GetUploadsByIDs(v0 context.Context, v1 ...int) ([]dbstore.Upload, error) {
	r0, r1 := m.GetUploadsByIDsFunc.nextHook()(v0, v1...)
	m.GetUploadsByIDsFunc.appendCall(ResolverGetUploadsByIDsFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetUploadsByIDs
// method of the parent MockResolver instance is invoked and the hook queue
// is empty.
func (f *ResolverGetUploadsByIDsFunc) SetDefaultHook(hook func(context.Context, ...int) ([]dbstore.Upload, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadsByIDs method of the parent MockResolver instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ResolverGetUploadsByIDsFunc) PushHook(hook func(context.Context, ...int) ([]dbstore.Upload, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverGetUploadsByIDsFunc) SetDefaultReturn(r0 []dbstore.Upload, r1 error) {
	f.SetDefaultHook(func(context.Context, ...int) ([]dbstore.Upload, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverGetUploadsByIDsFunc) PushReturn(r0 []dbstore.Upload, r1 error) {
	f.PushHook(func(context.Context, ...int) ([]dbstore.Upload, error) {
		return r0, r1
	})
}

func (f *ResolverGetUploadsByIDsFunc) nextHook() func(context.Context, ...int) ([]dbstore.Upload, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverGetUploadsByIDsFunc) appendCall(r0 ResolverGetUploadsByIDsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverGetUploadsByIDsFuncCall objects
// describing the invocations of this function.
func (f *ResolverGetUploadsByIDsFunc) History() []ResolverGetUploadsByIDsFuncCall {
	f.mutex.Lock()
	history := make([]ResolverGetUploadsByIDsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverGetUploadsByIDsFuncCall is an object that describes an invocation
// of method GetUploadsByIDs on an instance of MockResolver.
type ResolverGetUploadsByIDsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c ResolverGetUploadsByIDsFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverGetUploadsByIDsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// ResolverPoliciesResolverFunc describes the behavior when the
// PoliciesResolver method of the parent MockResolver instance is invoked.
type ResolverPoliciesResolverFunc struct {
	defaultHook func() resolvers.PoliciesResolver
	hooks       []func() resolvers.PoliciesResolver
	history     []ResolverPoliciesResolverFuncCall
	mutex       sync.Mutex
}

// PoliciesResolver delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockResolver) PoliciesResolver() resolvers.PoliciesResolver {
	r0 := m.PoliciesResolverFunc.nextHook()()
	m.PoliciesResolverFunc.appendCall(ResolverPoliciesResolverFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the PoliciesResolver
// method of the parent MockResolver instance is invoked and the hook queue
// is empty.
func (f *ResolverPoliciesResolverFunc) SetDefaultHook(hook func() resolvers.PoliciesResolver) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// PoliciesResolver method of the parent MockResolver instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ResolverPoliciesResolverFunc) PushHook(hook func() resolvers.PoliciesResolver) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverPoliciesResolverFunc) SetDefaultReturn(r0 resolvers.PoliciesResolver) {
	f.SetDefaultHook(func() resolvers.PoliciesResolver {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverPoliciesResolverFunc) PushReturn(r0 resolvers.PoliciesResolver) {
	f.PushHook(func() resolvers.PoliciesResolver {
		return r0
	})
}

func (f *ResolverPoliciesResolverFunc) nextHook() func() resolvers.PoliciesResolver {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverPoliciesResolverFunc) appendCall(r0 ResolverPoliciesResolverFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverPoliciesResolverFuncCall objects
// describing the invocations of this function.
func (f *ResolverPoliciesResolverFunc) History() []ResolverPoliciesResolverFuncCall {
	f.mutex.Lock()
	history := make([]ResolverPoliciesResolverFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverPoliciesResolverFuncCall is an object that describes an
// invocation of method PoliciesResolver on an instance of MockResolver.
type ResolverPoliciesResolverFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 resolvers.PoliciesResolver
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverPoliciesResolverFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverPoliciesResolverFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// ResolverRepositorySummaryFunc describes the behavior when the
// RepositorySummary method of the parent MockResolver instance is invoked.
type ResolverRepositorySummaryFunc struct {
	defaultHook func(context.Context, int) (resolvers.RepositorySummary, error)
	hooks       []func(context.Context, int) (resolvers.RepositorySummary, error)
	history     []ResolverRepositorySummaryFuncCall
	mutex       sync.Mutex
}

// RepositorySummary delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockResolver) RepositorySummary(v0 context.Context, v1 int) (resolvers.RepositorySummary, error) {
	r0, r1 := m.RepositorySummaryFunc.nextHook()(v0, v1)
	m.RepositorySummaryFunc.appendCall(ResolverRepositorySummaryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepositorySummary
// method of the parent MockResolver instance is invoked and the hook queue
// is empty.
func (f *ResolverRepositorySummaryFunc) SetDefaultHook(hook func(context.Context, int) (resolvers.RepositorySummary, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepositorySummary method of the parent MockResolver instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ResolverRepositorySummaryFunc) PushHook(hook func(context.Context, int) (resolvers.RepositorySummary, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverRepositorySummaryFunc) SetDefaultReturn(r0 resolvers.RepositorySummary, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (resolvers.RepositorySummary, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverRepositorySummaryFunc) PushReturn(r0 resolvers.RepositorySummary, r1 error) {
	f.PushHook(func(context.Context, int) (resolvers.RepositorySummary, error) {
		return r0, r1
	})
}

func (f *ResolverRepositorySummaryFunc) nextHook() func(context.Context, int) (resolvers.RepositorySummary, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverRepositorySummaryFunc) appendCall(r0 ResolverRepositorySummaryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverRepositorySummaryFuncCall objects
// describing the invocations of this function.
func (f *ResolverRepositorySummaryFunc) History() []ResolverRepositorySummaryFuncCall {
	f.mutex.Lock()
	history := make([]ResolverRepositorySummaryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverRepositorySummaryFuncCall is an object that describes an
// invocation of method RepositorySummary on an instance of MockResolver.
type ResolverRepositorySummaryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 resolvers.RepositorySummary
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverRepositorySummaryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverRepositorySummaryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// ResolverRequestLanguageSupportFunc describes the behavior when the
// RequestLanguageSupport method of the parent MockResolver instance is
// invoked.
type ResolverRequestLanguageSupportFunc struct {
	defaultHook func(context.Context, int, string) error
	hooks       []func(context.Context, int, string) error
	history     []ResolverRequestLanguageSupportFuncCall
	mutex       sync.Mutex
}

// RequestLanguageSupport delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockResolver) RequestLanguageSupport(v0 context.Context, v1 int, v2 string) error {
	r0 := m.RequestLanguageSupportFunc.nextHook()(v0, v1, v2)
	m.RequestLanguageSupportFunc.appendCall(ResolverRequestLanguageSupportFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// RequestLanguageSupport method of the parent MockResolver instance is
// invoked and the hook queue is empty.
func (f *ResolverRequestLanguageSupportFunc) SetDefaultHook(hook func(context.Context, int, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RequestLanguageSupport method of the parent MockResolver instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *ResolverRequestLanguageSupportFunc) PushHook(hook func(context.Context, int, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverRequestLanguageSupportFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverRequestLanguageSupportFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string) error {
		return r0
	})
}

func (f *ResolverRequestLanguageSupportFunc) nextHook() func(context.Context, int, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverRequestLanguageSupportFunc) appendCall(r0 ResolverRequestLanguageSupportFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverRequestLanguageSupportFuncCall
// objects describing the invocations of this function.
func (f *ResolverRequestLanguageSupportFunc) History() []ResolverRequestLanguageSupportFuncCall {
	f.mutex.Lock()
	history := make([]ResolverRequestLanguageSupportFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverRequestLanguageSupportFuncCall is an object that describes an
// invocation of method RequestLanguageSupport on an instance of
// MockResolver.
type ResolverRequestLanguageSupportFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverRequestLanguageSupportFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverRequestLanguageSupportFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// ResolverRequestedLanguageSupportFunc describes the behavior when the
// RequestedLanguageSupport method of the parent MockResolver instance is
// invoked.
type ResolverRequestedLanguageSupportFunc struct {
	defaultHook func(context.Context, int) ([]string, error)
	hooks       []func(context.Context, int) ([]string, error)
	history     []ResolverRequestedLanguageSupportFuncCall
	mutex       sync.Mutex
}

// RequestedLanguageSupport delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockResolver) RequestedLanguageSupport(v0 context.Context, v1 int) ([]string, error) {
	r0, r1 := m.RequestedLanguageSupportFunc.nextHook()(v0, v1)
	m.RequestedLanguageSupportFunc.appendCall(ResolverRequestedLanguageSupportFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// RequestedLanguageSupport method of the parent MockResolver instance is
// invoked and the hook queue is empty.
func (f *ResolverRequestedLanguageSupportFunc) SetDefaultHook(hook func(context.Context, int) ([]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RequestedLanguageSupport method of the parent MockResolver instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *ResolverRequestedLanguageSupportFunc) PushHook(hook func(context.Context, int) ([]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverRequestedLanguageSupportFunc) SetDefaultReturn(r0 []string, r1 error) {
	f.SetDefaultHook(func(context.Context, int) ([]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverRequestedLanguageSupportFunc) PushReturn(r0 []string, r1 error) {
	f.PushHook(func(context.Context, int) ([]string, error) {
		return r0, r1
	})
}

func (f *ResolverRequestedLanguageSupportFunc) nextHook() func(context.Context, int) ([]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverRequestedLanguageSupportFunc) appendCall(r0 ResolverRequestedLanguageSupportFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverRequestedLanguageSupportFuncCall
// objects describing the invocations of this function.
func (f *ResolverRequestedLanguageSupportFunc) History() []ResolverRequestedLanguageSupportFuncCall {
	f.mutex.Lock()
	history := make([]ResolverRequestedLanguageSupportFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverRequestedLanguageSupportFuncCall is an object that describes an
// invocation of method RequestedLanguageSupport on an instance of
// MockResolver.
type ResolverRequestedLanguageSupportFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverRequestedLanguageSupportFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverRequestedLanguageSupportFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// ResolverSupportedByCtagsFunc describes the behavior when the
// SupportedByCtags method of the parent MockResolver instance is invoked.
type ResolverSupportedByCtagsFunc struct {
	defaultHook func(context.Context, string, api.RepoName) (bool, string, error)
	hooks       []func(context.Context, string, api.RepoName) (bool, string, error)
	history     []ResolverSupportedByCtagsFuncCall
	mutex       sync.Mutex
}

// SupportedByCtags delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockResolver) SupportedByCtags(v0 context.Context, v1 string, v2 api.RepoName) (bool, string, error) {
	r0, r1, r2 := m.SupportedByCtagsFunc.nextHook()(v0, v1, v2)
	m.SupportedByCtagsFunc.appendCall(ResolverSupportedByCtagsFuncCall{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the SupportedByCtags
// method of the parent MockResolver instance is invoked and the hook queue
// is empty.
func (f *ResolverSupportedByCtagsFunc) SetDefaultHook(hook func(context.Context, string, api.RepoName) (bool, string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SupportedByCtags method of the parent MockResolver instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ResolverSupportedByCtagsFunc) PushHook(hook func(context.Context, string, api.RepoName) (bool, string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverSupportedByCtagsFunc) SetDefaultReturn(r0 bool, r1 string, r2 error) {
	f.SetDefaultHook(func(context.Context, string, api.RepoName) (bool, string, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverSupportedByCtagsFunc) PushReturn(r0 bool, r1 string, r2 error) {
	f.PushHook(func(context.Context, string, api.RepoName) (bool, string, error) {
		return r0, r1, r2
	})
}

func (f *ResolverSupportedByCtagsFunc) nextHook() func(context.Context, string, api.RepoName) (bool, string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverSupportedByCtagsFunc) appendCall(r0 ResolverSupportedByCtagsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverSupportedByCtagsFuncCall objects
// describing the invocations of this function.
func (f *ResolverSupportedByCtagsFunc) History() []ResolverSupportedByCtagsFuncCall {
	f.mutex.Lock()
	history := make([]ResolverSupportedByCtagsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverSupportedByCtagsFuncCall is an object that describes an
// invocation of method SupportedByCtags on an instance of MockResolver.
type ResolverSupportedByCtagsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 api.RepoName
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 string
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverSupportedByCtagsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverSupportedByCtagsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// ResolverUploadConnectionResolverFunc describes the behavior when the
// UploadConnectionResolver method of the parent MockResolver instance is
// invoked.
type ResolverUploadConnectionResolverFunc struct {
	defaultHook func(dbstore.GetUploadsOptions) *resolvers.UploadsResolver
	hooks       []func(dbstore.GetUploadsOptions) *resolvers.UploadsResolver
	history     []ResolverUploadConnectionResolverFuncCall
	mutex       sync.Mutex
}

// UploadConnectionResolver delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockResolver) UploadConnectionResolver(v0 dbstore.GetUploadsOptions) *resolvers.UploadsResolver {
	r0 := m.UploadConnectionResolverFunc.nextHook()(v0)
	m.UploadConnectionResolverFunc.appendCall(ResolverUploadConnectionResolverFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UploadConnectionResolver method of the parent MockResolver instance is
// invoked and the hook queue is empty.
func (f *ResolverUploadConnectionResolverFunc) SetDefaultHook(hook func(dbstore.GetUploadsOptions) *resolvers.UploadsResolver) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UploadConnectionResolver method of the parent MockResolver instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *ResolverUploadConnectionResolverFunc) PushHook(hook func(dbstore.GetUploadsOptions) *resolvers.UploadsResolver) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ResolverUploadConnectionResolverFunc) SetDefaultReturn(r0 *resolvers.UploadsResolver) {
	f.SetDefaultHook(func(dbstore.GetUploadsOptions) *resolvers.UploadsResolver {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ResolverUploadConnectionResolverFunc) PushReturn(r0 *resolvers.UploadsResolver) {
	f.PushHook(func(dbstore.GetUploadsOptions) *resolvers.UploadsResolver {
		return r0
	})
}

func (f *ResolverUploadConnectionResolverFunc) nextHook() func(dbstore.GetUploadsOptions) *resolvers.UploadsResolver {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ResolverUploadConnectionResolverFunc) appendCall(r0 ResolverUploadConnectionResolverFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ResolverUploadConnectionResolverFuncCall
// objects describing the invocations of this function.
func (f *ResolverUploadConnectionResolverFunc) History() []ResolverUploadConnectionResolverFuncCall {
	f.mutex.Lock()
	history := make([]ResolverUploadConnectionResolverFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ResolverUploadConnectionResolverFuncCall is an object that describes an
// invocation of method UploadConnectionResolver on an instance of
// MockResolver.
type ResolverUploadConnectionResolverFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 dbstore.GetUploadsOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *resolvers.UploadsResolver
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ResolverUploadConnectionResolverFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ResolverUploadConnectionResolverFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}
