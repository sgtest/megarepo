// Code generated by github.com/efritz/go-mockgen 0.1.0; DO NOT EDIT.

package resolvers

import (
	"context"
	api "github.com/sourcegraph/sourcegraph/enterprise/cmd/frontend/internal/codeintel/api"
	dbstore "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/stores/dbstore"
	lsifstore "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/stores/lsifstore"
	"sync"
)

// MockCodeIntelAPI is a mock implementation of the CodeIntelAPI interface
// (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/frontend/internal/codeintel/resolvers)
// used for unit testing.
type MockCodeIntelAPI struct {
	// DefinitionsFunc is an instance of a mock function object controlling
	// the behavior of the method Definitions.
	DefinitionsFunc *CodeIntelAPIDefinitionsFunc
	// DiagnosticsFunc is an instance of a mock function object controlling
	// the behavior of the method Diagnostics.
	DiagnosticsFunc *CodeIntelAPIDiagnosticsFunc
	// FindClosestDumpsFunc is an instance of a mock function object
	// controlling the behavior of the method FindClosestDumps.
	FindClosestDumpsFunc *CodeIntelAPIFindClosestDumpsFunc
	// HoverFunc is an instance of a mock function object controlling the
	// behavior of the method Hover.
	HoverFunc *CodeIntelAPIHoverFunc
	// RangesFunc is an instance of a mock function object controlling the
	// behavior of the method Ranges.
	RangesFunc *CodeIntelAPIRangesFunc
	// ReferencesFunc is an instance of a mock function object controlling
	// the behavior of the method References.
	ReferencesFunc *CodeIntelAPIReferencesFunc
}

// NewMockCodeIntelAPI creates a new mock of the CodeIntelAPI interface. All
// methods return zero values for all results, unless overwritten.
func NewMockCodeIntelAPI() *MockCodeIntelAPI {
	return &MockCodeIntelAPI{
		DefinitionsFunc: &CodeIntelAPIDefinitionsFunc{
			defaultHook: func(context.Context, string, int, int, int) ([]api.ResolvedLocation, error) {
				return nil, nil
			},
		},
		DiagnosticsFunc: &CodeIntelAPIDiagnosticsFunc{
			defaultHook: func(context.Context, string, int, int, int) ([]api.ResolvedDiagnostic, int, error) {
				return nil, 0, nil
			},
		},
		FindClosestDumpsFunc: &CodeIntelAPIFindClosestDumpsFunc{
			defaultHook: func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error) {
				return nil, nil
			},
		},
		HoverFunc: &CodeIntelAPIHoverFunc{
			defaultHook: func(context.Context, string, int, int, int) (string, lsifstore.Range, bool, error) {
				return "", lsifstore.Range{}, false, nil
			},
		},
		RangesFunc: &CodeIntelAPIRangesFunc{
			defaultHook: func(context.Context, string, int, int, int) ([]api.ResolvedCodeIntelligenceRange, error) {
				return nil, nil
			},
		},
		ReferencesFunc: &CodeIntelAPIReferencesFunc{
			defaultHook: func(context.Context, int, string, int, api.Cursor) ([]api.ResolvedLocation, api.Cursor, bool, error) {
				return nil, api.Cursor{}, false, nil
			},
		},
	}
}

// NewMockCodeIntelAPIFrom creates a new mock of the MockCodeIntelAPI
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockCodeIntelAPIFrom(i CodeIntelAPI) *MockCodeIntelAPI {
	return &MockCodeIntelAPI{
		DefinitionsFunc: &CodeIntelAPIDefinitionsFunc{
			defaultHook: i.Definitions,
		},
		DiagnosticsFunc: &CodeIntelAPIDiagnosticsFunc{
			defaultHook: i.Diagnostics,
		},
		FindClosestDumpsFunc: &CodeIntelAPIFindClosestDumpsFunc{
			defaultHook: i.FindClosestDumps,
		},
		HoverFunc: &CodeIntelAPIHoverFunc{
			defaultHook: i.Hover,
		},
		RangesFunc: &CodeIntelAPIRangesFunc{
			defaultHook: i.Ranges,
		},
		ReferencesFunc: &CodeIntelAPIReferencesFunc{
			defaultHook: i.References,
		},
	}
}

// CodeIntelAPIDefinitionsFunc describes the behavior when the Definitions
// method of the parent MockCodeIntelAPI instance is invoked.
type CodeIntelAPIDefinitionsFunc struct {
	defaultHook func(context.Context, string, int, int, int) ([]api.ResolvedLocation, error)
	hooks       []func(context.Context, string, int, int, int) ([]api.ResolvedLocation, error)
	history     []CodeIntelAPIDefinitionsFuncCall
	mutex       sync.Mutex
}

// Definitions delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockCodeIntelAPI) Definitions(v0 context.Context, v1 string, v2 int, v3 int, v4 int) ([]api.ResolvedLocation, error) {
	r0, r1 := m.DefinitionsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.DefinitionsFunc.appendCall(CodeIntelAPIDefinitionsFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Definitions method
// of the parent MockCodeIntelAPI instance is invoked and the hook queue is
// empty.
func (f *CodeIntelAPIDefinitionsFunc) SetDefaultHook(hook func(context.Context, string, int, int, int) ([]api.ResolvedLocation, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Definitions method of the parent MockCodeIntelAPI instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *CodeIntelAPIDefinitionsFunc) PushHook(hook func(context.Context, string, int, int, int) ([]api.ResolvedLocation, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *CodeIntelAPIDefinitionsFunc) SetDefaultReturn(r0 []api.ResolvedLocation, r1 error) {
	f.SetDefaultHook(func(context.Context, string, int, int, int) ([]api.ResolvedLocation, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *CodeIntelAPIDefinitionsFunc) PushReturn(r0 []api.ResolvedLocation, r1 error) {
	f.PushHook(func(context.Context, string, int, int, int) ([]api.ResolvedLocation, error) {
		return r0, r1
	})
}

func (f *CodeIntelAPIDefinitionsFunc) nextHook() func(context.Context, string, int, int, int) ([]api.ResolvedLocation, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *CodeIntelAPIDefinitionsFunc) appendCall(r0 CodeIntelAPIDefinitionsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of CodeIntelAPIDefinitionsFuncCall objects
// describing the invocations of this function.
func (f *CodeIntelAPIDefinitionsFunc) History() []CodeIntelAPIDefinitionsFuncCall {
	f.mutex.Lock()
	history := make([]CodeIntelAPIDefinitionsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// CodeIntelAPIDefinitionsFuncCall is an object that describes an invocation
// of method Definitions on an instance of MockCodeIntelAPI.
type CodeIntelAPIDefinitionsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []api.ResolvedLocation
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c CodeIntelAPIDefinitionsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c CodeIntelAPIDefinitionsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// CodeIntelAPIDiagnosticsFunc describes the behavior when the Diagnostics
// method of the parent MockCodeIntelAPI instance is invoked.
type CodeIntelAPIDiagnosticsFunc struct {
	defaultHook func(context.Context, string, int, int, int) ([]api.ResolvedDiagnostic, int, error)
	hooks       []func(context.Context, string, int, int, int) ([]api.ResolvedDiagnostic, int, error)
	history     []CodeIntelAPIDiagnosticsFuncCall
	mutex       sync.Mutex
}

// Diagnostics delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockCodeIntelAPI) Diagnostics(v0 context.Context, v1 string, v2 int, v3 int, v4 int) ([]api.ResolvedDiagnostic, int, error) {
	r0, r1, r2 := m.DiagnosticsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.DiagnosticsFunc.appendCall(CodeIntelAPIDiagnosticsFuncCall{v0, v1, v2, v3, v4, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Diagnostics method
// of the parent MockCodeIntelAPI instance is invoked and the hook queue is
// empty.
func (f *CodeIntelAPIDiagnosticsFunc) SetDefaultHook(hook func(context.Context, string, int, int, int) ([]api.ResolvedDiagnostic, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Diagnostics method of the parent MockCodeIntelAPI instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *CodeIntelAPIDiagnosticsFunc) PushHook(hook func(context.Context, string, int, int, int) ([]api.ResolvedDiagnostic, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *CodeIntelAPIDiagnosticsFunc) SetDefaultReturn(r0 []api.ResolvedDiagnostic, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, string, int, int, int) ([]api.ResolvedDiagnostic, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *CodeIntelAPIDiagnosticsFunc) PushReturn(r0 []api.ResolvedDiagnostic, r1 int, r2 error) {
	f.PushHook(func(context.Context, string, int, int, int) ([]api.ResolvedDiagnostic, int, error) {
		return r0, r1, r2
	})
}

func (f *CodeIntelAPIDiagnosticsFunc) nextHook() func(context.Context, string, int, int, int) ([]api.ResolvedDiagnostic, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *CodeIntelAPIDiagnosticsFunc) appendCall(r0 CodeIntelAPIDiagnosticsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of CodeIntelAPIDiagnosticsFuncCall objects
// describing the invocations of this function.
func (f *CodeIntelAPIDiagnosticsFunc) History() []CodeIntelAPIDiagnosticsFuncCall {
	f.mutex.Lock()
	history := make([]CodeIntelAPIDiagnosticsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// CodeIntelAPIDiagnosticsFuncCall is an object that describes an invocation
// of method Diagnostics on an instance of MockCodeIntelAPI.
type CodeIntelAPIDiagnosticsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []api.ResolvedDiagnostic
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c CodeIntelAPIDiagnosticsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c CodeIntelAPIDiagnosticsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// CodeIntelAPIFindClosestDumpsFunc describes the behavior when the
// FindClosestDumps method of the parent MockCodeIntelAPI instance is
// invoked.
type CodeIntelAPIFindClosestDumpsFunc struct {
	defaultHook func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error)
	hooks       []func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error)
	history     []CodeIntelAPIFindClosestDumpsFuncCall
	mutex       sync.Mutex
}

// FindClosestDumps delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockCodeIntelAPI) FindClosestDumps(v0 context.Context, v1 int, v2 string, v3 string, v4 bool, v5 string) ([]dbstore.Dump, error) {
	r0, r1 := m.FindClosestDumpsFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.FindClosestDumpsFunc.appendCall(CodeIntelAPIFindClosestDumpsFuncCall{v0, v1, v2, v3, v4, v5, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the FindClosestDumps
// method of the parent MockCodeIntelAPI instance is invoked and the hook
// queue is empty.
func (f *CodeIntelAPIFindClosestDumpsFunc) SetDefaultHook(hook func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// FindClosestDumps method of the parent MockCodeIntelAPI instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *CodeIntelAPIFindClosestDumpsFunc) PushHook(hook func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *CodeIntelAPIFindClosestDumpsFunc) SetDefaultReturn(r0 []dbstore.Dump, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *CodeIntelAPIFindClosestDumpsFunc) PushReturn(r0 []dbstore.Dump, r1 error) {
	f.PushHook(func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error) {
		return r0, r1
	})
}

func (f *CodeIntelAPIFindClosestDumpsFunc) nextHook() func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *CodeIntelAPIFindClosestDumpsFunc) appendCall(r0 CodeIntelAPIFindClosestDumpsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of CodeIntelAPIFindClosestDumpsFuncCall
// objects describing the invocations of this function.
func (f *CodeIntelAPIFindClosestDumpsFunc) History() []CodeIntelAPIFindClosestDumpsFuncCall {
	f.mutex.Lock()
	history := make([]CodeIntelAPIFindClosestDumpsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// CodeIntelAPIFindClosestDumpsFuncCall is an object that describes an
// invocation of method FindClosestDumps on an instance of MockCodeIntelAPI.
type CodeIntelAPIFindClosestDumpsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 bool
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c CodeIntelAPIFindClosestDumpsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c CodeIntelAPIFindClosestDumpsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// CodeIntelAPIHoverFunc describes the behavior when the Hover method of the
// parent MockCodeIntelAPI instance is invoked.
type CodeIntelAPIHoverFunc struct {
	defaultHook func(context.Context, string, int, int, int) (string, lsifstore.Range, bool, error)
	hooks       []func(context.Context, string, int, int, int) (string, lsifstore.Range, bool, error)
	history     []CodeIntelAPIHoverFuncCall
	mutex       sync.Mutex
}

// Hover delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockCodeIntelAPI) Hover(v0 context.Context, v1 string, v2 int, v3 int, v4 int) (string, lsifstore.Range, bool, error) {
	r0, r1, r2, r3 := m.HoverFunc.nextHook()(v0, v1, v2, v3, v4)
	m.HoverFunc.appendCall(CodeIntelAPIHoverFuncCall{v0, v1, v2, v3, v4, r0, r1, r2, r3})
	return r0, r1, r2, r3
}

// SetDefaultHook sets function that is called when the Hover method of the
// parent MockCodeIntelAPI instance is invoked and the hook queue is empty.
func (f *CodeIntelAPIHoverFunc) SetDefaultHook(hook func(context.Context, string, int, int, int) (string, lsifstore.Range, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Hover method of the parent MockCodeIntelAPI instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *CodeIntelAPIHoverFunc) PushHook(hook func(context.Context, string, int, int, int) (string, lsifstore.Range, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *CodeIntelAPIHoverFunc) SetDefaultReturn(r0 string, r1 lsifstore.Range, r2 bool, r3 error) {
	f.SetDefaultHook(func(context.Context, string, int, int, int) (string, lsifstore.Range, bool, error) {
		return r0, r1, r2, r3
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *CodeIntelAPIHoverFunc) PushReturn(r0 string, r1 lsifstore.Range, r2 bool, r3 error) {
	f.PushHook(func(context.Context, string, int, int, int) (string, lsifstore.Range, bool, error) {
		return r0, r1, r2, r3
	})
}

func (f *CodeIntelAPIHoverFunc) nextHook() func(context.Context, string, int, int, int) (string, lsifstore.Range, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *CodeIntelAPIHoverFunc) appendCall(r0 CodeIntelAPIHoverFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of CodeIntelAPIHoverFuncCall objects
// describing the invocations of this function.
func (f *CodeIntelAPIHoverFunc) History() []CodeIntelAPIHoverFuncCall {
	f.mutex.Lock()
	history := make([]CodeIntelAPIHoverFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// CodeIntelAPIHoverFuncCall is an object that describes an invocation of
// method Hover on an instance of MockCodeIntelAPI.
type CodeIntelAPIHoverFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 lsifstore.Range
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 bool
	// Result3 is the value of the 4th result returned from this method
	// invocation.
	Result3 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c CodeIntelAPIHoverFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c CodeIntelAPIHoverFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2, c.Result3}
}

// CodeIntelAPIRangesFunc describes the behavior when the Ranges method of
// the parent MockCodeIntelAPI instance is invoked.
type CodeIntelAPIRangesFunc struct {
	defaultHook func(context.Context, string, int, int, int) ([]api.ResolvedCodeIntelligenceRange, error)
	hooks       []func(context.Context, string, int, int, int) ([]api.ResolvedCodeIntelligenceRange, error)
	history     []CodeIntelAPIRangesFuncCall
	mutex       sync.Mutex
}

// Ranges delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockCodeIntelAPI) Ranges(v0 context.Context, v1 string, v2 int, v3 int, v4 int) ([]api.ResolvedCodeIntelligenceRange, error) {
	r0, r1 := m.RangesFunc.nextHook()(v0, v1, v2, v3, v4)
	m.RangesFunc.appendCall(CodeIntelAPIRangesFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Ranges method of the
// parent MockCodeIntelAPI instance is invoked and the hook queue is empty.
func (f *CodeIntelAPIRangesFunc) SetDefaultHook(hook func(context.Context, string, int, int, int) ([]api.ResolvedCodeIntelligenceRange, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Ranges method of the parent MockCodeIntelAPI instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *CodeIntelAPIRangesFunc) PushHook(hook func(context.Context, string, int, int, int) ([]api.ResolvedCodeIntelligenceRange, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *CodeIntelAPIRangesFunc) SetDefaultReturn(r0 []api.ResolvedCodeIntelligenceRange, r1 error) {
	f.SetDefaultHook(func(context.Context, string, int, int, int) ([]api.ResolvedCodeIntelligenceRange, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *CodeIntelAPIRangesFunc) PushReturn(r0 []api.ResolvedCodeIntelligenceRange, r1 error) {
	f.PushHook(func(context.Context, string, int, int, int) ([]api.ResolvedCodeIntelligenceRange, error) {
		return r0, r1
	})
}

func (f *CodeIntelAPIRangesFunc) nextHook() func(context.Context, string, int, int, int) ([]api.ResolvedCodeIntelligenceRange, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *CodeIntelAPIRangesFunc) appendCall(r0 CodeIntelAPIRangesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of CodeIntelAPIRangesFuncCall objects
// describing the invocations of this function.
func (f *CodeIntelAPIRangesFunc) History() []CodeIntelAPIRangesFuncCall {
	f.mutex.Lock()
	history := make([]CodeIntelAPIRangesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// CodeIntelAPIRangesFuncCall is an object that describes an invocation of
// method Ranges on an instance of MockCodeIntelAPI.
type CodeIntelAPIRangesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []api.ResolvedCodeIntelligenceRange
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c CodeIntelAPIRangesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c CodeIntelAPIRangesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// CodeIntelAPIReferencesFunc describes the behavior when the References
// method of the parent MockCodeIntelAPI instance is invoked.
type CodeIntelAPIReferencesFunc struct {
	defaultHook func(context.Context, int, string, int, api.Cursor) ([]api.ResolvedLocation, api.Cursor, bool, error)
	hooks       []func(context.Context, int, string, int, api.Cursor) ([]api.ResolvedLocation, api.Cursor, bool, error)
	history     []CodeIntelAPIReferencesFuncCall
	mutex       sync.Mutex
}

// References delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockCodeIntelAPI) References(v0 context.Context, v1 int, v2 string, v3 int, v4 api.Cursor) ([]api.ResolvedLocation, api.Cursor, bool, error) {
	r0, r1, r2, r3 := m.ReferencesFunc.nextHook()(v0, v1, v2, v3, v4)
	m.ReferencesFunc.appendCall(CodeIntelAPIReferencesFuncCall{v0, v1, v2, v3, v4, r0, r1, r2, r3})
	return r0, r1, r2, r3
}

// SetDefaultHook sets function that is called when the References method of
// the parent MockCodeIntelAPI instance is invoked and the hook queue is
// empty.
func (f *CodeIntelAPIReferencesFunc) SetDefaultHook(hook func(context.Context, int, string, int, api.Cursor) ([]api.ResolvedLocation, api.Cursor, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// References method of the parent MockCodeIntelAPI instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *CodeIntelAPIReferencesFunc) PushHook(hook func(context.Context, int, string, int, api.Cursor) ([]api.ResolvedLocation, api.Cursor, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *CodeIntelAPIReferencesFunc) SetDefaultReturn(r0 []api.ResolvedLocation, r1 api.Cursor, r2 bool, r3 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, api.Cursor) ([]api.ResolvedLocation, api.Cursor, bool, error) {
		return r0, r1, r2, r3
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *CodeIntelAPIReferencesFunc) PushReturn(r0 []api.ResolvedLocation, r1 api.Cursor, r2 bool, r3 error) {
	f.PushHook(func(context.Context, int, string, int, api.Cursor) ([]api.ResolvedLocation, api.Cursor, bool, error) {
		return r0, r1, r2, r3
	})
}

func (f *CodeIntelAPIReferencesFunc) nextHook() func(context.Context, int, string, int, api.Cursor) ([]api.ResolvedLocation, api.Cursor, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *CodeIntelAPIReferencesFunc) appendCall(r0 CodeIntelAPIReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of CodeIntelAPIReferencesFuncCall objects
// describing the invocations of this function.
func (f *CodeIntelAPIReferencesFunc) History() []CodeIntelAPIReferencesFuncCall {
	f.mutex.Lock()
	history := make([]CodeIntelAPIReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// CodeIntelAPIReferencesFuncCall is an object that describes an invocation
// of method References on an instance of MockCodeIntelAPI.
type CodeIntelAPIReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 api.Cursor
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []api.ResolvedLocation
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 api.Cursor
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 bool
	// Result3 is the value of the 4th result returned from this method
	// invocation.
	Result3 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c CodeIntelAPIReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c CodeIntelAPIReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2, c.Result3}
}

// MockDBStore is a mock implementation of the DBStore interface (from the
// package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/frontend/internal/codeintel/resolvers)
// used for unit testing.
type MockDBStore struct {
	// DeleteIndexByIDFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteIndexByID.
	DeleteIndexByIDFunc *DBStoreDeleteIndexByIDFunc
	// DeleteUploadByIDFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteUploadByID.
	DeleteUploadByIDFunc *DBStoreDeleteUploadByIDFunc
	// FindClosestDumpsFunc is an instance of a mock function object
	// controlling the behavior of the method FindClosestDumps.
	FindClosestDumpsFunc *DBStoreFindClosestDumpsFunc
	// FindClosestDumpsFromGraphFragmentFunc is an instance of a mock
	// function object controlling the behavior of the method
	// FindClosestDumpsFromGraphFragment.
	FindClosestDumpsFromGraphFragmentFunc *DBStoreFindClosestDumpsFromGraphFragmentFunc
	// GetDumpByIDFunc is an instance of a mock function object controlling
	// the behavior of the method GetDumpByID.
	GetDumpByIDFunc *DBStoreGetDumpByIDFunc
	// GetIndexByIDFunc is an instance of a mock function object controlling
	// the behavior of the method GetIndexByID.
	GetIndexByIDFunc *DBStoreGetIndexByIDFunc
	// GetIndexesFunc is an instance of a mock function object controlling
	// the behavior of the method GetIndexes.
	GetIndexesFunc *DBStoreGetIndexesFunc
	// GetPackageFunc is an instance of a mock function object controlling
	// the behavior of the method GetPackage.
	GetPackageFunc *DBStoreGetPackageFunc
	// GetUploadByIDFunc is an instance of a mock function object
	// controlling the behavior of the method GetUploadByID.
	GetUploadByIDFunc *DBStoreGetUploadByIDFunc
	// GetUploadsFunc is an instance of a mock function object controlling
	// the behavior of the method GetUploads.
	GetUploadsFunc *DBStoreGetUploadsFunc
	// HasCommitFunc is an instance of a mock function object controlling
	// the behavior of the method HasCommit.
	HasCommitFunc *DBStoreHasCommitFunc
	// HasRepositoryFunc is an instance of a mock function object
	// controlling the behavior of the method HasRepository.
	HasRepositoryFunc *DBStoreHasRepositoryFunc
	// MarkRepositoryAsDirtyFunc is an instance of a mock function object
	// controlling the behavior of the method MarkRepositoryAsDirty.
	MarkRepositoryAsDirtyFunc *DBStoreMarkRepositoryAsDirtyFunc
	// PackageReferencePagerFunc is an instance of a mock function object
	// controlling the behavior of the method PackageReferencePager.
	PackageReferencePagerFunc *DBStorePackageReferencePagerFunc
	// RepoNameFunc is an instance of a mock function object controlling the
	// behavior of the method RepoName.
	RepoNameFunc *DBStoreRepoNameFunc
	// SameRepoPagerFunc is an instance of a mock function object
	// controlling the behavior of the method SameRepoPager.
	SameRepoPagerFunc *DBStoreSameRepoPagerFunc
}

// NewMockDBStore creates a new mock of the DBStore interface. All methods
// return zero values for all results, unless overwritten.
func NewMockDBStore() *MockDBStore {
	return &MockDBStore{
		DeleteIndexByIDFunc: &DBStoreDeleteIndexByIDFunc{
			defaultHook: func(context.Context, int) (bool, error) {
				return false, nil
			},
		},
		DeleteUploadByIDFunc: &DBStoreDeleteUploadByIDFunc{
			defaultHook: func(context.Context, int) (bool, error) {
				return false, nil
			},
		},
		FindClosestDumpsFunc: &DBStoreFindClosestDumpsFunc{
			defaultHook: func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error) {
				return nil, nil
			},
		},
		FindClosestDumpsFromGraphFragmentFunc: &DBStoreFindClosestDumpsFromGraphFragmentFunc{
			defaultHook: func(context.Context, int, string, string, bool, string, map[string][]string) ([]dbstore.Dump, error) {
				return nil, nil
			},
		},
		GetDumpByIDFunc: &DBStoreGetDumpByIDFunc{
			defaultHook: func(context.Context, int) (dbstore.Dump, bool, error) {
				return dbstore.Dump{}, false, nil
			},
		},
		GetIndexByIDFunc: &DBStoreGetIndexByIDFunc{
			defaultHook: func(context.Context, int) (dbstore.Index, bool, error) {
				return dbstore.Index{}, false, nil
			},
		},
		GetIndexesFunc: &DBStoreGetIndexesFunc{
			defaultHook: func(context.Context, dbstore.GetIndexesOptions) ([]dbstore.Index, int, error) {
				return nil, 0, nil
			},
		},
		GetPackageFunc: &DBStoreGetPackageFunc{
			defaultHook: func(context.Context, string, string, string) (dbstore.Dump, bool, error) {
				return dbstore.Dump{}, false, nil
			},
		},
		GetUploadByIDFunc: &DBStoreGetUploadByIDFunc{
			defaultHook: func(context.Context, int) (dbstore.Upload, bool, error) {
				return dbstore.Upload{}, false, nil
			},
		},
		GetUploadsFunc: &DBStoreGetUploadsFunc{
			defaultHook: func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error) {
				return nil, 0, nil
			},
		},
		HasCommitFunc: &DBStoreHasCommitFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				return false, nil
			},
		},
		HasRepositoryFunc: &DBStoreHasRepositoryFunc{
			defaultHook: func(context.Context, int) (bool, error) {
				return false, nil
			},
		},
		MarkRepositoryAsDirtyFunc: &DBStoreMarkRepositoryAsDirtyFunc{
			defaultHook: func(context.Context, int) error {
				return nil
			},
		},
		PackageReferencePagerFunc: &DBStorePackageReferencePagerFunc{
			defaultHook: func(context.Context, string, string, string, int, int) (int, api.ReferencePager, error) {
				return 0, nil, nil
			},
		},
		RepoNameFunc: &DBStoreRepoNameFunc{
			defaultHook: func(context.Context, int) (string, error) {
				return "", nil
			},
		},
		SameRepoPagerFunc: &DBStoreSameRepoPagerFunc{
			defaultHook: func(context.Context, int, string, string, string, string, int) (int, api.ReferencePager, error) {
				return 0, nil, nil
			},
		},
	}
}

// NewMockDBStoreFrom creates a new mock of the MockDBStore interface. All
// methods delegate to the given implementation, unless overwritten.
func NewMockDBStoreFrom(i DBStore) *MockDBStore {
	return &MockDBStore{
		DeleteIndexByIDFunc: &DBStoreDeleteIndexByIDFunc{
			defaultHook: i.DeleteIndexByID,
		},
		DeleteUploadByIDFunc: &DBStoreDeleteUploadByIDFunc{
			defaultHook: i.DeleteUploadByID,
		},
		FindClosestDumpsFunc: &DBStoreFindClosestDumpsFunc{
			defaultHook: i.FindClosestDumps,
		},
		FindClosestDumpsFromGraphFragmentFunc: &DBStoreFindClosestDumpsFromGraphFragmentFunc{
			defaultHook: i.FindClosestDumpsFromGraphFragment,
		},
		GetDumpByIDFunc: &DBStoreGetDumpByIDFunc{
			defaultHook: i.GetDumpByID,
		},
		GetIndexByIDFunc: &DBStoreGetIndexByIDFunc{
			defaultHook: i.GetIndexByID,
		},
		GetIndexesFunc: &DBStoreGetIndexesFunc{
			defaultHook: i.GetIndexes,
		},
		GetPackageFunc: &DBStoreGetPackageFunc{
			defaultHook: i.GetPackage,
		},
		GetUploadByIDFunc: &DBStoreGetUploadByIDFunc{
			defaultHook: i.GetUploadByID,
		},
		GetUploadsFunc: &DBStoreGetUploadsFunc{
			defaultHook: i.GetUploads,
		},
		HasCommitFunc: &DBStoreHasCommitFunc{
			defaultHook: i.HasCommit,
		},
		HasRepositoryFunc: &DBStoreHasRepositoryFunc{
			defaultHook: i.HasRepository,
		},
		MarkRepositoryAsDirtyFunc: &DBStoreMarkRepositoryAsDirtyFunc{
			defaultHook: i.MarkRepositoryAsDirty,
		},
		PackageReferencePagerFunc: &DBStorePackageReferencePagerFunc{
			defaultHook: i.PackageReferencePager,
		},
		RepoNameFunc: &DBStoreRepoNameFunc{
			defaultHook: i.RepoName,
		},
		SameRepoPagerFunc: &DBStoreSameRepoPagerFunc{
			defaultHook: i.SameRepoPager,
		},
	}
}

// DBStoreDeleteIndexByIDFunc describes the behavior when the
// DeleteIndexByID method of the parent MockDBStore instance is invoked.
type DBStoreDeleteIndexByIDFunc struct {
	defaultHook func(context.Context, int) (bool, error)
	hooks       []func(context.Context, int) (bool, error)
	history     []DBStoreDeleteIndexByIDFuncCall
	mutex       sync.Mutex
}

// DeleteIndexByID delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) DeleteIndexByID(v0 context.Context, v1 int) (bool, error) {
	r0, r1 := m.DeleteIndexByIDFunc.nextHook()(v0, v1)
	m.DeleteIndexByIDFunc.appendCall(DBStoreDeleteIndexByIDFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DeleteIndexByID
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreDeleteIndexByIDFunc) SetDefaultHook(hook func(context.Context, int) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteIndexByID method of the parent MockDBStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *DBStoreDeleteIndexByIDFunc) PushHook(hook func(context.Context, int) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreDeleteIndexByIDFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreDeleteIndexByIDFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

func (f *DBStoreDeleteIndexByIDFunc) nextHook() func(context.Context, int) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreDeleteIndexByIDFunc) appendCall(r0 DBStoreDeleteIndexByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreDeleteIndexByIDFuncCall objects
// describing the invocations of this function.
func (f *DBStoreDeleteIndexByIDFunc) History() []DBStoreDeleteIndexByIDFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreDeleteIndexByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreDeleteIndexByIDFuncCall is an object that describes an invocation
// of method DeleteIndexByID on an instance of MockDBStore.
type DBStoreDeleteIndexByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreDeleteIndexByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreDeleteIndexByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreDeleteUploadByIDFunc describes the behavior when the
// DeleteUploadByID method of the parent MockDBStore instance is invoked.
type DBStoreDeleteUploadByIDFunc struct {
	defaultHook func(context.Context, int) (bool, error)
	hooks       []func(context.Context, int) (bool, error)
	history     []DBStoreDeleteUploadByIDFuncCall
	mutex       sync.Mutex
}

// DeleteUploadByID delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) DeleteUploadByID(v0 context.Context, v1 int) (bool, error) {
	r0, r1 := m.DeleteUploadByIDFunc.nextHook()(v0, v1)
	m.DeleteUploadByIDFunc.appendCall(DBStoreDeleteUploadByIDFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DeleteUploadByID
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreDeleteUploadByIDFunc) SetDefaultHook(hook func(context.Context, int) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteUploadByID method of the parent MockDBStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *DBStoreDeleteUploadByIDFunc) PushHook(hook func(context.Context, int) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreDeleteUploadByIDFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreDeleteUploadByIDFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

func (f *DBStoreDeleteUploadByIDFunc) nextHook() func(context.Context, int) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreDeleteUploadByIDFunc) appendCall(r0 DBStoreDeleteUploadByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreDeleteUploadByIDFuncCall objects
// describing the invocations of this function.
func (f *DBStoreDeleteUploadByIDFunc) History() []DBStoreDeleteUploadByIDFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreDeleteUploadByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreDeleteUploadByIDFuncCall is an object that describes an invocation
// of method DeleteUploadByID on an instance of MockDBStore.
type DBStoreDeleteUploadByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreDeleteUploadByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreDeleteUploadByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreFindClosestDumpsFunc describes the behavior when the
// FindClosestDumps method of the parent MockDBStore instance is invoked.
type DBStoreFindClosestDumpsFunc struct {
	defaultHook func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error)
	hooks       []func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error)
	history     []DBStoreFindClosestDumpsFuncCall
	mutex       sync.Mutex
}

// FindClosestDumps delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) FindClosestDumps(v0 context.Context, v1 int, v2 string, v3 string, v4 bool, v5 string) ([]dbstore.Dump, error) {
	r0, r1 := m.FindClosestDumpsFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.FindClosestDumpsFunc.appendCall(DBStoreFindClosestDumpsFuncCall{v0, v1, v2, v3, v4, v5, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the FindClosestDumps
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreFindClosestDumpsFunc) SetDefaultHook(hook func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// FindClosestDumps method of the parent MockDBStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *DBStoreFindClosestDumpsFunc) PushHook(hook func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreFindClosestDumpsFunc) SetDefaultReturn(r0 []dbstore.Dump, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreFindClosestDumpsFunc) PushReturn(r0 []dbstore.Dump, r1 error) {
	f.PushHook(func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error) {
		return r0, r1
	})
}

func (f *DBStoreFindClosestDumpsFunc) nextHook() func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreFindClosestDumpsFunc) appendCall(r0 DBStoreFindClosestDumpsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreFindClosestDumpsFuncCall objects
// describing the invocations of this function.
func (f *DBStoreFindClosestDumpsFunc) History() []DBStoreFindClosestDumpsFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreFindClosestDumpsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreFindClosestDumpsFuncCall is an object that describes an invocation
// of method FindClosestDumps on an instance of MockDBStore.
type DBStoreFindClosestDumpsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 bool
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreFindClosestDumpsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreFindClosestDumpsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreFindClosestDumpsFromGraphFragmentFunc describes the behavior when
// the FindClosestDumpsFromGraphFragment method of the parent MockDBStore
// instance is invoked.
type DBStoreFindClosestDumpsFromGraphFragmentFunc struct {
	defaultHook func(context.Context, int, string, string, bool, string, map[string][]string) ([]dbstore.Dump, error)
	hooks       []func(context.Context, int, string, string, bool, string, map[string][]string) ([]dbstore.Dump, error)
	history     []DBStoreFindClosestDumpsFromGraphFragmentFuncCall
	mutex       sync.Mutex
}

// FindClosestDumpsFromGraphFragment delegates to the next hook function in
// the queue and stores the parameter and result values of this invocation.
func (m *MockDBStore) FindClosestDumpsFromGraphFragment(v0 context.Context, v1 int, v2 string, v3 string, v4 bool, v5 string, v6 map[string][]string) ([]dbstore.Dump, error) {
	r0, r1 := m.FindClosestDumpsFromGraphFragmentFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6)
	m.FindClosestDumpsFromGraphFragmentFunc.appendCall(DBStoreFindClosestDumpsFromGraphFragmentFuncCall{v0, v1, v2, v3, v4, v5, v6, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// FindClosestDumpsFromGraphFragment method of the parent MockDBStore
// instance is invoked and the hook queue is empty.
func (f *DBStoreFindClosestDumpsFromGraphFragmentFunc) SetDefaultHook(hook func(context.Context, int, string, string, bool, string, map[string][]string) ([]dbstore.Dump, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// FindClosestDumpsFromGraphFragment method of the parent MockDBStore
// instance inovkes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *DBStoreFindClosestDumpsFromGraphFragmentFunc) PushHook(hook func(context.Context, int, string, string, bool, string, map[string][]string) ([]dbstore.Dump, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreFindClosestDumpsFromGraphFragmentFunc) SetDefaultReturn(r0 []dbstore.Dump, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, bool, string, map[string][]string) ([]dbstore.Dump, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreFindClosestDumpsFromGraphFragmentFunc) PushReturn(r0 []dbstore.Dump, r1 error) {
	f.PushHook(func(context.Context, int, string, string, bool, string, map[string][]string) ([]dbstore.Dump, error) {
		return r0, r1
	})
}

func (f *DBStoreFindClosestDumpsFromGraphFragmentFunc) nextHook() func(context.Context, int, string, string, bool, string, map[string][]string) ([]dbstore.Dump, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreFindClosestDumpsFromGraphFragmentFunc) appendCall(r0 DBStoreFindClosestDumpsFromGraphFragmentFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// DBStoreFindClosestDumpsFromGraphFragmentFuncCall objects describing the
// invocations of this function.
func (f *DBStoreFindClosestDumpsFromGraphFragmentFunc) History() []DBStoreFindClosestDumpsFromGraphFragmentFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreFindClosestDumpsFromGraphFragmentFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreFindClosestDumpsFromGraphFragmentFuncCall is an object that
// describes an invocation of method FindClosestDumpsFromGraphFragment on an
// instance of MockDBStore.
type DBStoreFindClosestDumpsFromGraphFragmentFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 bool
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 string
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 map[string][]string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreFindClosestDumpsFromGraphFragmentFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreFindClosestDumpsFromGraphFragmentFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreGetDumpByIDFunc describes the behavior when the GetDumpByID method
// of the parent MockDBStore instance is invoked.
type DBStoreGetDumpByIDFunc struct {
	defaultHook func(context.Context, int) (dbstore.Dump, bool, error)
	hooks       []func(context.Context, int) (dbstore.Dump, bool, error)
	history     []DBStoreGetDumpByIDFuncCall
	mutex       sync.Mutex
}

// GetDumpByID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) GetDumpByID(v0 context.Context, v1 int) (dbstore.Dump, bool, error) {
	r0, r1, r2 := m.GetDumpByIDFunc.nextHook()(v0, v1)
	m.GetDumpByIDFunc.appendCall(DBStoreGetDumpByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetDumpByID method
// of the parent MockDBStore instance is invoked and the hook queue is
// empty.
func (f *DBStoreGetDumpByIDFunc) SetDefaultHook(hook func(context.Context, int) (dbstore.Dump, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetDumpByID method of the parent MockDBStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreGetDumpByIDFunc) PushHook(hook func(context.Context, int) (dbstore.Dump, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreGetDumpByIDFunc) SetDefaultReturn(r0 dbstore.Dump, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (dbstore.Dump, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreGetDumpByIDFunc) PushReturn(r0 dbstore.Dump, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (dbstore.Dump, bool, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreGetDumpByIDFunc) nextHook() func(context.Context, int) (dbstore.Dump, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetDumpByIDFunc) appendCall(r0 DBStoreGetDumpByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetDumpByIDFuncCall objects
// describing the invocations of this function.
func (f *DBStoreGetDumpByIDFunc) History() []DBStoreGetDumpByIDFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetDumpByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetDumpByIDFuncCall is an object that describes an invocation of
// method GetDumpByID on an instance of MockDBStore.
type DBStoreGetDumpByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 dbstore.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetDumpByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetDumpByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreGetIndexByIDFunc describes the behavior when the GetIndexByID
// method of the parent MockDBStore instance is invoked.
type DBStoreGetIndexByIDFunc struct {
	defaultHook func(context.Context, int) (dbstore.Index, bool, error)
	hooks       []func(context.Context, int) (dbstore.Index, bool, error)
	history     []DBStoreGetIndexByIDFuncCall
	mutex       sync.Mutex
}

// GetIndexByID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) GetIndexByID(v0 context.Context, v1 int) (dbstore.Index, bool, error) {
	r0, r1, r2 := m.GetIndexByIDFunc.nextHook()(v0, v1)
	m.GetIndexByIDFunc.appendCall(DBStoreGetIndexByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetIndexByID method
// of the parent MockDBStore instance is invoked and the hook queue is
// empty.
func (f *DBStoreGetIndexByIDFunc) SetDefaultHook(hook func(context.Context, int) (dbstore.Index, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexByID method of the parent MockDBStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreGetIndexByIDFunc) PushHook(hook func(context.Context, int) (dbstore.Index, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreGetIndexByIDFunc) SetDefaultReturn(r0 dbstore.Index, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (dbstore.Index, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreGetIndexByIDFunc) PushReturn(r0 dbstore.Index, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (dbstore.Index, bool, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreGetIndexByIDFunc) nextHook() func(context.Context, int) (dbstore.Index, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetIndexByIDFunc) appendCall(r0 DBStoreGetIndexByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetIndexByIDFuncCall objects
// describing the invocations of this function.
func (f *DBStoreGetIndexByIDFunc) History() []DBStoreGetIndexByIDFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetIndexByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetIndexByIDFuncCall is an object that describes an invocation of
// method GetIndexByID on an instance of MockDBStore.
type DBStoreGetIndexByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 dbstore.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetIndexByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetIndexByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreGetIndexesFunc describes the behavior when the GetIndexes method
// of the parent MockDBStore instance is invoked.
type DBStoreGetIndexesFunc struct {
	defaultHook func(context.Context, dbstore.GetIndexesOptions) ([]dbstore.Index, int, error)
	hooks       []func(context.Context, dbstore.GetIndexesOptions) ([]dbstore.Index, int, error)
	history     []DBStoreGetIndexesFuncCall
	mutex       sync.Mutex
}

// GetIndexes delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) GetIndexes(v0 context.Context, v1 dbstore.GetIndexesOptions) ([]dbstore.Index, int, error) {
	r0, r1, r2 := m.GetIndexesFunc.nextHook()(v0, v1)
	m.GetIndexesFunc.appendCall(DBStoreGetIndexesFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetIndexes method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreGetIndexesFunc) SetDefaultHook(hook func(context.Context, dbstore.GetIndexesOptions) ([]dbstore.Index, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexes method of the parent MockDBStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreGetIndexesFunc) PushHook(hook func(context.Context, dbstore.GetIndexesOptions) ([]dbstore.Index, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreGetIndexesFunc) SetDefaultReturn(r0 []dbstore.Index, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, dbstore.GetIndexesOptions) ([]dbstore.Index, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreGetIndexesFunc) PushReturn(r0 []dbstore.Index, r1 int, r2 error) {
	f.PushHook(func(context.Context, dbstore.GetIndexesOptions) ([]dbstore.Index, int, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreGetIndexesFunc) nextHook() func(context.Context, dbstore.GetIndexesOptions) ([]dbstore.Index, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetIndexesFunc) appendCall(r0 DBStoreGetIndexesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetIndexesFuncCall objects
// describing the invocations of this function.
func (f *DBStoreGetIndexesFunc) History() []DBStoreGetIndexesFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetIndexesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetIndexesFuncCall is an object that describes an invocation of
// method GetIndexes on an instance of MockDBStore.
type DBStoreGetIndexesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 dbstore.GetIndexesOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetIndexesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetIndexesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreGetPackageFunc describes the behavior when the GetPackage method
// of the parent MockDBStore instance is invoked.
type DBStoreGetPackageFunc struct {
	defaultHook func(context.Context, string, string, string) (dbstore.Dump, bool, error)
	hooks       []func(context.Context, string, string, string) (dbstore.Dump, bool, error)
	history     []DBStoreGetPackageFuncCall
	mutex       sync.Mutex
}

// GetPackage delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) GetPackage(v0 context.Context, v1 string, v2 string, v3 string) (dbstore.Dump, bool, error) {
	r0, r1, r2 := m.GetPackageFunc.nextHook()(v0, v1, v2, v3)
	m.GetPackageFunc.appendCall(DBStoreGetPackageFuncCall{v0, v1, v2, v3, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetPackage method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreGetPackageFunc) SetDefaultHook(hook func(context.Context, string, string, string) (dbstore.Dump, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetPackage method of the parent MockDBStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreGetPackageFunc) PushHook(hook func(context.Context, string, string, string) (dbstore.Dump, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreGetPackageFunc) SetDefaultReturn(r0 dbstore.Dump, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, string, string, string) (dbstore.Dump, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreGetPackageFunc) PushReturn(r0 dbstore.Dump, r1 bool, r2 error) {
	f.PushHook(func(context.Context, string, string, string) (dbstore.Dump, bool, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreGetPackageFunc) nextHook() func(context.Context, string, string, string) (dbstore.Dump, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetPackageFunc) appendCall(r0 DBStoreGetPackageFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetPackageFuncCall objects
// describing the invocations of this function.
func (f *DBStoreGetPackageFunc) History() []DBStoreGetPackageFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetPackageFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetPackageFuncCall is an object that describes an invocation of
// method GetPackage on an instance of MockDBStore.
type DBStoreGetPackageFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 dbstore.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetPackageFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetPackageFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreGetUploadByIDFunc describes the behavior when the GetUploadByID
// method of the parent MockDBStore instance is invoked.
type DBStoreGetUploadByIDFunc struct {
	defaultHook func(context.Context, int) (dbstore.Upload, bool, error)
	hooks       []func(context.Context, int) (dbstore.Upload, bool, error)
	history     []DBStoreGetUploadByIDFuncCall
	mutex       sync.Mutex
}

// GetUploadByID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) GetUploadByID(v0 context.Context, v1 int) (dbstore.Upload, bool, error) {
	r0, r1, r2 := m.GetUploadByIDFunc.nextHook()(v0, v1)
	m.GetUploadByIDFunc.appendCall(DBStoreGetUploadByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetUploadByID method
// of the parent MockDBStore instance is invoked and the hook queue is
// empty.
func (f *DBStoreGetUploadByIDFunc) SetDefaultHook(hook func(context.Context, int) (dbstore.Upload, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadByID method of the parent MockDBStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreGetUploadByIDFunc) PushHook(hook func(context.Context, int) (dbstore.Upload, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreGetUploadByIDFunc) SetDefaultReturn(r0 dbstore.Upload, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (dbstore.Upload, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreGetUploadByIDFunc) PushReturn(r0 dbstore.Upload, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (dbstore.Upload, bool, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreGetUploadByIDFunc) nextHook() func(context.Context, int) (dbstore.Upload, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetUploadByIDFunc) appendCall(r0 DBStoreGetUploadByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetUploadByIDFuncCall objects
// describing the invocations of this function.
func (f *DBStoreGetUploadByIDFunc) History() []DBStoreGetUploadByIDFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetUploadByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetUploadByIDFuncCall is an object that describes an invocation of
// method GetUploadByID on an instance of MockDBStore.
type DBStoreGetUploadByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 dbstore.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetUploadByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetUploadByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreGetUploadsFunc describes the behavior when the GetUploads method
// of the parent MockDBStore instance is invoked.
type DBStoreGetUploadsFunc struct {
	defaultHook func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error)
	hooks       []func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error)
	history     []DBStoreGetUploadsFuncCall
	mutex       sync.Mutex
}

// GetUploads delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) GetUploads(v0 context.Context, v1 dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error) {
	r0, r1, r2 := m.GetUploadsFunc.nextHook()(v0, v1)
	m.GetUploadsFunc.appendCall(DBStoreGetUploadsFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetUploads method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreGetUploadsFunc) SetDefaultHook(hook func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploads method of the parent MockDBStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreGetUploadsFunc) PushHook(hook func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreGetUploadsFunc) SetDefaultReturn(r0 []dbstore.Upload, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreGetUploadsFunc) PushReturn(r0 []dbstore.Upload, r1 int, r2 error) {
	f.PushHook(func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreGetUploadsFunc) nextHook() func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetUploadsFunc) appendCall(r0 DBStoreGetUploadsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetUploadsFuncCall objects
// describing the invocations of this function.
func (f *DBStoreGetUploadsFunc) History() []DBStoreGetUploadsFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetUploadsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetUploadsFuncCall is an object that describes an invocation of
// method GetUploads on an instance of MockDBStore.
type DBStoreGetUploadsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 dbstore.GetUploadsOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetUploadsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetUploadsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreHasCommitFunc describes the behavior when the HasCommit method of
// the parent MockDBStore instance is invoked.
type DBStoreHasCommitFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []DBStoreHasCommitFuncCall
	mutex       sync.Mutex
}

// HasCommit delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) HasCommit(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.HasCommitFunc.nextHook()(v0, v1, v2)
	m.HasCommitFunc.appendCall(DBStoreHasCommitFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the HasCommit method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreHasCommitFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// HasCommit method of the parent MockDBStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreHasCommitFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreHasCommitFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreHasCommitFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *DBStoreHasCommitFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreHasCommitFunc) appendCall(r0 DBStoreHasCommitFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreHasCommitFuncCall objects describing
// the invocations of this function.
func (f *DBStoreHasCommitFunc) History() []DBStoreHasCommitFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreHasCommitFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreHasCommitFuncCall is an object that describes an invocation of
// method HasCommit on an instance of MockDBStore.
type DBStoreHasCommitFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreHasCommitFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreHasCommitFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreHasRepositoryFunc describes the behavior when the HasRepository
// method of the parent MockDBStore instance is invoked.
type DBStoreHasRepositoryFunc struct {
	defaultHook func(context.Context, int) (bool, error)
	hooks       []func(context.Context, int) (bool, error)
	history     []DBStoreHasRepositoryFuncCall
	mutex       sync.Mutex
}

// HasRepository delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) HasRepository(v0 context.Context, v1 int) (bool, error) {
	r0, r1 := m.HasRepositoryFunc.nextHook()(v0, v1)
	m.HasRepositoryFunc.appendCall(DBStoreHasRepositoryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the HasRepository method
// of the parent MockDBStore instance is invoked and the hook queue is
// empty.
func (f *DBStoreHasRepositoryFunc) SetDefaultHook(hook func(context.Context, int) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// HasRepository method of the parent MockDBStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreHasRepositoryFunc) PushHook(hook func(context.Context, int) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreHasRepositoryFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreHasRepositoryFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

func (f *DBStoreHasRepositoryFunc) nextHook() func(context.Context, int) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreHasRepositoryFunc) appendCall(r0 DBStoreHasRepositoryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreHasRepositoryFuncCall objects
// describing the invocations of this function.
func (f *DBStoreHasRepositoryFunc) History() []DBStoreHasRepositoryFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreHasRepositoryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreHasRepositoryFuncCall is an object that describes an invocation of
// method HasRepository on an instance of MockDBStore.
type DBStoreHasRepositoryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreHasRepositoryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreHasRepositoryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreMarkRepositoryAsDirtyFunc describes the behavior when the
// MarkRepositoryAsDirty method of the parent MockDBStore instance is
// invoked.
type DBStoreMarkRepositoryAsDirtyFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []DBStoreMarkRepositoryAsDirtyFuncCall
	mutex       sync.Mutex
}

// MarkRepositoryAsDirty delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) MarkRepositoryAsDirty(v0 context.Context, v1 int) error {
	r0 := m.MarkRepositoryAsDirtyFunc.nextHook()(v0, v1)
	m.MarkRepositoryAsDirtyFunc.appendCall(DBStoreMarkRepositoryAsDirtyFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// MarkRepositoryAsDirty method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreMarkRepositoryAsDirtyFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkRepositoryAsDirty method of the parent MockDBStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreMarkRepositoryAsDirtyFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreMarkRepositoryAsDirtyFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreMarkRepositoryAsDirtyFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *DBStoreMarkRepositoryAsDirtyFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreMarkRepositoryAsDirtyFunc) appendCall(r0 DBStoreMarkRepositoryAsDirtyFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreMarkRepositoryAsDirtyFuncCall
// objects describing the invocations of this function.
func (f *DBStoreMarkRepositoryAsDirtyFunc) History() []DBStoreMarkRepositoryAsDirtyFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreMarkRepositoryAsDirtyFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreMarkRepositoryAsDirtyFuncCall is an object that describes an
// invocation of method MarkRepositoryAsDirty on an instance of MockDBStore.
type DBStoreMarkRepositoryAsDirtyFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreMarkRepositoryAsDirtyFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreMarkRepositoryAsDirtyFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStorePackageReferencePagerFunc describes the behavior when the
// PackageReferencePager method of the parent MockDBStore instance is
// invoked.
type DBStorePackageReferencePagerFunc struct {
	defaultHook func(context.Context, string, string, string, int, int) (int, api.ReferencePager, error)
	hooks       []func(context.Context, string, string, string, int, int) (int, api.ReferencePager, error)
	history     []DBStorePackageReferencePagerFuncCall
	mutex       sync.Mutex
}

// PackageReferencePager delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) PackageReferencePager(v0 context.Context, v1 string, v2 string, v3 string, v4 int, v5 int) (int, api.ReferencePager, error) {
	r0, r1, r2 := m.PackageReferencePagerFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.PackageReferencePagerFunc.appendCall(DBStorePackageReferencePagerFuncCall{v0, v1, v2, v3, v4, v5, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// PackageReferencePager method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStorePackageReferencePagerFunc) SetDefaultHook(hook func(context.Context, string, string, string, int, int) (int, api.ReferencePager, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// PackageReferencePager method of the parent MockDBStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStorePackageReferencePagerFunc) PushHook(hook func(context.Context, string, string, string, int, int) (int, api.ReferencePager, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStorePackageReferencePagerFunc) SetDefaultReturn(r0 int, r1 api.ReferencePager, r2 error) {
	f.SetDefaultHook(func(context.Context, string, string, string, int, int) (int, api.ReferencePager, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStorePackageReferencePagerFunc) PushReturn(r0 int, r1 api.ReferencePager, r2 error) {
	f.PushHook(func(context.Context, string, string, string, int, int) (int, api.ReferencePager, error) {
		return r0, r1, r2
	})
}

func (f *DBStorePackageReferencePagerFunc) nextHook() func(context.Context, string, string, string, int, int) (int, api.ReferencePager, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStorePackageReferencePagerFunc) appendCall(r0 DBStorePackageReferencePagerFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStorePackageReferencePagerFuncCall
// objects describing the invocations of this function.
func (f *DBStorePackageReferencePagerFunc) History() []DBStorePackageReferencePagerFuncCall {
	f.mutex.Lock()
	history := make([]DBStorePackageReferencePagerFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStorePackageReferencePagerFuncCall is an object that describes an
// invocation of method PackageReferencePager on an instance of MockDBStore.
type DBStorePackageReferencePagerFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 api.ReferencePager
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStorePackageReferencePagerFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStorePackageReferencePagerFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreRepoNameFunc describes the behavior when the RepoName method of
// the parent MockDBStore instance is invoked.
type DBStoreRepoNameFunc struct {
	defaultHook func(context.Context, int) (string, error)
	hooks       []func(context.Context, int) (string, error)
	history     []DBStoreRepoNameFuncCall
	mutex       sync.Mutex
}

// RepoName delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) RepoName(v0 context.Context, v1 int) (string, error) {
	r0, r1 := m.RepoNameFunc.nextHook()(v0, v1)
	m.RepoNameFunc.appendCall(DBStoreRepoNameFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepoName method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreRepoNameFunc) SetDefaultHook(hook func(context.Context, int) (string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoName method of the parent MockDBStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreRepoNameFunc) PushHook(hook func(context.Context, int) (string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreRepoNameFunc) SetDefaultReturn(r0 string, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreRepoNameFunc) PushReturn(r0 string, r1 error) {
	f.PushHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

func (f *DBStoreRepoNameFunc) nextHook() func(context.Context, int) (string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreRepoNameFunc) appendCall(r0 DBStoreRepoNameFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreRepoNameFuncCall objects describing
// the invocations of this function.
func (f *DBStoreRepoNameFunc) History() []DBStoreRepoNameFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreRepoNameFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreRepoNameFuncCall is an object that describes an invocation of
// method RepoName on an instance of MockDBStore.
type DBStoreRepoNameFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreRepoNameFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreRepoNameFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreSameRepoPagerFunc describes the behavior when the SameRepoPager
// method of the parent MockDBStore instance is invoked.
type DBStoreSameRepoPagerFunc struct {
	defaultHook func(context.Context, int, string, string, string, string, int) (int, api.ReferencePager, error)
	hooks       []func(context.Context, int, string, string, string, string, int) (int, api.ReferencePager, error)
	history     []DBStoreSameRepoPagerFuncCall
	mutex       sync.Mutex
}

// SameRepoPager delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) SameRepoPager(v0 context.Context, v1 int, v2 string, v3 string, v4 string, v5 string, v6 int) (int, api.ReferencePager, error) {
	r0, r1, r2 := m.SameRepoPagerFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6)
	m.SameRepoPagerFunc.appendCall(DBStoreSameRepoPagerFuncCall{v0, v1, v2, v3, v4, v5, v6, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the SameRepoPager method
// of the parent MockDBStore instance is invoked and the hook queue is
// empty.
func (f *DBStoreSameRepoPagerFunc) SetDefaultHook(hook func(context.Context, int, string, string, string, string, int) (int, api.ReferencePager, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SameRepoPager method of the parent MockDBStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreSameRepoPagerFunc) PushHook(hook func(context.Context, int, string, string, string, string, int) (int, api.ReferencePager, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreSameRepoPagerFunc) SetDefaultReturn(r0 int, r1 api.ReferencePager, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, string, string, int) (int, api.ReferencePager, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreSameRepoPagerFunc) PushReturn(r0 int, r1 api.ReferencePager, r2 error) {
	f.PushHook(func(context.Context, int, string, string, string, string, int) (int, api.ReferencePager, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreSameRepoPagerFunc) nextHook() func(context.Context, int, string, string, string, string, int) (int, api.ReferencePager, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreSameRepoPagerFunc) appendCall(r0 DBStoreSameRepoPagerFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreSameRepoPagerFuncCall objects
// describing the invocations of this function.
func (f *DBStoreSameRepoPagerFunc) History() []DBStoreSameRepoPagerFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreSameRepoPagerFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreSameRepoPagerFuncCall is an object that describes an invocation of
// method SameRepoPager on an instance of MockDBStore.
type DBStoreSameRepoPagerFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 string
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 api.ReferencePager
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreSameRepoPagerFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreSameRepoPagerFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// MockLSIFStore is a mock implementation of the LSIFStore interface (from
// the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/frontend/internal/codeintel/resolvers)
// used for unit testing.
type MockLSIFStore struct {
	// DefinitionsFunc is an instance of a mock function object controlling
	// the behavior of the method Definitions.
	DefinitionsFunc *LSIFStoreDefinitionsFunc
	// DiagnosticsFunc is an instance of a mock function object controlling
	// the behavior of the method Diagnostics.
	DiagnosticsFunc *LSIFStoreDiagnosticsFunc
	// ExistsFunc is an instance of a mock function object controlling the
	// behavior of the method Exists.
	ExistsFunc *LSIFStoreExistsFunc
	// HoverFunc is an instance of a mock function object controlling the
	// behavior of the method Hover.
	HoverFunc *LSIFStoreHoverFunc
	// MonikerResultsFunc is an instance of a mock function object
	// controlling the behavior of the method MonikerResults.
	MonikerResultsFunc *LSIFStoreMonikerResultsFunc
	// MonikersByPositionFunc is an instance of a mock function object
	// controlling the behavior of the method MonikersByPosition.
	MonikersByPositionFunc *LSIFStoreMonikersByPositionFunc
	// PackageInformationFunc is an instance of a mock function object
	// controlling the behavior of the method PackageInformation.
	PackageInformationFunc *LSIFStorePackageInformationFunc
	// RangesFunc is an instance of a mock function object controlling the
	// behavior of the method Ranges.
	RangesFunc *LSIFStoreRangesFunc
	// ReferencesFunc is an instance of a mock function object controlling
	// the behavior of the method References.
	ReferencesFunc *LSIFStoreReferencesFunc
}

// NewMockLSIFStore creates a new mock of the LSIFStore interface. All
// methods return zero values for all results, unless overwritten.
func NewMockLSIFStore() *MockLSIFStore {
	return &MockLSIFStore{
		DefinitionsFunc: &LSIFStoreDefinitionsFunc{
			defaultHook: func(context.Context, int, string, int, int) ([]lsifstore.Location, error) {
				return nil, nil
			},
		},
		DiagnosticsFunc: &LSIFStoreDiagnosticsFunc{
			defaultHook: func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error) {
				return nil, 0, nil
			},
		},
		ExistsFunc: &LSIFStoreExistsFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				return false, nil
			},
		},
		HoverFunc: &LSIFStoreHoverFunc{
			defaultHook: func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error) {
				return "", lsifstore.Range{}, false, nil
			},
		},
		MonikerResultsFunc: &LSIFStoreMonikerResultsFunc{
			defaultHook: func(context.Context, int, string, string, string, int, int) ([]lsifstore.Location, int, error) {
				return nil, 0, nil
			},
		},
		MonikersByPositionFunc: &LSIFStoreMonikersByPositionFunc{
			defaultHook: func(context.Context, int, string, int, int) ([][]lsifstore.MonikerData, error) {
				return nil, nil
			},
		},
		PackageInformationFunc: &LSIFStorePackageInformationFunc{
			defaultHook: func(context.Context, int, string, string) (lsifstore.PackageInformationData, bool, error) {
				return lsifstore.PackageInformationData{}, false, nil
			},
		},
		RangesFunc: &LSIFStoreRangesFunc{
			defaultHook: func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error) {
				return nil, nil
			},
		},
		ReferencesFunc: &LSIFStoreReferencesFunc{
			defaultHook: func(context.Context, int, string, int, int) ([]lsifstore.Location, error) {
				return nil, nil
			},
		},
	}
}

// NewMockLSIFStoreFrom creates a new mock of the MockLSIFStore interface.
// All methods delegate to the given implementation, unless overwritten.
func NewMockLSIFStoreFrom(i LSIFStore) *MockLSIFStore {
	return &MockLSIFStore{
		DefinitionsFunc: &LSIFStoreDefinitionsFunc{
			defaultHook: i.Definitions,
		},
		DiagnosticsFunc: &LSIFStoreDiagnosticsFunc{
			defaultHook: i.Diagnostics,
		},
		ExistsFunc: &LSIFStoreExistsFunc{
			defaultHook: i.Exists,
		},
		HoverFunc: &LSIFStoreHoverFunc{
			defaultHook: i.Hover,
		},
		MonikerResultsFunc: &LSIFStoreMonikerResultsFunc{
			defaultHook: i.MonikerResults,
		},
		MonikersByPositionFunc: &LSIFStoreMonikersByPositionFunc{
			defaultHook: i.MonikersByPosition,
		},
		PackageInformationFunc: &LSIFStorePackageInformationFunc{
			defaultHook: i.PackageInformation,
		},
		RangesFunc: &LSIFStoreRangesFunc{
			defaultHook: i.Ranges,
		},
		ReferencesFunc: &LSIFStoreReferencesFunc{
			defaultHook: i.References,
		},
	}
}

// LSIFStoreDefinitionsFunc describes the behavior when the Definitions
// method of the parent MockLSIFStore instance is invoked.
type LSIFStoreDefinitionsFunc struct {
	defaultHook func(context.Context, int, string, int, int) ([]lsifstore.Location, error)
	hooks       []func(context.Context, int, string, int, int) ([]lsifstore.Location, error)
	history     []LSIFStoreDefinitionsFuncCall
	mutex       sync.Mutex
}

// Definitions delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockLSIFStore) Definitions(v0 context.Context, v1 int, v2 string, v3 int, v4 int) ([]lsifstore.Location, error) {
	r0, r1 := m.DefinitionsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.DefinitionsFunc.appendCall(LSIFStoreDefinitionsFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Definitions method
// of the parent MockLSIFStore instance is invoked and the hook queue is
// empty.
func (f *LSIFStoreDefinitionsFunc) SetDefaultHook(hook func(context.Context, int, string, int, int) ([]lsifstore.Location, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Definitions method of the parent MockLSIFStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreDefinitionsFunc) PushHook(hook func(context.Context, int, string, int, int) ([]lsifstore.Location, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreDefinitionsFunc) SetDefaultReturn(r0 []lsifstore.Location, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int) ([]lsifstore.Location, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreDefinitionsFunc) PushReturn(r0 []lsifstore.Location, r1 error) {
	f.PushHook(func(context.Context, int, string, int, int) ([]lsifstore.Location, error) {
		return r0, r1
	})
}

func (f *LSIFStoreDefinitionsFunc) nextHook() func(context.Context, int, string, int, int) ([]lsifstore.Location, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreDefinitionsFunc) appendCall(r0 LSIFStoreDefinitionsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreDefinitionsFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreDefinitionsFunc) History() []LSIFStoreDefinitionsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreDefinitionsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreDefinitionsFuncCall is an object that describes an invocation of
// method Definitions on an instance of MockLSIFStore.
type LSIFStoreDefinitionsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.Location
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreDefinitionsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreDefinitionsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStoreDiagnosticsFunc describes the behavior when the Diagnostics
// method of the parent MockLSIFStore instance is invoked.
type LSIFStoreDiagnosticsFunc struct {
	defaultHook func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error)
	hooks       []func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error)
	history     []LSIFStoreDiagnosticsFuncCall
	mutex       sync.Mutex
}

// Diagnostics delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockLSIFStore) Diagnostics(v0 context.Context, v1 int, v2 string, v3 int, v4 int) ([]lsifstore.Diagnostic, int, error) {
	r0, r1, r2 := m.DiagnosticsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.DiagnosticsFunc.appendCall(LSIFStoreDiagnosticsFuncCall{v0, v1, v2, v3, v4, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Diagnostics method
// of the parent MockLSIFStore instance is invoked and the hook queue is
// empty.
func (f *LSIFStoreDiagnosticsFunc) SetDefaultHook(hook func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Diagnostics method of the parent MockLSIFStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreDiagnosticsFunc) PushHook(hook func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreDiagnosticsFunc) SetDefaultReturn(r0 []lsifstore.Diagnostic, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreDiagnosticsFunc) PushReturn(r0 []lsifstore.Diagnostic, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error) {
		return r0, r1, r2
	})
}

func (f *LSIFStoreDiagnosticsFunc) nextHook() func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreDiagnosticsFunc) appendCall(r0 LSIFStoreDiagnosticsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreDiagnosticsFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreDiagnosticsFunc) History() []LSIFStoreDiagnosticsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreDiagnosticsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreDiagnosticsFuncCall is an object that describes an invocation of
// method Diagnostics on an instance of MockLSIFStore.
type LSIFStoreDiagnosticsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.Diagnostic
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreDiagnosticsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreDiagnosticsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// LSIFStoreExistsFunc describes the behavior when the Exists method of the
// parent MockLSIFStore instance is invoked.
type LSIFStoreExistsFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []LSIFStoreExistsFuncCall
	mutex       sync.Mutex
}

// Exists delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) Exists(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.ExistsFunc.nextHook()(v0, v1, v2)
	m.ExistsFunc.appendCall(LSIFStoreExistsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Exists method of the
// parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreExistsFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Exists method of the parent MockLSIFStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreExistsFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreExistsFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreExistsFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *LSIFStoreExistsFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreExistsFunc) appendCall(r0 LSIFStoreExistsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreExistsFuncCall objects describing
// the invocations of this function.
func (f *LSIFStoreExistsFunc) History() []LSIFStoreExistsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreExistsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreExistsFuncCall is an object that describes an invocation of
// method Exists on an instance of MockLSIFStore.
type LSIFStoreExistsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreExistsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreExistsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStoreHoverFunc describes the behavior when the Hover method of the
// parent MockLSIFStore instance is invoked.
type LSIFStoreHoverFunc struct {
	defaultHook func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error)
	hooks       []func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error)
	history     []LSIFStoreHoverFuncCall
	mutex       sync.Mutex
}

// Hover delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) Hover(v0 context.Context, v1 int, v2 string, v3 int, v4 int) (string, lsifstore.Range, bool, error) {
	r0, r1, r2, r3 := m.HoverFunc.nextHook()(v0, v1, v2, v3, v4)
	m.HoverFunc.appendCall(LSIFStoreHoverFuncCall{v0, v1, v2, v3, v4, r0, r1, r2, r3})
	return r0, r1, r2, r3
}

// SetDefaultHook sets function that is called when the Hover method of the
// parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreHoverFunc) SetDefaultHook(hook func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Hover method of the parent MockLSIFStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *LSIFStoreHoverFunc) PushHook(hook func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreHoverFunc) SetDefaultReturn(r0 string, r1 lsifstore.Range, r2 bool, r3 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error) {
		return r0, r1, r2, r3
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreHoverFunc) PushReturn(r0 string, r1 lsifstore.Range, r2 bool, r3 error) {
	f.PushHook(func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error) {
		return r0, r1, r2, r3
	})
}

func (f *LSIFStoreHoverFunc) nextHook() func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreHoverFunc) appendCall(r0 LSIFStoreHoverFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreHoverFuncCall objects describing
// the invocations of this function.
func (f *LSIFStoreHoverFunc) History() []LSIFStoreHoverFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreHoverFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreHoverFuncCall is an object that describes an invocation of
// method Hover on an instance of MockLSIFStore.
type LSIFStoreHoverFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 lsifstore.Range
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 bool
	// Result3 is the value of the 4th result returned from this method
	// invocation.
	Result3 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreHoverFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreHoverFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2, c.Result3}
}

// LSIFStoreMonikerResultsFunc describes the behavior when the
// MonikerResults method of the parent MockLSIFStore instance is invoked.
type LSIFStoreMonikerResultsFunc struct {
	defaultHook func(context.Context, int, string, string, string, int, int) ([]lsifstore.Location, int, error)
	hooks       []func(context.Context, int, string, string, string, int, int) ([]lsifstore.Location, int, error)
	history     []LSIFStoreMonikerResultsFuncCall
	mutex       sync.Mutex
}

// MonikerResults delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) MonikerResults(v0 context.Context, v1 int, v2 string, v3 string, v4 string, v5 int, v6 int) ([]lsifstore.Location, int, error) {
	r0, r1, r2 := m.MonikerResultsFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6)
	m.MonikerResultsFunc.appendCall(LSIFStoreMonikerResultsFuncCall{v0, v1, v2, v3, v4, v5, v6, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the MonikerResults
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreMonikerResultsFunc) SetDefaultHook(hook func(context.Context, int, string, string, string, int, int) ([]lsifstore.Location, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MonikerResults method of the parent MockLSIFStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreMonikerResultsFunc) PushHook(hook func(context.Context, int, string, string, string, int, int) ([]lsifstore.Location, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreMonikerResultsFunc) SetDefaultReturn(r0 []lsifstore.Location, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, string, int, int) ([]lsifstore.Location, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreMonikerResultsFunc) PushReturn(r0 []lsifstore.Location, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string, string, string, int, int) ([]lsifstore.Location, int, error) {
		return r0, r1, r2
	})
}

func (f *LSIFStoreMonikerResultsFunc) nextHook() func(context.Context, int, string, string, string, int, int) ([]lsifstore.Location, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreMonikerResultsFunc) appendCall(r0 LSIFStoreMonikerResultsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreMonikerResultsFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreMonikerResultsFunc) History() []LSIFStoreMonikerResultsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreMonikerResultsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreMonikerResultsFuncCall is an object that describes an invocation
// of method MonikerResults on an instance of MockLSIFStore.
type LSIFStoreMonikerResultsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 int
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.Location
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreMonikerResultsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreMonikerResultsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// LSIFStoreMonikersByPositionFunc describes the behavior when the
// MonikersByPosition method of the parent MockLSIFStore instance is
// invoked.
type LSIFStoreMonikersByPositionFunc struct {
	defaultHook func(context.Context, int, string, int, int) ([][]lsifstore.MonikerData, error)
	hooks       []func(context.Context, int, string, int, int) ([][]lsifstore.MonikerData, error)
	history     []LSIFStoreMonikersByPositionFuncCall
	mutex       sync.Mutex
}

// MonikersByPosition delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) MonikersByPosition(v0 context.Context, v1 int, v2 string, v3 int, v4 int) ([][]lsifstore.MonikerData, error) {
	r0, r1 := m.MonikersByPositionFunc.nextHook()(v0, v1, v2, v3, v4)
	m.MonikersByPositionFunc.appendCall(LSIFStoreMonikersByPositionFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MonikersByPosition
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreMonikersByPositionFunc) SetDefaultHook(hook func(context.Context, int, string, int, int) ([][]lsifstore.MonikerData, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MonikersByPosition method of the parent MockLSIFStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *LSIFStoreMonikersByPositionFunc) PushHook(hook func(context.Context, int, string, int, int) ([][]lsifstore.MonikerData, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreMonikersByPositionFunc) SetDefaultReturn(r0 [][]lsifstore.MonikerData, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int) ([][]lsifstore.MonikerData, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreMonikersByPositionFunc) PushReturn(r0 [][]lsifstore.MonikerData, r1 error) {
	f.PushHook(func(context.Context, int, string, int, int) ([][]lsifstore.MonikerData, error) {
		return r0, r1
	})
}

func (f *LSIFStoreMonikersByPositionFunc) nextHook() func(context.Context, int, string, int, int) ([][]lsifstore.MonikerData, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreMonikersByPositionFunc) appendCall(r0 LSIFStoreMonikersByPositionFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreMonikersByPositionFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreMonikersByPositionFunc) History() []LSIFStoreMonikersByPositionFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreMonikersByPositionFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreMonikersByPositionFuncCall is an object that describes an
// invocation of method MonikersByPosition on an instance of MockLSIFStore.
type LSIFStoreMonikersByPositionFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 [][]lsifstore.MonikerData
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreMonikersByPositionFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreMonikersByPositionFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStorePackageInformationFunc describes the behavior when the
// PackageInformation method of the parent MockLSIFStore instance is
// invoked.
type LSIFStorePackageInformationFunc struct {
	defaultHook func(context.Context, int, string, string) (lsifstore.PackageInformationData, bool, error)
	hooks       []func(context.Context, int, string, string) (lsifstore.PackageInformationData, bool, error)
	history     []LSIFStorePackageInformationFuncCall
	mutex       sync.Mutex
}

// PackageInformation delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) PackageInformation(v0 context.Context, v1 int, v2 string, v3 string) (lsifstore.PackageInformationData, bool, error) {
	r0, r1, r2 := m.PackageInformationFunc.nextHook()(v0, v1, v2, v3)
	m.PackageInformationFunc.appendCall(LSIFStorePackageInformationFuncCall{v0, v1, v2, v3, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the PackageInformation
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStorePackageInformationFunc) SetDefaultHook(hook func(context.Context, int, string, string) (lsifstore.PackageInformationData, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// PackageInformation method of the parent MockLSIFStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *LSIFStorePackageInformationFunc) PushHook(hook func(context.Context, int, string, string) (lsifstore.PackageInformationData, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStorePackageInformationFunc) SetDefaultReturn(r0 lsifstore.PackageInformationData, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, string) (lsifstore.PackageInformationData, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStorePackageInformationFunc) PushReturn(r0 lsifstore.PackageInformationData, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int, string, string) (lsifstore.PackageInformationData, bool, error) {
		return r0, r1, r2
	})
}

func (f *LSIFStorePackageInformationFunc) nextHook() func(context.Context, int, string, string) (lsifstore.PackageInformationData, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStorePackageInformationFunc) appendCall(r0 LSIFStorePackageInformationFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStorePackageInformationFuncCall objects
// describing the invocations of this function.
func (f *LSIFStorePackageInformationFunc) History() []LSIFStorePackageInformationFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStorePackageInformationFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStorePackageInformationFuncCall is an object that describes an
// invocation of method PackageInformation on an instance of MockLSIFStore.
type LSIFStorePackageInformationFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 lsifstore.PackageInformationData
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStorePackageInformationFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStorePackageInformationFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// LSIFStoreRangesFunc describes the behavior when the Ranges method of the
// parent MockLSIFStore instance is invoked.
type LSIFStoreRangesFunc struct {
	defaultHook func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error)
	hooks       []func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error)
	history     []LSIFStoreRangesFuncCall
	mutex       sync.Mutex
}

// Ranges delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) Ranges(v0 context.Context, v1 int, v2 string, v3 int, v4 int) ([]lsifstore.CodeIntelligenceRange, error) {
	r0, r1 := m.RangesFunc.nextHook()(v0, v1, v2, v3, v4)
	m.RangesFunc.appendCall(LSIFStoreRangesFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Ranges method of the
// parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreRangesFunc) SetDefaultHook(hook func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Ranges method of the parent MockLSIFStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreRangesFunc) PushHook(hook func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreRangesFunc) SetDefaultReturn(r0 []lsifstore.CodeIntelligenceRange, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreRangesFunc) PushReturn(r0 []lsifstore.CodeIntelligenceRange, r1 error) {
	f.PushHook(func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error) {
		return r0, r1
	})
}

func (f *LSIFStoreRangesFunc) nextHook() func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreRangesFunc) appendCall(r0 LSIFStoreRangesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreRangesFuncCall objects describing
// the invocations of this function.
func (f *LSIFStoreRangesFunc) History() []LSIFStoreRangesFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreRangesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreRangesFuncCall is an object that describes an invocation of
// method Ranges on an instance of MockLSIFStore.
type LSIFStoreRangesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.CodeIntelligenceRange
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreRangesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreRangesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStoreReferencesFunc describes the behavior when the References method
// of the parent MockLSIFStore instance is invoked.
type LSIFStoreReferencesFunc struct {
	defaultHook func(context.Context, int, string, int, int) ([]lsifstore.Location, error)
	hooks       []func(context.Context, int, string, int, int) ([]lsifstore.Location, error)
	history     []LSIFStoreReferencesFuncCall
	mutex       sync.Mutex
}

// References delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockLSIFStore) References(v0 context.Context, v1 int, v2 string, v3 int, v4 int) ([]lsifstore.Location, error) {
	r0, r1 := m.ReferencesFunc.nextHook()(v0, v1, v2, v3, v4)
	m.ReferencesFunc.appendCall(LSIFStoreReferencesFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the References method of
// the parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreReferencesFunc) SetDefaultHook(hook func(context.Context, int, string, int, int) ([]lsifstore.Location, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// References method of the parent MockLSIFStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreReferencesFunc) PushHook(hook func(context.Context, int, string, int, int) ([]lsifstore.Location, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreReferencesFunc) SetDefaultReturn(r0 []lsifstore.Location, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int) ([]lsifstore.Location, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreReferencesFunc) PushReturn(r0 []lsifstore.Location, r1 error) {
	f.PushHook(func(context.Context, int, string, int, int) ([]lsifstore.Location, error) {
		return r0, r1
	})
}

func (f *LSIFStoreReferencesFunc) nextHook() func(context.Context, int, string, int, int) ([]lsifstore.Location, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreReferencesFunc) appendCall(r0 LSIFStoreReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreReferencesFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreReferencesFunc) History() []LSIFStoreReferencesFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreReferencesFuncCall is an object that describes an invocation of
// method References on an instance of MockLSIFStore.
type LSIFStoreReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.Location
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}
