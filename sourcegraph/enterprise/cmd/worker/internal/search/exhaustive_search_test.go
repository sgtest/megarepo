package search

import (
	"context"
	"fmt"
	"strings"
	"testing"
	"time"

	"github.com/keegancsmith/sqlf"
	"github.com/stretchr/testify/require"

	"github.com/sourcegraph/sourcegraph/internal/actor"
	"github.com/sourcegraph/sourcegraph/internal/database"
	"github.com/sourcegraph/sourcegraph/internal/database/basestore"
	"github.com/sourcegraph/sourcegraph/internal/database/dbtest"
	"github.com/sourcegraph/sourcegraph/internal/observation"
	"github.com/sourcegraph/sourcegraph/internal/search/exhaustive/store"
	"github.com/sourcegraph/sourcegraph/internal/search/exhaustive/types"
)

func TestExhaustiveSearch(t *testing.T) {
	// This test exercises the full worker infra from the time a search job is
	// created until it is done.

	require := require.New(t)
	observationCtx := observation.TestContextTB(t)
	logger := observationCtx.Logger
	db := database.NewDB(logger, dbtest.NewDB(logger, t))
	s := store.New(db, observation.TestContextTB(t))

	ctx, cancel := context.WithCancel(actor.WithInternalActor(context.Background()))
	defer cancel()

	userID := insertRow(t, s.Store, "users", "username", "alice")
	insertRow(t, s.Store, "repo", "id", 1, "name", "repoa")
	insertRow(t, s.Store, "repo", "id", 2, "name", "repob")

	query := "1@rev1 1@rev2 2@rev3"

	// Create a job
	jobID, err := s.CreateExhaustiveSearchJob(ctx, types.ExhaustiveSearchJob{
		InitiatorID: userID,
		Query:       query,
	})
	require.NoError(err)

	// Now that the job is created, we start up all the worker routines for
	// exhaustive search and wait until there are no more jobs left.
	searchJob := &searchJob{
		workerDB: db,
		config: config{
			WorkerInterval: 10 * time.Millisecond,
		},
	}
	routines, err := searchJob.Routines(ctx, observationCtx)
	require.NoError(err)
	for _, routine := range routines {
		go routine.Start()
		defer routine.Stop()
	}
	require.Eventually(func() bool {
		return !searchJob.hasWork(ctx)
	}, tTimeout(t, 10*time.Second), 10*time.Millisecond)

	// We now validate by directly checking the entries are created that we
	// want.
	want := "1@spec 2@spec"
	wantJobCount := 2
	rows, err := s.Store.Query(ctx, sqlf.Sprintf("SELECT id, CONCAT(repo_id, '@', ref_spec) AS part FROM exhaustive_search_repo_jobs WHERE search_job_id = %d ORDER BY part ASC", jobID))
	require.NoError(err)

	var gotParts []string
	var ids []int64
	for rows.Next() {
		var part string
		var id int64
		require.NoError(rows.Scan(&id, &part))
		ids = append(ids, id)
		gotParts = append(gotParts, part)
	}
	require.NoError(rows.Err())

	// This check is not strictly required because the number of ids is implicitly
	// checked by the format of "want". However, we check explicitly anyway to get a
	// nice error message instead of a panic when accessing the ids by index later
	// in the test.
	require.Equal(wantJobCount, len(ids))

	got := strings.Join(gotParts, " ")
	require.Equal(want, got)

	// Check that we created 3 repo revision jobs.
	want = fmt.Sprintf("%[1]d:rev1 %[1]d:rev2 %[2]d:rev3", ids[0], ids[1])
	rows, err = s.Store.Query(ctx, sqlf.Sprintf("SELECT CONCAT(search_repo_job_id, ':', revision) AS part FROM exhaustive_search_repo_revision_jobs WHERE search_repo_job_id IN (SELECT id from exhaustive_search_repo_jobs WHERE search_job_id = %d) ORDER BY PART ASC", jobID))
	require.NoError(err)

	gotParts = gotParts[:0]
	for rows.Next() {
		var part string
		require.NoError(rows.Scan(&part))
		gotParts = append(gotParts, part)
	}
	require.NoError(rows.Err())

	got = strings.Join(gotParts, " ")
	require.Equal(want, got)
}

// insertRow is a helper for inserting a row into a table. It assumes the
// table has an autogenerated column called id and it will return that value.
func insertRow(t testing.TB, store *basestore.Store, table string, keyValues ...any) int32 {
	var columns, values []*sqlf.Query
	for i, kv := range keyValues {
		if i%2 == 0 {
			columns = append(columns, sqlf.Sprintf(kv.(string)))
		} else {
			values = append(values, sqlf.Sprintf("%v", kv))
		}
	}
	q := sqlf.Sprintf(`INSERT INTO %s(%s) VALUES(%s) RETURNING id`, sqlf.Sprintf(table), sqlf.Join(columns, ", "), sqlf.Join(values, ", "))
	row := store.QueryRow(context.Background(), q)
	var id int32
	if err := row.Scan(&id); err != nil {
		t.Fatal(err)
	}
	return id
}

// tTimeout returns the duration until t's deadline. If there is no deadline
// or the deadline is further away than max, then max is returned.
func tTimeout(t *testing.T, max time.Duration) time.Duration {
	deadline, ok := t.Deadline()
	if !ok {
		return max
	}
	timeout := time.Until(deadline)
	if max < timeout {
		return max
	}
	return timeout
}
