// Code generated by github.com/efritz/go-mockgen 0.1.0; DO NOT EDIT.

package worker

import (
	"context"
	gitserver "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/gitserver"
	lsifstore "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/stores/lsifstore"
	basestore "github.com/sourcegraph/sourcegraph/internal/db/basestore"
	"sync"
	"time"
)

// MockDBStore is a mock implementation of the DBStore interface (from the
// package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/precise-code-intel-worker/internal/worker)
// used for unit testing.
type MockDBStore struct {
	// DeleteOverlappingDumpsFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteOverlappingDumps.
	DeleteOverlappingDumpsFunc *DBStoreDeleteOverlappingDumpsFunc
	// DoneFunc is an instance of a mock function object controlling the
	// behavior of the method Done.
	DoneFunc *DBStoreDoneFunc
	// HandleFunc is an instance of a mock function object controlling the
	// behavior of the method Handle.
	HandleFunc *DBStoreHandleFunc
	// MarkCompleteFunc is an instance of a mock function object controlling
	// the behavior of the method MarkComplete.
	MarkCompleteFunc *DBStoreMarkCompleteFunc
	// MarkRepositoryAsDirtyFunc is an instance of a mock function object
	// controlling the behavior of the method MarkRepositoryAsDirty.
	MarkRepositoryAsDirtyFunc *DBStoreMarkRepositoryAsDirtyFunc
	// RepoNameFunc is an instance of a mock function object controlling the
	// behavior of the method RepoName.
	RepoNameFunc *DBStoreRepoNameFunc
	// RequeueFunc is an instance of a mock function object controlling the
	// behavior of the method Requeue.
	RequeueFunc *DBStoreRequeueFunc
	// TransactFunc is an instance of a mock function object controlling the
	// behavior of the method Transact.
	TransactFunc *DBStoreTransactFunc
	// UpdatePackageReferencesFunc is an instance of a mock function object
	// controlling the behavior of the method UpdatePackageReferences.
	UpdatePackageReferencesFunc *DBStoreUpdatePackageReferencesFunc
	// UpdatePackagesFunc is an instance of a mock function object
	// controlling the behavior of the method UpdatePackages.
	UpdatePackagesFunc *DBStoreUpdatePackagesFunc
	// WithFunc is an instance of a mock function object controlling the
	// behavior of the method With.
	WithFunc *DBStoreWithFunc
}

// NewMockDBStore creates a new mock of the DBStore interface. All methods
// return zero values for all results, unless overwritten.
func NewMockDBStore() *MockDBStore {
	return &MockDBStore{
		DeleteOverlappingDumpsFunc: &DBStoreDeleteOverlappingDumpsFunc{
			defaultHook: func(context.Context, int, string, string, string) error {
				return nil
			},
		},
		DoneFunc: &DBStoreDoneFunc{
			defaultHook: func(error) error {
				return nil
			},
		},
		HandleFunc: &DBStoreHandleFunc{
			defaultHook: func() *basestore.TransactableHandle {
				return nil
			},
		},
		MarkCompleteFunc: &DBStoreMarkCompleteFunc{
			defaultHook: func(context.Context, int) error {
				return nil
			},
		},
		MarkRepositoryAsDirtyFunc: &DBStoreMarkRepositoryAsDirtyFunc{
			defaultHook: func(context.Context, int) error {
				return nil
			},
		},
		RepoNameFunc: &DBStoreRepoNameFunc{
			defaultHook: func(context.Context, int) (string, error) {
				return "", nil
			},
		},
		RequeueFunc: &DBStoreRequeueFunc{
			defaultHook: func(context.Context, int, time.Time) error {
				return nil
			},
		},
		TransactFunc: &DBStoreTransactFunc{
			defaultHook: func(context.Context) (DBStore, error) {
				return nil, nil
			},
		},
		UpdatePackageReferencesFunc: &DBStoreUpdatePackageReferencesFunc{
			defaultHook: func(context.Context, []lsifstore.PackageReference) error {
				return nil
			},
		},
		UpdatePackagesFunc: &DBStoreUpdatePackagesFunc{
			defaultHook: func(context.Context, []lsifstore.Package) error {
				return nil
			},
		},
		WithFunc: &DBStoreWithFunc{
			defaultHook: func(basestore.ShareableStore) DBStore {
				return nil
			},
		},
	}
}

// NewMockDBStoreFrom creates a new mock of the MockDBStore interface. All
// methods delegate to the given implementation, unless overwritten.
func NewMockDBStoreFrom(i DBStore) *MockDBStore {
	return &MockDBStore{
		DeleteOverlappingDumpsFunc: &DBStoreDeleteOverlappingDumpsFunc{
			defaultHook: i.DeleteOverlappingDumps,
		},
		DoneFunc: &DBStoreDoneFunc{
			defaultHook: i.Done,
		},
		HandleFunc: &DBStoreHandleFunc{
			defaultHook: i.Handle,
		},
		MarkCompleteFunc: &DBStoreMarkCompleteFunc{
			defaultHook: i.MarkComplete,
		},
		MarkRepositoryAsDirtyFunc: &DBStoreMarkRepositoryAsDirtyFunc{
			defaultHook: i.MarkRepositoryAsDirty,
		},
		RepoNameFunc: &DBStoreRepoNameFunc{
			defaultHook: i.RepoName,
		},
		RequeueFunc: &DBStoreRequeueFunc{
			defaultHook: i.Requeue,
		},
		TransactFunc: &DBStoreTransactFunc{
			defaultHook: i.Transact,
		},
		UpdatePackageReferencesFunc: &DBStoreUpdatePackageReferencesFunc{
			defaultHook: i.UpdatePackageReferences,
		},
		UpdatePackagesFunc: &DBStoreUpdatePackagesFunc{
			defaultHook: i.UpdatePackages,
		},
		WithFunc: &DBStoreWithFunc{
			defaultHook: i.With,
		},
	}
}

// DBStoreDeleteOverlappingDumpsFunc describes the behavior when the
// DeleteOverlappingDumps method of the parent MockDBStore instance is
// invoked.
type DBStoreDeleteOverlappingDumpsFunc struct {
	defaultHook func(context.Context, int, string, string, string) error
	hooks       []func(context.Context, int, string, string, string) error
	history     []DBStoreDeleteOverlappingDumpsFuncCall
	mutex       sync.Mutex
}

// DeleteOverlappingDumps delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) DeleteOverlappingDumps(v0 context.Context, v1 int, v2 string, v3 string, v4 string) error {
	r0 := m.DeleteOverlappingDumpsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.DeleteOverlappingDumpsFunc.appendCall(DBStoreDeleteOverlappingDumpsFuncCall{v0, v1, v2, v3, v4, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// DeleteOverlappingDumps method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreDeleteOverlappingDumpsFunc) SetDefaultHook(hook func(context.Context, int, string, string, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteOverlappingDumps method of the parent MockDBStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreDeleteOverlappingDumpsFunc) PushHook(hook func(context.Context, int, string, string, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreDeleteOverlappingDumpsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, string) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreDeleteOverlappingDumpsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string, string, string) error {
		return r0
	})
}

func (f *DBStoreDeleteOverlappingDumpsFunc) nextHook() func(context.Context, int, string, string, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreDeleteOverlappingDumpsFunc) appendCall(r0 DBStoreDeleteOverlappingDumpsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreDeleteOverlappingDumpsFuncCall
// objects describing the invocations of this function.
func (f *DBStoreDeleteOverlappingDumpsFunc) History() []DBStoreDeleteOverlappingDumpsFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreDeleteOverlappingDumpsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreDeleteOverlappingDumpsFuncCall is an object that describes an
// invocation of method DeleteOverlappingDumps on an instance of
// MockDBStore.
type DBStoreDeleteOverlappingDumpsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreDeleteOverlappingDumpsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreDeleteOverlappingDumpsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreDoneFunc describes the behavior when the Done method of the parent
// MockDBStore instance is invoked.
type DBStoreDoneFunc struct {
	defaultHook func(error) error
	hooks       []func(error) error
	history     []DBStoreDoneFuncCall
	mutex       sync.Mutex
}

// Done delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) Done(v0 error) error {
	r0 := m.DoneFunc.nextHook()(v0)
	m.DoneFunc.appendCall(DBStoreDoneFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Done method of the
// parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreDoneFunc) SetDefaultHook(hook func(error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Done method of the parent MockDBStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *DBStoreDoneFunc) PushHook(hook func(error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreDoneFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(error) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreDoneFunc) PushReturn(r0 error) {
	f.PushHook(func(error) error {
		return r0
	})
}

func (f *DBStoreDoneFunc) nextHook() func(error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreDoneFunc) appendCall(r0 DBStoreDoneFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreDoneFuncCall objects describing the
// invocations of this function.
func (f *DBStoreDoneFunc) History() []DBStoreDoneFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreDoneFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreDoneFuncCall is an object that describes an invocation of method
// Done on an instance of MockDBStore.
type DBStoreDoneFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreDoneFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreDoneFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreHandleFunc describes the behavior when the Handle method of the
// parent MockDBStore instance is invoked.
type DBStoreHandleFunc struct {
	defaultHook func() *basestore.TransactableHandle
	hooks       []func() *basestore.TransactableHandle
	history     []DBStoreHandleFuncCall
	mutex       sync.Mutex
}

// Handle delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) Handle() *basestore.TransactableHandle {
	r0 := m.HandleFunc.nextHook()()
	m.HandleFunc.appendCall(DBStoreHandleFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the Handle method of the
// parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreHandleFunc) SetDefaultHook(hook func() *basestore.TransactableHandle) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Handle method of the parent MockDBStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *DBStoreHandleFunc) PushHook(hook func() *basestore.TransactableHandle) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreHandleFunc) SetDefaultReturn(r0 *basestore.TransactableHandle) {
	f.SetDefaultHook(func() *basestore.TransactableHandle {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreHandleFunc) PushReturn(r0 *basestore.TransactableHandle) {
	f.PushHook(func() *basestore.TransactableHandle {
		return r0
	})
}

func (f *DBStoreHandleFunc) nextHook() func() *basestore.TransactableHandle {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreHandleFunc) appendCall(r0 DBStoreHandleFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreHandleFuncCall objects describing
// the invocations of this function.
func (f *DBStoreHandleFunc) History() []DBStoreHandleFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreHandleFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreHandleFuncCall is an object that describes an invocation of method
// Handle on an instance of MockDBStore.
type DBStoreHandleFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *basestore.TransactableHandle
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreHandleFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreHandleFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreMarkCompleteFunc describes the behavior when the MarkComplete
// method of the parent MockDBStore instance is invoked.
type DBStoreMarkCompleteFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []DBStoreMarkCompleteFuncCall
	mutex       sync.Mutex
}

// MarkComplete delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) MarkComplete(v0 context.Context, v1 int) error {
	r0 := m.MarkCompleteFunc.nextHook()(v0, v1)
	m.MarkCompleteFunc.appendCall(DBStoreMarkCompleteFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the MarkComplete method
// of the parent MockDBStore instance is invoked and the hook queue is
// empty.
func (f *DBStoreMarkCompleteFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkComplete method of the parent MockDBStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreMarkCompleteFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreMarkCompleteFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreMarkCompleteFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *DBStoreMarkCompleteFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreMarkCompleteFunc) appendCall(r0 DBStoreMarkCompleteFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreMarkCompleteFuncCall objects
// describing the invocations of this function.
func (f *DBStoreMarkCompleteFunc) History() []DBStoreMarkCompleteFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreMarkCompleteFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreMarkCompleteFuncCall is an object that describes an invocation of
// method MarkComplete on an instance of MockDBStore.
type DBStoreMarkCompleteFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreMarkCompleteFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreMarkCompleteFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreMarkRepositoryAsDirtyFunc describes the behavior when the
// MarkRepositoryAsDirty method of the parent MockDBStore instance is
// invoked.
type DBStoreMarkRepositoryAsDirtyFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []DBStoreMarkRepositoryAsDirtyFuncCall
	mutex       sync.Mutex
}

// MarkRepositoryAsDirty delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) MarkRepositoryAsDirty(v0 context.Context, v1 int) error {
	r0 := m.MarkRepositoryAsDirtyFunc.nextHook()(v0, v1)
	m.MarkRepositoryAsDirtyFunc.appendCall(DBStoreMarkRepositoryAsDirtyFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// MarkRepositoryAsDirty method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreMarkRepositoryAsDirtyFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkRepositoryAsDirty method of the parent MockDBStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreMarkRepositoryAsDirtyFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreMarkRepositoryAsDirtyFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreMarkRepositoryAsDirtyFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *DBStoreMarkRepositoryAsDirtyFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreMarkRepositoryAsDirtyFunc) appendCall(r0 DBStoreMarkRepositoryAsDirtyFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreMarkRepositoryAsDirtyFuncCall
// objects describing the invocations of this function.
func (f *DBStoreMarkRepositoryAsDirtyFunc) History() []DBStoreMarkRepositoryAsDirtyFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreMarkRepositoryAsDirtyFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreMarkRepositoryAsDirtyFuncCall is an object that describes an
// invocation of method MarkRepositoryAsDirty on an instance of MockDBStore.
type DBStoreMarkRepositoryAsDirtyFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreMarkRepositoryAsDirtyFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreMarkRepositoryAsDirtyFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreRepoNameFunc describes the behavior when the RepoName method of
// the parent MockDBStore instance is invoked.
type DBStoreRepoNameFunc struct {
	defaultHook func(context.Context, int) (string, error)
	hooks       []func(context.Context, int) (string, error)
	history     []DBStoreRepoNameFuncCall
	mutex       sync.Mutex
}

// RepoName delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) RepoName(v0 context.Context, v1 int) (string, error) {
	r0, r1 := m.RepoNameFunc.nextHook()(v0, v1)
	m.RepoNameFunc.appendCall(DBStoreRepoNameFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepoName method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreRepoNameFunc) SetDefaultHook(hook func(context.Context, int) (string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoName method of the parent MockDBStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreRepoNameFunc) PushHook(hook func(context.Context, int) (string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreRepoNameFunc) SetDefaultReturn(r0 string, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreRepoNameFunc) PushReturn(r0 string, r1 error) {
	f.PushHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

func (f *DBStoreRepoNameFunc) nextHook() func(context.Context, int) (string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreRepoNameFunc) appendCall(r0 DBStoreRepoNameFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreRepoNameFuncCall objects describing
// the invocations of this function.
func (f *DBStoreRepoNameFunc) History() []DBStoreRepoNameFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreRepoNameFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreRepoNameFuncCall is an object that describes an invocation of
// method RepoName on an instance of MockDBStore.
type DBStoreRepoNameFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreRepoNameFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreRepoNameFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreRequeueFunc describes the behavior when the Requeue method of the
// parent MockDBStore instance is invoked.
type DBStoreRequeueFunc struct {
	defaultHook func(context.Context, int, time.Time) error
	hooks       []func(context.Context, int, time.Time) error
	history     []DBStoreRequeueFuncCall
	mutex       sync.Mutex
}

// Requeue delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) Requeue(v0 context.Context, v1 int, v2 time.Time) error {
	r0 := m.RequeueFunc.nextHook()(v0, v1, v2)
	m.RequeueFunc.appendCall(DBStoreRequeueFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Requeue method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreRequeueFunc) SetDefaultHook(hook func(context.Context, int, time.Time) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Requeue method of the parent MockDBStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *DBStoreRequeueFunc) PushHook(hook func(context.Context, int, time.Time) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreRequeueFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreRequeueFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

func (f *DBStoreRequeueFunc) nextHook() func(context.Context, int, time.Time) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreRequeueFunc) appendCall(r0 DBStoreRequeueFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreRequeueFuncCall objects describing
// the invocations of this function.
func (f *DBStoreRequeueFunc) History() []DBStoreRequeueFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreRequeueFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreRequeueFuncCall is an object that describes an invocation of
// method Requeue on an instance of MockDBStore.
type DBStoreRequeueFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreRequeueFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreRequeueFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreTransactFunc describes the behavior when the Transact method of
// the parent MockDBStore instance is invoked.
type DBStoreTransactFunc struct {
	defaultHook func(context.Context) (DBStore, error)
	hooks       []func(context.Context) (DBStore, error)
	history     []DBStoreTransactFuncCall
	mutex       sync.Mutex
}

// Transact delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) Transact(v0 context.Context) (DBStore, error) {
	r0, r1 := m.TransactFunc.nextHook()(v0)
	m.TransactFunc.appendCall(DBStoreTransactFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Transact method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreTransactFunc) SetDefaultHook(hook func(context.Context) (DBStore, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Transact method of the parent MockDBStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreTransactFunc) PushHook(hook func(context.Context) (DBStore, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreTransactFunc) SetDefaultReturn(r0 DBStore, r1 error) {
	f.SetDefaultHook(func(context.Context) (DBStore, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreTransactFunc) PushReturn(r0 DBStore, r1 error) {
	f.PushHook(func(context.Context) (DBStore, error) {
		return r0, r1
	})
}

func (f *DBStoreTransactFunc) nextHook() func(context.Context) (DBStore, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreTransactFunc) appendCall(r0 DBStoreTransactFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreTransactFuncCall objects describing
// the invocations of this function.
func (f *DBStoreTransactFunc) History() []DBStoreTransactFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreTransactFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreTransactFuncCall is an object that describes an invocation of
// method Transact on an instance of MockDBStore.
type DBStoreTransactFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 DBStore
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreTransactFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreTransactFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreUpdatePackageReferencesFunc describes the behavior when the
// UpdatePackageReferences method of the parent MockDBStore instance is
// invoked.
type DBStoreUpdatePackageReferencesFunc struct {
	defaultHook func(context.Context, []lsifstore.PackageReference) error
	hooks       []func(context.Context, []lsifstore.PackageReference) error
	history     []DBStoreUpdatePackageReferencesFuncCall
	mutex       sync.Mutex
}

// UpdatePackageReferences delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) UpdatePackageReferences(v0 context.Context, v1 []lsifstore.PackageReference) error {
	r0 := m.UpdatePackageReferencesFunc.nextHook()(v0, v1)
	m.UpdatePackageReferencesFunc.appendCall(DBStoreUpdatePackageReferencesFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdatePackageReferences method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreUpdatePackageReferencesFunc) SetDefaultHook(hook func(context.Context, []lsifstore.PackageReference) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdatePackageReferences method of the parent MockDBStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreUpdatePackageReferencesFunc) PushHook(hook func(context.Context, []lsifstore.PackageReference) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreUpdatePackageReferencesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, []lsifstore.PackageReference) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreUpdatePackageReferencesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, []lsifstore.PackageReference) error {
		return r0
	})
}

func (f *DBStoreUpdatePackageReferencesFunc) nextHook() func(context.Context, []lsifstore.PackageReference) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreUpdatePackageReferencesFunc) appendCall(r0 DBStoreUpdatePackageReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreUpdatePackageReferencesFuncCall
// objects describing the invocations of this function.
func (f *DBStoreUpdatePackageReferencesFunc) History() []DBStoreUpdatePackageReferencesFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreUpdatePackageReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreUpdatePackageReferencesFuncCall is an object that describes an
// invocation of method UpdatePackageReferences on an instance of
// MockDBStore.
type DBStoreUpdatePackageReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []lsifstore.PackageReference
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreUpdatePackageReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreUpdatePackageReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreUpdatePackagesFunc describes the behavior when the UpdatePackages
// method of the parent MockDBStore instance is invoked.
type DBStoreUpdatePackagesFunc struct {
	defaultHook func(context.Context, []lsifstore.Package) error
	hooks       []func(context.Context, []lsifstore.Package) error
	history     []DBStoreUpdatePackagesFuncCall
	mutex       sync.Mutex
}

// UpdatePackages delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) UpdatePackages(v0 context.Context, v1 []lsifstore.Package) error {
	r0 := m.UpdatePackagesFunc.nextHook()(v0, v1)
	m.UpdatePackagesFunc.appendCall(DBStoreUpdatePackagesFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the UpdatePackages
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreUpdatePackagesFunc) SetDefaultHook(hook func(context.Context, []lsifstore.Package) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdatePackages method of the parent MockDBStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreUpdatePackagesFunc) PushHook(hook func(context.Context, []lsifstore.Package) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreUpdatePackagesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, []lsifstore.Package) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreUpdatePackagesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, []lsifstore.Package) error {
		return r0
	})
}

func (f *DBStoreUpdatePackagesFunc) nextHook() func(context.Context, []lsifstore.Package) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreUpdatePackagesFunc) appendCall(r0 DBStoreUpdatePackagesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreUpdatePackagesFuncCall objects
// describing the invocations of this function.
func (f *DBStoreUpdatePackagesFunc) History() []DBStoreUpdatePackagesFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreUpdatePackagesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreUpdatePackagesFuncCall is an object that describes an invocation
// of method UpdatePackages on an instance of MockDBStore.
type DBStoreUpdatePackagesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []lsifstore.Package
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreUpdatePackagesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreUpdatePackagesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreWithFunc describes the behavior when the With method of the parent
// MockDBStore instance is invoked.
type DBStoreWithFunc struct {
	defaultHook func(basestore.ShareableStore) DBStore
	hooks       []func(basestore.ShareableStore) DBStore
	history     []DBStoreWithFuncCall
	mutex       sync.Mutex
}

// With delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) With(v0 basestore.ShareableStore) DBStore {
	r0 := m.WithFunc.nextHook()(v0)
	m.WithFunc.appendCall(DBStoreWithFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the With method of the
// parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreWithFunc) SetDefaultHook(hook func(basestore.ShareableStore) DBStore) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// With method of the parent MockDBStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *DBStoreWithFunc) PushHook(hook func(basestore.ShareableStore) DBStore) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreWithFunc) SetDefaultReturn(r0 DBStore) {
	f.SetDefaultHook(func(basestore.ShareableStore) DBStore {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreWithFunc) PushReturn(r0 DBStore) {
	f.PushHook(func(basestore.ShareableStore) DBStore {
		return r0
	})
}

func (f *DBStoreWithFunc) nextHook() func(basestore.ShareableStore) DBStore {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreWithFunc) appendCall(r0 DBStoreWithFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreWithFuncCall objects describing the
// invocations of this function.
func (f *DBStoreWithFunc) History() []DBStoreWithFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreWithFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreWithFuncCall is an object that describes an invocation of method
// With on an instance of MockDBStore.
type DBStoreWithFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 basestore.ShareableStore
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 DBStore
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreWithFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreWithFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// MockGitserverClient is a mock implementation of the GitserverClient
// interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/precise-code-intel-worker/internal/worker)
// used for unit testing.
type MockGitserverClient struct {
	// DirectoryChildrenFunc is an instance of a mock function object
	// controlling the behavior of the method DirectoryChildren.
	DirectoryChildrenFunc *GitserverClientDirectoryChildrenFunc
}

// NewMockGitserverClient creates a new mock of the GitserverClient
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockGitserverClient() *MockGitserverClient {
	return &MockGitserverClient{
		DirectoryChildrenFunc: &GitserverClientDirectoryChildrenFunc{
			defaultHook: func(context.Context, gitserver.DBStore, int, string, []string) (map[string][]string, error) {
				return nil, nil
			},
		},
	}
}

// NewMockGitserverClientFrom creates a new mock of the MockGitserverClient
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockGitserverClientFrom(i GitserverClient) *MockGitserverClient {
	return &MockGitserverClient{
		DirectoryChildrenFunc: &GitserverClientDirectoryChildrenFunc{
			defaultHook: i.DirectoryChildren,
		},
	}
}

// GitserverClientDirectoryChildrenFunc describes the behavior when the
// DirectoryChildren method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientDirectoryChildrenFunc struct {
	defaultHook func(context.Context, gitserver.DBStore, int, string, []string) (map[string][]string, error)
	hooks       []func(context.Context, gitserver.DBStore, int, string, []string) (map[string][]string, error)
	history     []GitserverClientDirectoryChildrenFuncCall
	mutex       sync.Mutex
}

// DirectoryChildren delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockGitserverClient) DirectoryChildren(v0 context.Context, v1 gitserver.DBStore, v2 int, v3 string, v4 []string) (map[string][]string, error) {
	r0, r1 := m.DirectoryChildrenFunc.nextHook()(v0, v1, v2, v3, v4)
	m.DirectoryChildrenFunc.appendCall(GitserverClientDirectoryChildrenFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DirectoryChildren
// method of the parent MockGitserverClient instance is invoked and the hook
// queue is empty.
func (f *GitserverClientDirectoryChildrenFunc) SetDefaultHook(hook func(context.Context, gitserver.DBStore, int, string, []string) (map[string][]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DirectoryChildren method of the parent MockGitserverClient instance
// inovkes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *GitserverClientDirectoryChildrenFunc) PushHook(hook func(context.Context, gitserver.DBStore, int, string, []string) (map[string][]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *GitserverClientDirectoryChildrenFunc) SetDefaultReturn(r0 map[string][]string, r1 error) {
	f.SetDefaultHook(func(context.Context, gitserver.DBStore, int, string, []string) (map[string][]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *GitserverClientDirectoryChildrenFunc) PushReturn(r0 map[string][]string, r1 error) {
	f.PushHook(func(context.Context, gitserver.DBStore, int, string, []string) (map[string][]string, error) {
		return r0, r1
	})
}

func (f *GitserverClientDirectoryChildrenFunc) nextHook() func(context.Context, gitserver.DBStore, int, string, []string) (map[string][]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientDirectoryChildrenFunc) appendCall(r0 GitserverClientDirectoryChildrenFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientDirectoryChildrenFuncCall
// objects describing the invocations of this function.
func (f *GitserverClientDirectoryChildrenFunc) History() []GitserverClientDirectoryChildrenFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientDirectoryChildrenFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientDirectoryChildrenFuncCall is an object that describes an
// invocation of method DirectoryChildren on an instance of
// MockGitserverClient.
type GitserverClientDirectoryChildrenFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 gitserver.DBStore
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 []string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[string][]string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientDirectoryChildrenFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientDirectoryChildrenFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockLSIFStore is a mock implementation of the LSIFStore interface (from
// the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/precise-code-intel-worker/internal/worker)
// used for unit testing.
type MockLSIFStore struct {
	// DoneFunc is an instance of a mock function object controlling the
	// behavior of the method Done.
	DoneFunc *LSIFStoreDoneFunc
	// TransactFunc is an instance of a mock function object controlling the
	// behavior of the method Transact.
	TransactFunc *LSIFStoreTransactFunc
	// WriteDefinitionsFunc is an instance of a mock function object
	// controlling the behavior of the method WriteDefinitions.
	WriteDefinitionsFunc *LSIFStoreWriteDefinitionsFunc
	// WriteDocumentsFunc is an instance of a mock function object
	// controlling the behavior of the method WriteDocuments.
	WriteDocumentsFunc *LSIFStoreWriteDocumentsFunc
	// WriteMetaFunc is an instance of a mock function object controlling
	// the behavior of the method WriteMeta.
	WriteMetaFunc *LSIFStoreWriteMetaFunc
	// WriteReferencesFunc is an instance of a mock function object
	// controlling the behavior of the method WriteReferences.
	WriteReferencesFunc *LSIFStoreWriteReferencesFunc
	// WriteResultChunksFunc is an instance of a mock function object
	// controlling the behavior of the method WriteResultChunks.
	WriteResultChunksFunc *LSIFStoreWriteResultChunksFunc
}

// NewMockLSIFStore creates a new mock of the LSIFStore interface. All
// methods return zero values for all results, unless overwritten.
func NewMockLSIFStore() *MockLSIFStore {
	return &MockLSIFStore{
		DoneFunc: &LSIFStoreDoneFunc{
			defaultHook: func(error) error {
				return nil
			},
		},
		TransactFunc: &LSIFStoreTransactFunc{
			defaultHook: func(context.Context) (LSIFStore, error) {
				return nil, nil
			},
		},
		WriteDefinitionsFunc: &LSIFStoreWriteDefinitionsFunc{
			defaultHook: func(context.Context, int, chan lsifstore.MonikerLocations) error {
				return nil
			},
		},
		WriteDocumentsFunc: &LSIFStoreWriteDocumentsFunc{
			defaultHook: func(context.Context, int, chan lsifstore.KeyedDocumentData) error {
				return nil
			},
		},
		WriteMetaFunc: &LSIFStoreWriteMetaFunc{
			defaultHook: func(context.Context, int, lsifstore.MetaData) error {
				return nil
			},
		},
		WriteReferencesFunc: &LSIFStoreWriteReferencesFunc{
			defaultHook: func(context.Context, int, chan lsifstore.MonikerLocations) error {
				return nil
			},
		},
		WriteResultChunksFunc: &LSIFStoreWriteResultChunksFunc{
			defaultHook: func(context.Context, int, chan lsifstore.IndexedResultChunkData) error {
				return nil
			},
		},
	}
}

// NewMockLSIFStoreFrom creates a new mock of the MockLSIFStore interface.
// All methods delegate to the given implementation, unless overwritten.
func NewMockLSIFStoreFrom(i LSIFStore) *MockLSIFStore {
	return &MockLSIFStore{
		DoneFunc: &LSIFStoreDoneFunc{
			defaultHook: i.Done,
		},
		TransactFunc: &LSIFStoreTransactFunc{
			defaultHook: i.Transact,
		},
		WriteDefinitionsFunc: &LSIFStoreWriteDefinitionsFunc{
			defaultHook: i.WriteDefinitions,
		},
		WriteDocumentsFunc: &LSIFStoreWriteDocumentsFunc{
			defaultHook: i.WriteDocuments,
		},
		WriteMetaFunc: &LSIFStoreWriteMetaFunc{
			defaultHook: i.WriteMeta,
		},
		WriteReferencesFunc: &LSIFStoreWriteReferencesFunc{
			defaultHook: i.WriteReferences,
		},
		WriteResultChunksFunc: &LSIFStoreWriteResultChunksFunc{
			defaultHook: i.WriteResultChunks,
		},
	}
}

// LSIFStoreDoneFunc describes the behavior when the Done method of the
// parent MockLSIFStore instance is invoked.
type LSIFStoreDoneFunc struct {
	defaultHook func(error) error
	hooks       []func(error) error
	history     []LSIFStoreDoneFuncCall
	mutex       sync.Mutex
}

// Done delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) Done(v0 error) error {
	r0 := m.DoneFunc.nextHook()(v0)
	m.DoneFunc.appendCall(LSIFStoreDoneFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Done method of the
// parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreDoneFunc) SetDefaultHook(hook func(error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Done method of the parent MockLSIFStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *LSIFStoreDoneFunc) PushHook(hook func(error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreDoneFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(error) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreDoneFunc) PushReturn(r0 error) {
	f.PushHook(func(error) error {
		return r0
	})
}

func (f *LSIFStoreDoneFunc) nextHook() func(error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreDoneFunc) appendCall(r0 LSIFStoreDoneFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreDoneFuncCall objects describing
// the invocations of this function.
func (f *LSIFStoreDoneFunc) History() []LSIFStoreDoneFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreDoneFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreDoneFuncCall is an object that describes an invocation of method
// Done on an instance of MockLSIFStore.
type LSIFStoreDoneFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreDoneFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreDoneFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreTransactFunc describes the behavior when the Transact method of
// the parent MockLSIFStore instance is invoked.
type LSIFStoreTransactFunc struct {
	defaultHook func(context.Context) (LSIFStore, error)
	hooks       []func(context.Context) (LSIFStore, error)
	history     []LSIFStoreTransactFuncCall
	mutex       sync.Mutex
}

// Transact delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) Transact(v0 context.Context) (LSIFStore, error) {
	r0, r1 := m.TransactFunc.nextHook()(v0)
	m.TransactFunc.appendCall(LSIFStoreTransactFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Transact method of
// the parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreTransactFunc) SetDefaultHook(hook func(context.Context) (LSIFStore, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Transact method of the parent MockLSIFStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreTransactFunc) PushHook(hook func(context.Context) (LSIFStore, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreTransactFunc) SetDefaultReturn(r0 LSIFStore, r1 error) {
	f.SetDefaultHook(func(context.Context) (LSIFStore, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreTransactFunc) PushReturn(r0 LSIFStore, r1 error) {
	f.PushHook(func(context.Context) (LSIFStore, error) {
		return r0, r1
	})
}

func (f *LSIFStoreTransactFunc) nextHook() func(context.Context) (LSIFStore, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreTransactFunc) appendCall(r0 LSIFStoreTransactFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreTransactFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreTransactFunc) History() []LSIFStoreTransactFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreTransactFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreTransactFuncCall is an object that describes an invocation of
// method Transact on an instance of MockLSIFStore.
type LSIFStoreTransactFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 LSIFStore
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreTransactFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreTransactFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStoreWriteDefinitionsFunc describes the behavior when the
// WriteDefinitions method of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteDefinitionsFunc struct {
	defaultHook func(context.Context, int, chan lsifstore.MonikerLocations) error
	hooks       []func(context.Context, int, chan lsifstore.MonikerLocations) error
	history     []LSIFStoreWriteDefinitionsFuncCall
	mutex       sync.Mutex
}

// WriteDefinitions delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteDefinitions(v0 context.Context, v1 int, v2 chan lsifstore.MonikerLocations) error {
	r0 := m.WriteDefinitionsFunc.nextHook()(v0, v1, v2)
	m.WriteDefinitionsFunc.appendCall(LSIFStoreWriteDefinitionsFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteDefinitions
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreWriteDefinitionsFunc) SetDefaultHook(hook func(context.Context, int, chan lsifstore.MonikerLocations) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteDefinitions method of the parent MockLSIFStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreWriteDefinitionsFunc) PushHook(hook func(context.Context, int, chan lsifstore.MonikerLocations) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteDefinitionsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan lsifstore.MonikerLocations) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteDefinitionsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan lsifstore.MonikerLocations) error {
		return r0
	})
}

func (f *LSIFStoreWriteDefinitionsFunc) nextHook() func(context.Context, int, chan lsifstore.MonikerLocations) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteDefinitionsFunc) appendCall(r0 LSIFStoreWriteDefinitionsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteDefinitionsFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteDefinitionsFunc) History() []LSIFStoreWriteDefinitionsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteDefinitionsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteDefinitionsFuncCall is an object that describes an
// invocation of method WriteDefinitions on an instance of MockLSIFStore.
type LSIFStoreWriteDefinitionsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan lsifstore.MonikerLocations
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteDefinitionsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteDefinitionsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreWriteDocumentsFunc describes the behavior when the
// WriteDocuments method of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteDocumentsFunc struct {
	defaultHook func(context.Context, int, chan lsifstore.KeyedDocumentData) error
	hooks       []func(context.Context, int, chan lsifstore.KeyedDocumentData) error
	history     []LSIFStoreWriteDocumentsFuncCall
	mutex       sync.Mutex
}

// WriteDocuments delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteDocuments(v0 context.Context, v1 int, v2 chan lsifstore.KeyedDocumentData) error {
	r0 := m.WriteDocumentsFunc.nextHook()(v0, v1, v2)
	m.WriteDocumentsFunc.appendCall(LSIFStoreWriteDocumentsFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteDocuments
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreWriteDocumentsFunc) SetDefaultHook(hook func(context.Context, int, chan lsifstore.KeyedDocumentData) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteDocuments method of the parent MockLSIFStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreWriteDocumentsFunc) PushHook(hook func(context.Context, int, chan lsifstore.KeyedDocumentData) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteDocumentsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan lsifstore.KeyedDocumentData) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteDocumentsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan lsifstore.KeyedDocumentData) error {
		return r0
	})
}

func (f *LSIFStoreWriteDocumentsFunc) nextHook() func(context.Context, int, chan lsifstore.KeyedDocumentData) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteDocumentsFunc) appendCall(r0 LSIFStoreWriteDocumentsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteDocumentsFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteDocumentsFunc) History() []LSIFStoreWriteDocumentsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteDocumentsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteDocumentsFuncCall is an object that describes an invocation
// of method WriteDocuments on an instance of MockLSIFStore.
type LSIFStoreWriteDocumentsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan lsifstore.KeyedDocumentData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteDocumentsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteDocumentsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreWriteMetaFunc describes the behavior when the WriteMeta method
// of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteMetaFunc struct {
	defaultHook func(context.Context, int, lsifstore.MetaData) error
	hooks       []func(context.Context, int, lsifstore.MetaData) error
	history     []LSIFStoreWriteMetaFuncCall
	mutex       sync.Mutex
}

// WriteMeta delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) WriteMeta(v0 context.Context, v1 int, v2 lsifstore.MetaData) error {
	r0 := m.WriteMetaFunc.nextHook()(v0, v1, v2)
	m.WriteMetaFunc.appendCall(LSIFStoreWriteMetaFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteMeta method of
// the parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreWriteMetaFunc) SetDefaultHook(hook func(context.Context, int, lsifstore.MetaData) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteMeta method of the parent MockLSIFStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreWriteMetaFunc) PushHook(hook func(context.Context, int, lsifstore.MetaData) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteMetaFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, lsifstore.MetaData) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteMetaFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, lsifstore.MetaData) error {
		return r0
	})
}

func (f *LSIFStoreWriteMetaFunc) nextHook() func(context.Context, int, lsifstore.MetaData) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteMetaFunc) appendCall(r0 LSIFStoreWriteMetaFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteMetaFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteMetaFunc) History() []LSIFStoreWriteMetaFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteMetaFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteMetaFuncCall is an object that describes an invocation of
// method WriteMeta on an instance of MockLSIFStore.
type LSIFStoreWriteMetaFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 lsifstore.MetaData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteMetaFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteMetaFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreWriteReferencesFunc describes the behavior when the
// WriteReferences method of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteReferencesFunc struct {
	defaultHook func(context.Context, int, chan lsifstore.MonikerLocations) error
	hooks       []func(context.Context, int, chan lsifstore.MonikerLocations) error
	history     []LSIFStoreWriteReferencesFuncCall
	mutex       sync.Mutex
}

// WriteReferences delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteReferences(v0 context.Context, v1 int, v2 chan lsifstore.MonikerLocations) error {
	r0 := m.WriteReferencesFunc.nextHook()(v0, v1, v2)
	m.WriteReferencesFunc.appendCall(LSIFStoreWriteReferencesFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteReferences
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreWriteReferencesFunc) SetDefaultHook(hook func(context.Context, int, chan lsifstore.MonikerLocations) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteReferences method of the parent MockLSIFStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreWriteReferencesFunc) PushHook(hook func(context.Context, int, chan lsifstore.MonikerLocations) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteReferencesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan lsifstore.MonikerLocations) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteReferencesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan lsifstore.MonikerLocations) error {
		return r0
	})
}

func (f *LSIFStoreWriteReferencesFunc) nextHook() func(context.Context, int, chan lsifstore.MonikerLocations) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteReferencesFunc) appendCall(r0 LSIFStoreWriteReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteReferencesFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteReferencesFunc) History() []LSIFStoreWriteReferencesFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteReferencesFuncCall is an object that describes an
// invocation of method WriteReferences on an instance of MockLSIFStore.
type LSIFStoreWriteReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan lsifstore.MonikerLocations
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreWriteResultChunksFunc describes the behavior when the
// WriteResultChunks method of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteResultChunksFunc struct {
	defaultHook func(context.Context, int, chan lsifstore.IndexedResultChunkData) error
	hooks       []func(context.Context, int, chan lsifstore.IndexedResultChunkData) error
	history     []LSIFStoreWriteResultChunksFuncCall
	mutex       sync.Mutex
}

// WriteResultChunks delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteResultChunks(v0 context.Context, v1 int, v2 chan lsifstore.IndexedResultChunkData) error {
	r0 := m.WriteResultChunksFunc.nextHook()(v0, v1, v2)
	m.WriteResultChunksFunc.appendCall(LSIFStoreWriteResultChunksFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteResultChunks
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreWriteResultChunksFunc) SetDefaultHook(hook func(context.Context, int, chan lsifstore.IndexedResultChunkData) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteResultChunks method of the parent MockLSIFStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreWriteResultChunksFunc) PushHook(hook func(context.Context, int, chan lsifstore.IndexedResultChunkData) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteResultChunksFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan lsifstore.IndexedResultChunkData) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteResultChunksFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan lsifstore.IndexedResultChunkData) error {
		return r0
	})
}

func (f *LSIFStoreWriteResultChunksFunc) nextHook() func(context.Context, int, chan lsifstore.IndexedResultChunkData) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteResultChunksFunc) appendCall(r0 LSIFStoreWriteResultChunksFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteResultChunksFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteResultChunksFunc) History() []LSIFStoreWriteResultChunksFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteResultChunksFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteResultChunksFuncCall is an object that describes an
// invocation of method WriteResultChunks on an instance of MockLSIFStore.
type LSIFStoreWriteResultChunksFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan lsifstore.IndexedResultChunkData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteResultChunksFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteResultChunksFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}
