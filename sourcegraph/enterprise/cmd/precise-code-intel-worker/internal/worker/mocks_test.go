// Code generated by go-mockgen 1.3.3; DO NOT EDIT.
//
// This file was generated by running `sg generate` (or `go-mockgen`) at the root of
// this repository. To add additional mocks to this or another package, add a new entry
// to the mockgen.yaml file in the root of this repository.

package worker

import (
	"context"
	"sync"
	"time"

	sqlf "github.com/keegancsmith/sqlf"
	api "github.com/sourcegraph/sourcegraph/internal/api"
	dbstore "github.com/sourcegraph/sourcegraph/internal/codeintel/stores/dbstore"
	basestore "github.com/sourcegraph/sourcegraph/internal/database/basestore"
	workerutil "github.com/sourcegraph/sourcegraph/internal/workerutil"
	store "github.com/sourcegraph/sourcegraph/internal/workerutil/dbworker/store"
	precise "github.com/sourcegraph/sourcegraph/lib/codeintel/precise"
)

// MockDBStore is a mock implementation of the DBStore interface (from the
// package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/precise-code-intel-worker/internal/worker)
// used for unit testing.
type MockDBStore struct {
	// DeleteOverlappingDumpsFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteOverlappingDumps.
	DeleteOverlappingDumpsFunc *DBStoreDeleteOverlappingDumpsFunc
	// DoneFunc is an instance of a mock function object controlling the
	// behavior of the method Done.
	DoneFunc *DBStoreDoneFunc
	// HandleFunc is an instance of a mock function object controlling the
	// behavior of the method Handle.
	HandleFunc *DBStoreHandleFunc
	// InsertDependencySyncingJobFunc is an instance of a mock function
	// object controlling the behavior of the method
	// InsertDependencySyncingJob.
	InsertDependencySyncingJobFunc *DBStoreInsertDependencySyncingJobFunc
	// MarkRepositoryAsDirtyFunc is an instance of a mock function object
	// controlling the behavior of the method MarkRepositoryAsDirty.
	MarkRepositoryAsDirtyFunc *DBStoreMarkRepositoryAsDirtyFunc
	// RepoNameFunc is an instance of a mock function object controlling the
	// behavior of the method RepoName.
	RepoNameFunc *DBStoreRepoNameFunc
	// RepoNamesFunc is an instance of a mock function object controlling
	// the behavior of the method RepoNames.
	RepoNamesFunc *DBStoreRepoNamesFunc
	// TransactFunc is an instance of a mock function object controlling the
	// behavior of the method Transact.
	TransactFunc *DBStoreTransactFunc
	// UpdateCommitedAtFunc is an instance of a mock function object
	// controlling the behavior of the method UpdateCommitedAt.
	UpdateCommitedAtFunc *DBStoreUpdateCommitedAtFunc
	// UpdatePackageReferencesFunc is an instance of a mock function object
	// controlling the behavior of the method UpdatePackageReferences.
	UpdatePackageReferencesFunc *DBStoreUpdatePackageReferencesFunc
	// UpdatePackagesFunc is an instance of a mock function object
	// controlling the behavior of the method UpdatePackages.
	UpdatePackagesFunc *DBStoreUpdatePackagesFunc
	// UpdateReferenceCountsFunc is an instance of a mock function object
	// controlling the behavior of the method UpdateReferenceCounts.
	UpdateReferenceCountsFunc *DBStoreUpdateReferenceCountsFunc
	// WithFunc is an instance of a mock function object controlling the
	// behavior of the method With.
	WithFunc *DBStoreWithFunc
}

// NewMockDBStore creates a new mock of the DBStore interface. All methods
// return zero values for all results, unless overwritten.
func NewMockDBStore() *MockDBStore {
	return &MockDBStore{
		DeleteOverlappingDumpsFunc: &DBStoreDeleteOverlappingDumpsFunc{
			defaultHook: func(context.Context, int, string, string, string) (r0 error) {
				return
			},
		},
		DoneFunc: &DBStoreDoneFunc{
			defaultHook: func(error) (r0 error) {
				return
			},
		},
		HandleFunc: &DBStoreHandleFunc{
			defaultHook: func() (r0 basestore.TransactableHandle) {
				return
			},
		},
		InsertDependencySyncingJobFunc: &DBStoreInsertDependencySyncingJobFunc{
			defaultHook: func(context.Context, int) (r0 int, r1 error) {
				return
			},
		},
		MarkRepositoryAsDirtyFunc: &DBStoreMarkRepositoryAsDirtyFunc{
			defaultHook: func(context.Context, int) (r0 error) {
				return
			},
		},
		RepoNameFunc: &DBStoreRepoNameFunc{
			defaultHook: func(context.Context, int) (r0 string, r1 error) {
				return
			},
		},
		RepoNamesFunc: &DBStoreRepoNamesFunc{
			defaultHook: func(context.Context, ...int) (r0 map[int]string, r1 error) {
				return
			},
		},
		TransactFunc: &DBStoreTransactFunc{
			defaultHook: func(context.Context) (r0 DBStore, r1 error) {
				return
			},
		},
		UpdateCommitedAtFunc: &DBStoreUpdateCommitedAtFunc{
			defaultHook: func(context.Context, int, time.Time) (r0 error) {
				return
			},
		},
		UpdatePackageReferencesFunc: &DBStoreUpdatePackageReferencesFunc{
			defaultHook: func(context.Context, int, []precise.PackageReference) (r0 error) {
				return
			},
		},
		UpdatePackagesFunc: &DBStoreUpdatePackagesFunc{
			defaultHook: func(context.Context, int, []precise.Package) (r0 error) {
				return
			},
		},
		UpdateReferenceCountsFunc: &DBStoreUpdateReferenceCountsFunc{
			defaultHook: func(context.Context, []int, dbstore.DependencyReferenceCountUpdateType) (r0 int, r1 error) {
				return
			},
		},
		WithFunc: &DBStoreWithFunc{
			defaultHook: func(basestore.ShareableStore) (r0 DBStore) {
				return
			},
		},
	}
}

// NewStrictMockDBStore creates a new mock of the DBStore interface. All
// methods panic on invocation, unless overwritten.
func NewStrictMockDBStore() *MockDBStore {
	return &MockDBStore{
		DeleteOverlappingDumpsFunc: &DBStoreDeleteOverlappingDumpsFunc{
			defaultHook: func(context.Context, int, string, string, string) error {
				panic("unexpected invocation of MockDBStore.DeleteOverlappingDumps")
			},
		},
		DoneFunc: &DBStoreDoneFunc{
			defaultHook: func(error) error {
				panic("unexpected invocation of MockDBStore.Done")
			},
		},
		HandleFunc: &DBStoreHandleFunc{
			defaultHook: func() basestore.TransactableHandle {
				panic("unexpected invocation of MockDBStore.Handle")
			},
		},
		InsertDependencySyncingJobFunc: &DBStoreInsertDependencySyncingJobFunc{
			defaultHook: func(context.Context, int) (int, error) {
				panic("unexpected invocation of MockDBStore.InsertDependencySyncingJob")
			},
		},
		MarkRepositoryAsDirtyFunc: &DBStoreMarkRepositoryAsDirtyFunc{
			defaultHook: func(context.Context, int) error {
				panic("unexpected invocation of MockDBStore.MarkRepositoryAsDirty")
			},
		},
		RepoNameFunc: &DBStoreRepoNameFunc{
			defaultHook: func(context.Context, int) (string, error) {
				panic("unexpected invocation of MockDBStore.RepoName")
			},
		},
		RepoNamesFunc: &DBStoreRepoNamesFunc{
			defaultHook: func(context.Context, ...int) (map[int]string, error) {
				panic("unexpected invocation of MockDBStore.RepoNames")
			},
		},
		TransactFunc: &DBStoreTransactFunc{
			defaultHook: func(context.Context) (DBStore, error) {
				panic("unexpected invocation of MockDBStore.Transact")
			},
		},
		UpdateCommitedAtFunc: &DBStoreUpdateCommitedAtFunc{
			defaultHook: func(context.Context, int, time.Time) error {
				panic("unexpected invocation of MockDBStore.UpdateCommitedAt")
			},
		},
		UpdatePackageReferencesFunc: &DBStoreUpdatePackageReferencesFunc{
			defaultHook: func(context.Context, int, []precise.PackageReference) error {
				panic("unexpected invocation of MockDBStore.UpdatePackageReferences")
			},
		},
		UpdatePackagesFunc: &DBStoreUpdatePackagesFunc{
			defaultHook: func(context.Context, int, []precise.Package) error {
				panic("unexpected invocation of MockDBStore.UpdatePackages")
			},
		},
		UpdateReferenceCountsFunc: &DBStoreUpdateReferenceCountsFunc{
			defaultHook: func(context.Context, []int, dbstore.DependencyReferenceCountUpdateType) (int, error) {
				panic("unexpected invocation of MockDBStore.UpdateReferenceCounts")
			},
		},
		WithFunc: &DBStoreWithFunc{
			defaultHook: func(basestore.ShareableStore) DBStore {
				panic("unexpected invocation of MockDBStore.With")
			},
		},
	}
}

// NewMockDBStoreFrom creates a new mock of the MockDBStore interface. All
// methods delegate to the given implementation, unless overwritten.
func NewMockDBStoreFrom(i DBStore) *MockDBStore {
	return &MockDBStore{
		DeleteOverlappingDumpsFunc: &DBStoreDeleteOverlappingDumpsFunc{
			defaultHook: i.DeleteOverlappingDumps,
		},
		DoneFunc: &DBStoreDoneFunc{
			defaultHook: i.Done,
		},
		HandleFunc: &DBStoreHandleFunc{
			defaultHook: i.Handle,
		},
		InsertDependencySyncingJobFunc: &DBStoreInsertDependencySyncingJobFunc{
			defaultHook: i.InsertDependencySyncingJob,
		},
		MarkRepositoryAsDirtyFunc: &DBStoreMarkRepositoryAsDirtyFunc{
			defaultHook: i.MarkRepositoryAsDirty,
		},
		RepoNameFunc: &DBStoreRepoNameFunc{
			defaultHook: i.RepoName,
		},
		RepoNamesFunc: &DBStoreRepoNamesFunc{
			defaultHook: i.RepoNames,
		},
		TransactFunc: &DBStoreTransactFunc{
			defaultHook: i.Transact,
		},
		UpdateCommitedAtFunc: &DBStoreUpdateCommitedAtFunc{
			defaultHook: i.UpdateCommitedAt,
		},
		UpdatePackageReferencesFunc: &DBStoreUpdatePackageReferencesFunc{
			defaultHook: i.UpdatePackageReferences,
		},
		UpdatePackagesFunc: &DBStoreUpdatePackagesFunc{
			defaultHook: i.UpdatePackages,
		},
		UpdateReferenceCountsFunc: &DBStoreUpdateReferenceCountsFunc{
			defaultHook: i.UpdateReferenceCounts,
		},
		WithFunc: &DBStoreWithFunc{
			defaultHook: i.With,
		},
	}
}

// DBStoreDeleteOverlappingDumpsFunc describes the behavior when the
// DeleteOverlappingDumps method of the parent MockDBStore instance is
// invoked.
type DBStoreDeleteOverlappingDumpsFunc struct {
	defaultHook func(context.Context, int, string, string, string) error
	hooks       []func(context.Context, int, string, string, string) error
	history     []DBStoreDeleteOverlappingDumpsFuncCall
	mutex       sync.Mutex
}

// DeleteOverlappingDumps delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) DeleteOverlappingDumps(v0 context.Context, v1 int, v2 string, v3 string, v4 string) error {
	r0 := m.DeleteOverlappingDumpsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.DeleteOverlappingDumpsFunc.appendCall(DBStoreDeleteOverlappingDumpsFuncCall{v0, v1, v2, v3, v4, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// DeleteOverlappingDumps method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreDeleteOverlappingDumpsFunc) SetDefaultHook(hook func(context.Context, int, string, string, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteOverlappingDumps method of the parent MockDBStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreDeleteOverlappingDumpsFunc) PushHook(hook func(context.Context, int, string, string, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreDeleteOverlappingDumpsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, string) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreDeleteOverlappingDumpsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string, string, string) error {
		return r0
	})
}

func (f *DBStoreDeleteOverlappingDumpsFunc) nextHook() func(context.Context, int, string, string, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreDeleteOverlappingDumpsFunc) appendCall(r0 DBStoreDeleteOverlappingDumpsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreDeleteOverlappingDumpsFuncCall
// objects describing the invocations of this function.
func (f *DBStoreDeleteOverlappingDumpsFunc) History() []DBStoreDeleteOverlappingDumpsFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreDeleteOverlappingDumpsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreDeleteOverlappingDumpsFuncCall is an object that describes an
// invocation of method DeleteOverlappingDumps on an instance of
// MockDBStore.
type DBStoreDeleteOverlappingDumpsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreDeleteOverlappingDumpsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreDeleteOverlappingDumpsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreDoneFunc describes the behavior when the Done method of the parent
// MockDBStore instance is invoked.
type DBStoreDoneFunc struct {
	defaultHook func(error) error
	hooks       []func(error) error
	history     []DBStoreDoneFuncCall
	mutex       sync.Mutex
}

// Done delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) Done(v0 error) error {
	r0 := m.DoneFunc.nextHook()(v0)
	m.DoneFunc.appendCall(DBStoreDoneFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Done method of the
// parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreDoneFunc) SetDefaultHook(hook func(error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Done method of the parent MockDBStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *DBStoreDoneFunc) PushHook(hook func(error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreDoneFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(error) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreDoneFunc) PushReturn(r0 error) {
	f.PushHook(func(error) error {
		return r0
	})
}

func (f *DBStoreDoneFunc) nextHook() func(error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreDoneFunc) appendCall(r0 DBStoreDoneFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreDoneFuncCall objects describing the
// invocations of this function.
func (f *DBStoreDoneFunc) History() []DBStoreDoneFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreDoneFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreDoneFuncCall is an object that describes an invocation of method
// Done on an instance of MockDBStore.
type DBStoreDoneFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreDoneFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreDoneFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreHandleFunc describes the behavior when the Handle method of the
// parent MockDBStore instance is invoked.
type DBStoreHandleFunc struct {
	defaultHook func() basestore.TransactableHandle
	hooks       []func() basestore.TransactableHandle
	history     []DBStoreHandleFuncCall
	mutex       sync.Mutex
}

// Handle delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) Handle() basestore.TransactableHandle {
	r0 := m.HandleFunc.nextHook()()
	m.HandleFunc.appendCall(DBStoreHandleFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the Handle method of the
// parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreHandleFunc) SetDefaultHook(hook func() basestore.TransactableHandle) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Handle method of the parent MockDBStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *DBStoreHandleFunc) PushHook(hook func() basestore.TransactableHandle) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreHandleFunc) SetDefaultReturn(r0 basestore.TransactableHandle) {
	f.SetDefaultHook(func() basestore.TransactableHandle {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreHandleFunc) PushReturn(r0 basestore.TransactableHandle) {
	f.PushHook(func() basestore.TransactableHandle {
		return r0
	})
}

func (f *DBStoreHandleFunc) nextHook() func() basestore.TransactableHandle {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreHandleFunc) appendCall(r0 DBStoreHandleFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreHandleFuncCall objects describing
// the invocations of this function.
func (f *DBStoreHandleFunc) History() []DBStoreHandleFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreHandleFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreHandleFuncCall is an object that describes an invocation of method
// Handle on an instance of MockDBStore.
type DBStoreHandleFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 basestore.TransactableHandle
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreHandleFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreHandleFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreInsertDependencySyncingJobFunc describes the behavior when the
// InsertDependencySyncingJob method of the parent MockDBStore instance is
// invoked.
type DBStoreInsertDependencySyncingJobFunc struct {
	defaultHook func(context.Context, int) (int, error)
	hooks       []func(context.Context, int) (int, error)
	history     []DBStoreInsertDependencySyncingJobFuncCall
	mutex       sync.Mutex
}

// InsertDependencySyncingJob delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockDBStore) InsertDependencySyncingJob(v0 context.Context, v1 int) (int, error) {
	r0, r1 := m.InsertDependencySyncingJobFunc.nextHook()(v0, v1)
	m.InsertDependencySyncingJobFunc.appendCall(DBStoreInsertDependencySyncingJobFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// InsertDependencySyncingJob method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreInsertDependencySyncingJobFunc) SetDefaultHook(hook func(context.Context, int) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertDependencySyncingJob method of the parent MockDBStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *DBStoreInsertDependencySyncingJobFunc) PushHook(hook func(context.Context, int) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreInsertDependencySyncingJobFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreInsertDependencySyncingJobFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int) (int, error) {
		return r0, r1
	})
}

func (f *DBStoreInsertDependencySyncingJobFunc) nextHook() func(context.Context, int) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreInsertDependencySyncingJobFunc) appendCall(r0 DBStoreInsertDependencySyncingJobFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreInsertDependencySyncingJobFuncCall
// objects describing the invocations of this function.
func (f *DBStoreInsertDependencySyncingJobFunc) History() []DBStoreInsertDependencySyncingJobFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreInsertDependencySyncingJobFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreInsertDependencySyncingJobFuncCall is an object that describes an
// invocation of method InsertDependencySyncingJob on an instance of
// MockDBStore.
type DBStoreInsertDependencySyncingJobFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreInsertDependencySyncingJobFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreInsertDependencySyncingJobFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreMarkRepositoryAsDirtyFunc describes the behavior when the
// MarkRepositoryAsDirty method of the parent MockDBStore instance is
// invoked.
type DBStoreMarkRepositoryAsDirtyFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []DBStoreMarkRepositoryAsDirtyFuncCall
	mutex       sync.Mutex
}

// MarkRepositoryAsDirty delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) MarkRepositoryAsDirty(v0 context.Context, v1 int) error {
	r0 := m.MarkRepositoryAsDirtyFunc.nextHook()(v0, v1)
	m.MarkRepositoryAsDirtyFunc.appendCall(DBStoreMarkRepositoryAsDirtyFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// MarkRepositoryAsDirty method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreMarkRepositoryAsDirtyFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkRepositoryAsDirty method of the parent MockDBStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreMarkRepositoryAsDirtyFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreMarkRepositoryAsDirtyFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreMarkRepositoryAsDirtyFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *DBStoreMarkRepositoryAsDirtyFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreMarkRepositoryAsDirtyFunc) appendCall(r0 DBStoreMarkRepositoryAsDirtyFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreMarkRepositoryAsDirtyFuncCall
// objects describing the invocations of this function.
func (f *DBStoreMarkRepositoryAsDirtyFunc) History() []DBStoreMarkRepositoryAsDirtyFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreMarkRepositoryAsDirtyFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreMarkRepositoryAsDirtyFuncCall is an object that describes an
// invocation of method MarkRepositoryAsDirty on an instance of MockDBStore.
type DBStoreMarkRepositoryAsDirtyFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreMarkRepositoryAsDirtyFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreMarkRepositoryAsDirtyFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreRepoNameFunc describes the behavior when the RepoName method of
// the parent MockDBStore instance is invoked.
type DBStoreRepoNameFunc struct {
	defaultHook func(context.Context, int) (string, error)
	hooks       []func(context.Context, int) (string, error)
	history     []DBStoreRepoNameFuncCall
	mutex       sync.Mutex
}

// RepoName delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) RepoName(v0 context.Context, v1 int) (string, error) {
	r0, r1 := m.RepoNameFunc.nextHook()(v0, v1)
	m.RepoNameFunc.appendCall(DBStoreRepoNameFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepoName method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreRepoNameFunc) SetDefaultHook(hook func(context.Context, int) (string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoName method of the parent MockDBStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreRepoNameFunc) PushHook(hook func(context.Context, int) (string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreRepoNameFunc) SetDefaultReturn(r0 string, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreRepoNameFunc) PushReturn(r0 string, r1 error) {
	f.PushHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

func (f *DBStoreRepoNameFunc) nextHook() func(context.Context, int) (string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreRepoNameFunc) appendCall(r0 DBStoreRepoNameFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreRepoNameFuncCall objects describing
// the invocations of this function.
func (f *DBStoreRepoNameFunc) History() []DBStoreRepoNameFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreRepoNameFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreRepoNameFuncCall is an object that describes an invocation of
// method RepoName on an instance of MockDBStore.
type DBStoreRepoNameFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreRepoNameFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreRepoNameFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreRepoNamesFunc describes the behavior when the RepoNames method of
// the parent MockDBStore instance is invoked.
type DBStoreRepoNamesFunc struct {
	defaultHook func(context.Context, ...int) (map[int]string, error)
	hooks       []func(context.Context, ...int) (map[int]string, error)
	history     []DBStoreRepoNamesFuncCall
	mutex       sync.Mutex
}

// RepoNames delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) RepoNames(v0 context.Context, v1 ...int) (map[int]string, error) {
	r0, r1 := m.RepoNamesFunc.nextHook()(v0, v1...)
	m.RepoNamesFunc.appendCall(DBStoreRepoNamesFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepoNames method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreRepoNamesFunc) SetDefaultHook(hook func(context.Context, ...int) (map[int]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoNames method of the parent MockDBStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreRepoNamesFunc) PushHook(hook func(context.Context, ...int) (map[int]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreRepoNamesFunc) SetDefaultReturn(r0 map[int]string, r1 error) {
	f.SetDefaultHook(func(context.Context, ...int) (map[int]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreRepoNamesFunc) PushReturn(r0 map[int]string, r1 error) {
	f.PushHook(func(context.Context, ...int) (map[int]string, error) {
		return r0, r1
	})
}

func (f *DBStoreRepoNamesFunc) nextHook() func(context.Context, ...int) (map[int]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreRepoNamesFunc) appendCall(r0 DBStoreRepoNamesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreRepoNamesFuncCall objects describing
// the invocations of this function.
func (f *DBStoreRepoNamesFunc) History() []DBStoreRepoNamesFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreRepoNamesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreRepoNamesFuncCall is an object that describes an invocation of
// method RepoNames on an instance of MockDBStore.
type DBStoreRepoNamesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[int]string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c DBStoreRepoNamesFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreRepoNamesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreTransactFunc describes the behavior when the Transact method of
// the parent MockDBStore instance is invoked.
type DBStoreTransactFunc struct {
	defaultHook func(context.Context) (DBStore, error)
	hooks       []func(context.Context) (DBStore, error)
	history     []DBStoreTransactFuncCall
	mutex       sync.Mutex
}

// Transact delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) Transact(v0 context.Context) (DBStore, error) {
	r0, r1 := m.TransactFunc.nextHook()(v0)
	m.TransactFunc.appendCall(DBStoreTransactFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Transact method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreTransactFunc) SetDefaultHook(hook func(context.Context) (DBStore, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Transact method of the parent MockDBStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreTransactFunc) PushHook(hook func(context.Context) (DBStore, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreTransactFunc) SetDefaultReturn(r0 DBStore, r1 error) {
	f.SetDefaultHook(func(context.Context) (DBStore, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreTransactFunc) PushReturn(r0 DBStore, r1 error) {
	f.PushHook(func(context.Context) (DBStore, error) {
		return r0, r1
	})
}

func (f *DBStoreTransactFunc) nextHook() func(context.Context) (DBStore, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreTransactFunc) appendCall(r0 DBStoreTransactFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreTransactFuncCall objects describing
// the invocations of this function.
func (f *DBStoreTransactFunc) History() []DBStoreTransactFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreTransactFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreTransactFuncCall is an object that describes an invocation of
// method Transact on an instance of MockDBStore.
type DBStoreTransactFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 DBStore
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreTransactFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreTransactFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreUpdateCommitedAtFunc describes the behavior when the
// UpdateCommitedAt method of the parent MockDBStore instance is invoked.
type DBStoreUpdateCommitedAtFunc struct {
	defaultHook func(context.Context, int, time.Time) error
	hooks       []func(context.Context, int, time.Time) error
	history     []DBStoreUpdateCommitedAtFuncCall
	mutex       sync.Mutex
}

// UpdateCommitedAt delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) UpdateCommitedAt(v0 context.Context, v1 int, v2 time.Time) error {
	r0 := m.UpdateCommitedAtFunc.nextHook()(v0, v1, v2)
	m.UpdateCommitedAtFunc.appendCall(DBStoreUpdateCommitedAtFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the UpdateCommitedAt
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreUpdateCommitedAtFunc) SetDefaultHook(hook func(context.Context, int, time.Time) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateCommitedAt method of the parent MockDBStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *DBStoreUpdateCommitedAtFunc) PushHook(hook func(context.Context, int, time.Time) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreUpdateCommitedAtFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreUpdateCommitedAtFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

func (f *DBStoreUpdateCommitedAtFunc) nextHook() func(context.Context, int, time.Time) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreUpdateCommitedAtFunc) appendCall(r0 DBStoreUpdateCommitedAtFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreUpdateCommitedAtFuncCall objects
// describing the invocations of this function.
func (f *DBStoreUpdateCommitedAtFunc) History() []DBStoreUpdateCommitedAtFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreUpdateCommitedAtFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreUpdateCommitedAtFuncCall is an object that describes an invocation
// of method UpdateCommitedAt on an instance of MockDBStore.
type DBStoreUpdateCommitedAtFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreUpdateCommitedAtFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreUpdateCommitedAtFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreUpdatePackageReferencesFunc describes the behavior when the
// UpdatePackageReferences method of the parent MockDBStore instance is
// invoked.
type DBStoreUpdatePackageReferencesFunc struct {
	defaultHook func(context.Context, int, []precise.PackageReference) error
	hooks       []func(context.Context, int, []precise.PackageReference) error
	history     []DBStoreUpdatePackageReferencesFuncCall
	mutex       sync.Mutex
}

// UpdatePackageReferences delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) UpdatePackageReferences(v0 context.Context, v1 int, v2 []precise.PackageReference) error {
	r0 := m.UpdatePackageReferencesFunc.nextHook()(v0, v1, v2)
	m.UpdatePackageReferencesFunc.appendCall(DBStoreUpdatePackageReferencesFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdatePackageReferences method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreUpdatePackageReferencesFunc) SetDefaultHook(hook func(context.Context, int, []precise.PackageReference) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdatePackageReferences method of the parent MockDBStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreUpdatePackageReferencesFunc) PushHook(hook func(context.Context, int, []precise.PackageReference) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreUpdatePackageReferencesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, []precise.PackageReference) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreUpdatePackageReferencesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, []precise.PackageReference) error {
		return r0
	})
}

func (f *DBStoreUpdatePackageReferencesFunc) nextHook() func(context.Context, int, []precise.PackageReference) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreUpdatePackageReferencesFunc) appendCall(r0 DBStoreUpdatePackageReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreUpdatePackageReferencesFuncCall
// objects describing the invocations of this function.
func (f *DBStoreUpdatePackageReferencesFunc) History() []DBStoreUpdatePackageReferencesFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreUpdatePackageReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreUpdatePackageReferencesFuncCall is an object that describes an
// invocation of method UpdatePackageReferences on an instance of
// MockDBStore.
type DBStoreUpdatePackageReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []precise.PackageReference
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreUpdatePackageReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreUpdatePackageReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreUpdatePackagesFunc describes the behavior when the UpdatePackages
// method of the parent MockDBStore instance is invoked.
type DBStoreUpdatePackagesFunc struct {
	defaultHook func(context.Context, int, []precise.Package) error
	hooks       []func(context.Context, int, []precise.Package) error
	history     []DBStoreUpdatePackagesFuncCall
	mutex       sync.Mutex
}

// UpdatePackages delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) UpdatePackages(v0 context.Context, v1 int, v2 []precise.Package) error {
	r0 := m.UpdatePackagesFunc.nextHook()(v0, v1, v2)
	m.UpdatePackagesFunc.appendCall(DBStoreUpdatePackagesFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the UpdatePackages
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreUpdatePackagesFunc) SetDefaultHook(hook func(context.Context, int, []precise.Package) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdatePackages method of the parent MockDBStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreUpdatePackagesFunc) PushHook(hook func(context.Context, int, []precise.Package) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreUpdatePackagesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, []precise.Package) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreUpdatePackagesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, []precise.Package) error {
		return r0
	})
}

func (f *DBStoreUpdatePackagesFunc) nextHook() func(context.Context, int, []precise.Package) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreUpdatePackagesFunc) appendCall(r0 DBStoreUpdatePackagesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreUpdatePackagesFuncCall objects
// describing the invocations of this function.
func (f *DBStoreUpdatePackagesFunc) History() []DBStoreUpdatePackagesFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreUpdatePackagesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreUpdatePackagesFuncCall is an object that describes an invocation
// of method UpdatePackages on an instance of MockDBStore.
type DBStoreUpdatePackagesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []precise.Package
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreUpdatePackagesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreUpdatePackagesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreUpdateReferenceCountsFunc describes the behavior when the
// UpdateReferenceCounts method of the parent MockDBStore instance is
// invoked.
type DBStoreUpdateReferenceCountsFunc struct {
	defaultHook func(context.Context, []int, dbstore.DependencyReferenceCountUpdateType) (int, error)
	hooks       []func(context.Context, []int, dbstore.DependencyReferenceCountUpdateType) (int, error)
	history     []DBStoreUpdateReferenceCountsFuncCall
	mutex       sync.Mutex
}

// UpdateReferenceCounts delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) UpdateReferenceCounts(v0 context.Context, v1 []int, v2 dbstore.DependencyReferenceCountUpdateType) (int, error) {
	r0, r1 := m.UpdateReferenceCountsFunc.nextHook()(v0, v1, v2)
	m.UpdateReferenceCountsFunc.appendCall(DBStoreUpdateReferenceCountsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// UpdateReferenceCounts method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreUpdateReferenceCountsFunc) SetDefaultHook(hook func(context.Context, []int, dbstore.DependencyReferenceCountUpdateType) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateReferenceCounts method of the parent MockDBStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreUpdateReferenceCountsFunc) PushHook(hook func(context.Context, []int, dbstore.DependencyReferenceCountUpdateType) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreUpdateReferenceCountsFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, []int, dbstore.DependencyReferenceCountUpdateType) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreUpdateReferenceCountsFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, []int, dbstore.DependencyReferenceCountUpdateType) (int, error) {
		return r0, r1
	})
}

func (f *DBStoreUpdateReferenceCountsFunc) nextHook() func(context.Context, []int, dbstore.DependencyReferenceCountUpdateType) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreUpdateReferenceCountsFunc) appendCall(r0 DBStoreUpdateReferenceCountsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreUpdateReferenceCountsFuncCall
// objects describing the invocations of this function.
func (f *DBStoreUpdateReferenceCountsFunc) History() []DBStoreUpdateReferenceCountsFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreUpdateReferenceCountsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreUpdateReferenceCountsFuncCall is an object that describes an
// invocation of method UpdateReferenceCounts on an instance of MockDBStore.
type DBStoreUpdateReferenceCountsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 dbstore.DependencyReferenceCountUpdateType
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreUpdateReferenceCountsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreUpdateReferenceCountsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreWithFunc describes the behavior when the With method of the parent
// MockDBStore instance is invoked.
type DBStoreWithFunc struct {
	defaultHook func(basestore.ShareableStore) DBStore
	hooks       []func(basestore.ShareableStore) DBStore
	history     []DBStoreWithFuncCall
	mutex       sync.Mutex
}

// With delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) With(v0 basestore.ShareableStore) DBStore {
	r0 := m.WithFunc.nextHook()(v0)
	m.WithFunc.appendCall(DBStoreWithFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the With method of the
// parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreWithFunc) SetDefaultHook(hook func(basestore.ShareableStore) DBStore) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// With method of the parent MockDBStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *DBStoreWithFunc) PushHook(hook func(basestore.ShareableStore) DBStore) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreWithFunc) SetDefaultReturn(r0 DBStore) {
	f.SetDefaultHook(func(basestore.ShareableStore) DBStore {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreWithFunc) PushReturn(r0 DBStore) {
	f.PushHook(func(basestore.ShareableStore) DBStore {
		return r0
	})
}

func (f *DBStoreWithFunc) nextHook() func(basestore.ShareableStore) DBStore {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreWithFunc) appendCall(r0 DBStoreWithFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreWithFuncCall objects describing the
// invocations of this function.
func (f *DBStoreWithFunc) History() []DBStoreWithFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreWithFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreWithFuncCall is an object that describes an invocation of method
// With on an instance of MockDBStore.
type DBStoreWithFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 basestore.ShareableStore
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 DBStore
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreWithFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreWithFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// MockGitserverClient is a mock implementation of the GitserverClient
// interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/precise-code-intel-worker/internal/worker)
// used for unit testing.
type MockGitserverClient struct {
	// CommitDateFunc is an instance of a mock function object controlling
	// the behavior of the method CommitDate.
	CommitDateFunc *GitserverClientCommitDateFunc
	// DefaultBranchContainsFunc is an instance of a mock function object
	// controlling the behavior of the method DefaultBranchContains.
	DefaultBranchContainsFunc *GitserverClientDefaultBranchContainsFunc
	// DirectoryChildrenFunc is an instance of a mock function object
	// controlling the behavior of the method DirectoryChildren.
	DirectoryChildrenFunc *GitserverClientDirectoryChildrenFunc
	// ResolveRevisionFunc is an instance of a mock function object
	// controlling the behavior of the method ResolveRevision.
	ResolveRevisionFunc *GitserverClientResolveRevisionFunc
}

// NewMockGitserverClient creates a new mock of the GitserverClient
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockGitserverClient() *MockGitserverClient {
	return &MockGitserverClient{
		CommitDateFunc: &GitserverClientCommitDateFunc{
			defaultHook: func(context.Context, int, string) (r0 string, r1 time.Time, r2 bool, r3 error) {
				return
			},
		},
		DefaultBranchContainsFunc: &GitserverClientDefaultBranchContainsFunc{
			defaultHook: func(context.Context, int, string) (r0 bool, r1 error) {
				return
			},
		},
		DirectoryChildrenFunc: &GitserverClientDirectoryChildrenFunc{
			defaultHook: func(context.Context, int, string, []string) (r0 map[string][]string, r1 error) {
				return
			},
		},
		ResolveRevisionFunc: &GitserverClientResolveRevisionFunc{
			defaultHook: func(context.Context, int, string) (r0 api.CommitID, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockGitserverClient creates a new mock of the GitserverClient
// interface. All methods panic on invocation, unless overwritten.
func NewStrictMockGitserverClient() *MockGitserverClient {
	return &MockGitserverClient{
		CommitDateFunc: &GitserverClientCommitDateFunc{
			defaultHook: func(context.Context, int, string) (string, time.Time, bool, error) {
				panic("unexpected invocation of MockGitserverClient.CommitDate")
			},
		},
		DefaultBranchContainsFunc: &GitserverClientDefaultBranchContainsFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				panic("unexpected invocation of MockGitserverClient.DefaultBranchContains")
			},
		},
		DirectoryChildrenFunc: &GitserverClientDirectoryChildrenFunc{
			defaultHook: func(context.Context, int, string, []string) (map[string][]string, error) {
				panic("unexpected invocation of MockGitserverClient.DirectoryChildren")
			},
		},
		ResolveRevisionFunc: &GitserverClientResolveRevisionFunc{
			defaultHook: func(context.Context, int, string) (api.CommitID, error) {
				panic("unexpected invocation of MockGitserverClient.ResolveRevision")
			},
		},
	}
}

// NewMockGitserverClientFrom creates a new mock of the MockGitserverClient
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockGitserverClientFrom(i GitserverClient) *MockGitserverClient {
	return &MockGitserverClient{
		CommitDateFunc: &GitserverClientCommitDateFunc{
			defaultHook: i.CommitDate,
		},
		DefaultBranchContainsFunc: &GitserverClientDefaultBranchContainsFunc{
			defaultHook: i.DefaultBranchContains,
		},
		DirectoryChildrenFunc: &GitserverClientDirectoryChildrenFunc{
			defaultHook: i.DirectoryChildren,
		},
		ResolveRevisionFunc: &GitserverClientResolveRevisionFunc{
			defaultHook: i.ResolveRevision,
		},
	}
}

// GitserverClientCommitDateFunc describes the behavior when the CommitDate
// method of the parent MockGitserverClient instance is invoked.
type GitserverClientCommitDateFunc struct {
	defaultHook func(context.Context, int, string) (string, time.Time, bool, error)
	hooks       []func(context.Context, int, string) (string, time.Time, bool, error)
	history     []GitserverClientCommitDateFuncCall
	mutex       sync.Mutex
}

// CommitDate delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverClient) CommitDate(v0 context.Context, v1 int, v2 string) (string, time.Time, bool, error) {
	r0, r1, r2, r3 := m.CommitDateFunc.nextHook()(v0, v1, v2)
	m.CommitDateFunc.appendCall(GitserverClientCommitDateFuncCall{v0, v1, v2, r0, r1, r2, r3})
	return r0, r1, r2, r3
}

// SetDefaultHook sets function that is called when the CommitDate method of
// the parent MockGitserverClient instance is invoked and the hook queue is
// empty.
func (f *GitserverClientCommitDateFunc) SetDefaultHook(hook func(context.Context, int, string) (string, time.Time, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitDate method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientCommitDateFunc) PushHook(hook func(context.Context, int, string) (string, time.Time, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientCommitDateFunc) SetDefaultReturn(r0 string, r1 time.Time, r2 bool, r3 error) {
	f.SetDefaultHook(func(context.Context, int, string) (string, time.Time, bool, error) {
		return r0, r1, r2, r3
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientCommitDateFunc) PushReturn(r0 string, r1 time.Time, r2 bool, r3 error) {
	f.PushHook(func(context.Context, int, string) (string, time.Time, bool, error) {
		return r0, r1, r2, r3
	})
}

func (f *GitserverClientCommitDateFunc) nextHook() func(context.Context, int, string) (string, time.Time, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientCommitDateFunc) appendCall(r0 GitserverClientCommitDateFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientCommitDateFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientCommitDateFunc) History() []GitserverClientCommitDateFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientCommitDateFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientCommitDateFuncCall is an object that describes an
// invocation of method CommitDate on an instance of MockGitserverClient.
type GitserverClientCommitDateFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 time.Time
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 bool
	// Result3 is the value of the 4th result returned from this method
	// invocation.
	Result3 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientCommitDateFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientCommitDateFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2, c.Result3}
}

// GitserverClientDefaultBranchContainsFunc describes the behavior when the
// DefaultBranchContains method of the parent MockGitserverClient instance
// is invoked.
type GitserverClientDefaultBranchContainsFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []GitserverClientDefaultBranchContainsFuncCall
	mutex       sync.Mutex
}

// DefaultBranchContains delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockGitserverClient) DefaultBranchContains(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.DefaultBranchContainsFunc.nextHook()(v0, v1, v2)
	m.DefaultBranchContainsFunc.appendCall(GitserverClientDefaultBranchContainsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// DefaultBranchContains method of the parent MockGitserverClient instance
// is invoked and the hook queue is empty.
func (f *GitserverClientDefaultBranchContainsFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DefaultBranchContains method of the parent MockGitserverClient instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *GitserverClientDefaultBranchContainsFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientDefaultBranchContainsFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientDefaultBranchContainsFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *GitserverClientDefaultBranchContainsFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientDefaultBranchContainsFunc) appendCall(r0 GitserverClientDefaultBranchContainsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// GitserverClientDefaultBranchContainsFuncCall objects describing the
// invocations of this function.
func (f *GitserverClientDefaultBranchContainsFunc) History() []GitserverClientDefaultBranchContainsFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientDefaultBranchContainsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientDefaultBranchContainsFuncCall is an object that describes
// an invocation of method DefaultBranchContains on an instance of
// MockGitserverClient.
type GitserverClientDefaultBranchContainsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientDefaultBranchContainsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientDefaultBranchContainsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientDirectoryChildrenFunc describes the behavior when the
// DirectoryChildren method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientDirectoryChildrenFunc struct {
	defaultHook func(context.Context, int, string, []string) (map[string][]string, error)
	hooks       []func(context.Context, int, string, []string) (map[string][]string, error)
	history     []GitserverClientDirectoryChildrenFuncCall
	mutex       sync.Mutex
}

// DirectoryChildren delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockGitserverClient) DirectoryChildren(v0 context.Context, v1 int, v2 string, v3 []string) (map[string][]string, error) {
	r0, r1 := m.DirectoryChildrenFunc.nextHook()(v0, v1, v2, v3)
	m.DirectoryChildrenFunc.appendCall(GitserverClientDirectoryChildrenFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DirectoryChildren
// method of the parent MockGitserverClient instance is invoked and the hook
// queue is empty.
func (f *GitserverClientDirectoryChildrenFunc) SetDefaultHook(hook func(context.Context, int, string, []string) (map[string][]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DirectoryChildren method of the parent MockGitserverClient instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *GitserverClientDirectoryChildrenFunc) PushHook(hook func(context.Context, int, string, []string) (map[string][]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientDirectoryChildrenFunc) SetDefaultReturn(r0 map[string][]string, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, []string) (map[string][]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientDirectoryChildrenFunc) PushReturn(r0 map[string][]string, r1 error) {
	f.PushHook(func(context.Context, int, string, []string) (map[string][]string, error) {
		return r0, r1
	})
}

func (f *GitserverClientDirectoryChildrenFunc) nextHook() func(context.Context, int, string, []string) (map[string][]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientDirectoryChildrenFunc) appendCall(r0 GitserverClientDirectoryChildrenFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientDirectoryChildrenFuncCall
// objects describing the invocations of this function.
func (f *GitserverClientDirectoryChildrenFunc) History() []GitserverClientDirectoryChildrenFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientDirectoryChildrenFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientDirectoryChildrenFuncCall is an object that describes an
// invocation of method DirectoryChildren on an instance of
// MockGitserverClient.
type GitserverClientDirectoryChildrenFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 []string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[string][]string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientDirectoryChildrenFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientDirectoryChildrenFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientResolveRevisionFunc describes the behavior when the
// ResolveRevision method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientResolveRevisionFunc struct {
	defaultHook func(context.Context, int, string) (api.CommitID, error)
	hooks       []func(context.Context, int, string) (api.CommitID, error)
	history     []GitserverClientResolveRevisionFuncCall
	mutex       sync.Mutex
}

// ResolveRevision delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockGitserverClient) ResolveRevision(v0 context.Context, v1 int, v2 string) (api.CommitID, error) {
	r0, r1 := m.ResolveRevisionFunc.nextHook()(v0, v1, v2)
	m.ResolveRevisionFunc.appendCall(GitserverClientResolveRevisionFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ResolveRevision
// method of the parent MockGitserverClient instance is invoked and the hook
// queue is empty.
func (f *GitserverClientResolveRevisionFunc) SetDefaultHook(hook func(context.Context, int, string) (api.CommitID, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ResolveRevision method of the parent MockGitserverClient instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitserverClientResolveRevisionFunc) PushHook(hook func(context.Context, int, string) (api.CommitID, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientResolveRevisionFunc) SetDefaultReturn(r0 api.CommitID, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (api.CommitID, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientResolveRevisionFunc) PushReturn(r0 api.CommitID, r1 error) {
	f.PushHook(func(context.Context, int, string) (api.CommitID, error) {
		return r0, r1
	})
}

func (f *GitserverClientResolveRevisionFunc) nextHook() func(context.Context, int, string) (api.CommitID, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientResolveRevisionFunc) appendCall(r0 GitserverClientResolveRevisionFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientResolveRevisionFuncCall
// objects describing the invocations of this function.
func (f *GitserverClientResolveRevisionFunc) History() []GitserverClientResolveRevisionFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientResolveRevisionFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientResolveRevisionFuncCall is an object that describes an
// invocation of method ResolveRevision on an instance of
// MockGitserverClient.
type GitserverClientResolveRevisionFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 api.CommitID
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientResolveRevisionFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientResolveRevisionFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockLSIFStore is a mock implementation of the LSIFStore interface (from
// the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/precise-code-intel-worker/internal/worker)
// used for unit testing.
type MockLSIFStore struct {
	// DoneFunc is an instance of a mock function object controlling the
	// behavior of the method Done.
	DoneFunc *LSIFStoreDoneFunc
	// TransactFunc is an instance of a mock function object controlling the
	// behavior of the method Transact.
	TransactFunc *LSIFStoreTransactFunc
	// WriteDefinitionsFunc is an instance of a mock function object
	// controlling the behavior of the method WriteDefinitions.
	WriteDefinitionsFunc *LSIFStoreWriteDefinitionsFunc
	// WriteDocumentsFunc is an instance of a mock function object
	// controlling the behavior of the method WriteDocuments.
	WriteDocumentsFunc *LSIFStoreWriteDocumentsFunc
	// WriteImplementationsFunc is an instance of a mock function object
	// controlling the behavior of the method WriteImplementations.
	WriteImplementationsFunc *LSIFStoreWriteImplementationsFunc
	// WriteMetaFunc is an instance of a mock function object controlling
	// the behavior of the method WriteMeta.
	WriteMetaFunc *LSIFStoreWriteMetaFunc
	// WriteReferencesFunc is an instance of a mock function object
	// controlling the behavior of the method WriteReferences.
	WriteReferencesFunc *LSIFStoreWriteReferencesFunc
	// WriteResultChunksFunc is an instance of a mock function object
	// controlling the behavior of the method WriteResultChunks.
	WriteResultChunksFunc *LSIFStoreWriteResultChunksFunc
}

// NewMockLSIFStore creates a new mock of the LSIFStore interface. All
// methods return zero values for all results, unless overwritten.
func NewMockLSIFStore() *MockLSIFStore {
	return &MockLSIFStore{
		DoneFunc: &LSIFStoreDoneFunc{
			defaultHook: func(error) (r0 error) {
				return
			},
		},
		TransactFunc: &LSIFStoreTransactFunc{
			defaultHook: func(context.Context) (r0 LSIFStore, r1 error) {
				return
			},
		},
		WriteDefinitionsFunc: &LSIFStoreWriteDefinitionsFunc{
			defaultHook: func(context.Context, int, chan precise.MonikerLocations) (r0 uint32, r1 error) {
				return
			},
		},
		WriteDocumentsFunc: &LSIFStoreWriteDocumentsFunc{
			defaultHook: func(context.Context, int, chan precise.KeyedDocumentData) (r0 uint32, r1 error) {
				return
			},
		},
		WriteImplementationsFunc: &LSIFStoreWriteImplementationsFunc{
			defaultHook: func(context.Context, int, chan precise.MonikerLocations) (r0 uint32, r1 error) {
				return
			},
		},
		WriteMetaFunc: &LSIFStoreWriteMetaFunc{
			defaultHook: func(context.Context, int, precise.MetaData) (r0 error) {
				return
			},
		},
		WriteReferencesFunc: &LSIFStoreWriteReferencesFunc{
			defaultHook: func(context.Context, int, chan precise.MonikerLocations) (r0 uint32, r1 error) {
				return
			},
		},
		WriteResultChunksFunc: &LSIFStoreWriteResultChunksFunc{
			defaultHook: func(context.Context, int, chan precise.IndexedResultChunkData) (r0 uint32, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockLSIFStore creates a new mock of the LSIFStore interface. All
// methods panic on invocation, unless overwritten.
func NewStrictMockLSIFStore() *MockLSIFStore {
	return &MockLSIFStore{
		DoneFunc: &LSIFStoreDoneFunc{
			defaultHook: func(error) error {
				panic("unexpected invocation of MockLSIFStore.Done")
			},
		},
		TransactFunc: &LSIFStoreTransactFunc{
			defaultHook: func(context.Context) (LSIFStore, error) {
				panic("unexpected invocation of MockLSIFStore.Transact")
			},
		},
		WriteDefinitionsFunc: &LSIFStoreWriteDefinitionsFunc{
			defaultHook: func(context.Context, int, chan precise.MonikerLocations) (uint32, error) {
				panic("unexpected invocation of MockLSIFStore.WriteDefinitions")
			},
		},
		WriteDocumentsFunc: &LSIFStoreWriteDocumentsFunc{
			defaultHook: func(context.Context, int, chan precise.KeyedDocumentData) (uint32, error) {
				panic("unexpected invocation of MockLSIFStore.WriteDocuments")
			},
		},
		WriteImplementationsFunc: &LSIFStoreWriteImplementationsFunc{
			defaultHook: func(context.Context, int, chan precise.MonikerLocations) (uint32, error) {
				panic("unexpected invocation of MockLSIFStore.WriteImplementations")
			},
		},
		WriteMetaFunc: &LSIFStoreWriteMetaFunc{
			defaultHook: func(context.Context, int, precise.MetaData) error {
				panic("unexpected invocation of MockLSIFStore.WriteMeta")
			},
		},
		WriteReferencesFunc: &LSIFStoreWriteReferencesFunc{
			defaultHook: func(context.Context, int, chan precise.MonikerLocations) (uint32, error) {
				panic("unexpected invocation of MockLSIFStore.WriteReferences")
			},
		},
		WriteResultChunksFunc: &LSIFStoreWriteResultChunksFunc{
			defaultHook: func(context.Context, int, chan precise.IndexedResultChunkData) (uint32, error) {
				panic("unexpected invocation of MockLSIFStore.WriteResultChunks")
			},
		},
	}
}

// NewMockLSIFStoreFrom creates a new mock of the MockLSIFStore interface.
// All methods delegate to the given implementation, unless overwritten.
func NewMockLSIFStoreFrom(i LSIFStore) *MockLSIFStore {
	return &MockLSIFStore{
		DoneFunc: &LSIFStoreDoneFunc{
			defaultHook: i.Done,
		},
		TransactFunc: &LSIFStoreTransactFunc{
			defaultHook: i.Transact,
		},
		WriteDefinitionsFunc: &LSIFStoreWriteDefinitionsFunc{
			defaultHook: i.WriteDefinitions,
		},
		WriteDocumentsFunc: &LSIFStoreWriteDocumentsFunc{
			defaultHook: i.WriteDocuments,
		},
		WriteImplementationsFunc: &LSIFStoreWriteImplementationsFunc{
			defaultHook: i.WriteImplementations,
		},
		WriteMetaFunc: &LSIFStoreWriteMetaFunc{
			defaultHook: i.WriteMeta,
		},
		WriteReferencesFunc: &LSIFStoreWriteReferencesFunc{
			defaultHook: i.WriteReferences,
		},
		WriteResultChunksFunc: &LSIFStoreWriteResultChunksFunc{
			defaultHook: i.WriteResultChunks,
		},
	}
}

// LSIFStoreDoneFunc describes the behavior when the Done method of the
// parent MockLSIFStore instance is invoked.
type LSIFStoreDoneFunc struct {
	defaultHook func(error) error
	hooks       []func(error) error
	history     []LSIFStoreDoneFuncCall
	mutex       sync.Mutex
}

// Done delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) Done(v0 error) error {
	r0 := m.DoneFunc.nextHook()(v0)
	m.DoneFunc.appendCall(LSIFStoreDoneFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Done method of the
// parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreDoneFunc) SetDefaultHook(hook func(error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Done method of the parent MockLSIFStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *LSIFStoreDoneFunc) PushHook(hook func(error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreDoneFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(error) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreDoneFunc) PushReturn(r0 error) {
	f.PushHook(func(error) error {
		return r0
	})
}

func (f *LSIFStoreDoneFunc) nextHook() func(error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreDoneFunc) appendCall(r0 LSIFStoreDoneFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreDoneFuncCall objects describing
// the invocations of this function.
func (f *LSIFStoreDoneFunc) History() []LSIFStoreDoneFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreDoneFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreDoneFuncCall is an object that describes an invocation of method
// Done on an instance of MockLSIFStore.
type LSIFStoreDoneFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreDoneFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreDoneFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreTransactFunc describes the behavior when the Transact method of
// the parent MockLSIFStore instance is invoked.
type LSIFStoreTransactFunc struct {
	defaultHook func(context.Context) (LSIFStore, error)
	hooks       []func(context.Context) (LSIFStore, error)
	history     []LSIFStoreTransactFuncCall
	mutex       sync.Mutex
}

// Transact delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) Transact(v0 context.Context) (LSIFStore, error) {
	r0, r1 := m.TransactFunc.nextHook()(v0)
	m.TransactFunc.appendCall(LSIFStoreTransactFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Transact method of
// the parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreTransactFunc) SetDefaultHook(hook func(context.Context) (LSIFStore, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Transact method of the parent MockLSIFStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreTransactFunc) PushHook(hook func(context.Context) (LSIFStore, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreTransactFunc) SetDefaultReturn(r0 LSIFStore, r1 error) {
	f.SetDefaultHook(func(context.Context) (LSIFStore, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreTransactFunc) PushReturn(r0 LSIFStore, r1 error) {
	f.PushHook(func(context.Context) (LSIFStore, error) {
		return r0, r1
	})
}

func (f *LSIFStoreTransactFunc) nextHook() func(context.Context) (LSIFStore, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreTransactFunc) appendCall(r0 LSIFStoreTransactFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreTransactFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreTransactFunc) History() []LSIFStoreTransactFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreTransactFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreTransactFuncCall is an object that describes an invocation of
// method Transact on an instance of MockLSIFStore.
type LSIFStoreTransactFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 LSIFStore
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreTransactFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreTransactFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStoreWriteDefinitionsFunc describes the behavior when the
// WriteDefinitions method of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteDefinitionsFunc struct {
	defaultHook func(context.Context, int, chan precise.MonikerLocations) (uint32, error)
	hooks       []func(context.Context, int, chan precise.MonikerLocations) (uint32, error)
	history     []LSIFStoreWriteDefinitionsFuncCall
	mutex       sync.Mutex
}

// WriteDefinitions delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteDefinitions(v0 context.Context, v1 int, v2 chan precise.MonikerLocations) (uint32, error) {
	r0, r1 := m.WriteDefinitionsFunc.nextHook()(v0, v1, v2)
	m.WriteDefinitionsFunc.appendCall(LSIFStoreWriteDefinitionsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the WriteDefinitions
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreWriteDefinitionsFunc) SetDefaultHook(hook func(context.Context, int, chan precise.MonikerLocations) (uint32, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteDefinitions method of the parent MockLSIFStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreWriteDefinitionsFunc) PushHook(hook func(context.Context, int, chan precise.MonikerLocations) (uint32, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreWriteDefinitionsFunc) SetDefaultReturn(r0 uint32, r1 error) {
	f.SetDefaultHook(func(context.Context, int, chan precise.MonikerLocations) (uint32, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreWriteDefinitionsFunc) PushReturn(r0 uint32, r1 error) {
	f.PushHook(func(context.Context, int, chan precise.MonikerLocations) (uint32, error) {
		return r0, r1
	})
}

func (f *LSIFStoreWriteDefinitionsFunc) nextHook() func(context.Context, int, chan precise.MonikerLocations) (uint32, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteDefinitionsFunc) appendCall(r0 LSIFStoreWriteDefinitionsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteDefinitionsFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteDefinitionsFunc) History() []LSIFStoreWriteDefinitionsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteDefinitionsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteDefinitionsFuncCall is an object that describes an
// invocation of method WriteDefinitions on an instance of MockLSIFStore.
type LSIFStoreWriteDefinitionsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan precise.MonikerLocations
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 uint32
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteDefinitionsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteDefinitionsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStoreWriteDocumentsFunc describes the behavior when the
// WriteDocuments method of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteDocumentsFunc struct {
	defaultHook func(context.Context, int, chan precise.KeyedDocumentData) (uint32, error)
	hooks       []func(context.Context, int, chan precise.KeyedDocumentData) (uint32, error)
	history     []LSIFStoreWriteDocumentsFuncCall
	mutex       sync.Mutex
}

// WriteDocuments delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteDocuments(v0 context.Context, v1 int, v2 chan precise.KeyedDocumentData) (uint32, error) {
	r0, r1 := m.WriteDocumentsFunc.nextHook()(v0, v1, v2)
	m.WriteDocumentsFunc.appendCall(LSIFStoreWriteDocumentsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the WriteDocuments
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreWriteDocumentsFunc) SetDefaultHook(hook func(context.Context, int, chan precise.KeyedDocumentData) (uint32, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteDocuments method of the parent MockLSIFStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreWriteDocumentsFunc) PushHook(hook func(context.Context, int, chan precise.KeyedDocumentData) (uint32, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreWriteDocumentsFunc) SetDefaultReturn(r0 uint32, r1 error) {
	f.SetDefaultHook(func(context.Context, int, chan precise.KeyedDocumentData) (uint32, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreWriteDocumentsFunc) PushReturn(r0 uint32, r1 error) {
	f.PushHook(func(context.Context, int, chan precise.KeyedDocumentData) (uint32, error) {
		return r0, r1
	})
}

func (f *LSIFStoreWriteDocumentsFunc) nextHook() func(context.Context, int, chan precise.KeyedDocumentData) (uint32, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteDocumentsFunc) appendCall(r0 LSIFStoreWriteDocumentsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteDocumentsFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteDocumentsFunc) History() []LSIFStoreWriteDocumentsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteDocumentsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteDocumentsFuncCall is an object that describes an invocation
// of method WriteDocuments on an instance of MockLSIFStore.
type LSIFStoreWriteDocumentsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan precise.KeyedDocumentData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 uint32
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteDocumentsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteDocumentsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStoreWriteImplementationsFunc describes the behavior when the
// WriteImplementations method of the parent MockLSIFStore instance is
// invoked.
type LSIFStoreWriteImplementationsFunc struct {
	defaultHook func(context.Context, int, chan precise.MonikerLocations) (uint32, error)
	hooks       []func(context.Context, int, chan precise.MonikerLocations) (uint32, error)
	history     []LSIFStoreWriteImplementationsFuncCall
	mutex       sync.Mutex
}

// WriteImplementations delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteImplementations(v0 context.Context, v1 int, v2 chan precise.MonikerLocations) (uint32, error) {
	r0, r1 := m.WriteImplementationsFunc.nextHook()(v0, v1, v2)
	m.WriteImplementationsFunc.appendCall(LSIFStoreWriteImplementationsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the WriteImplementations
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreWriteImplementationsFunc) SetDefaultHook(hook func(context.Context, int, chan precise.MonikerLocations) (uint32, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteImplementations method of the parent MockLSIFStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *LSIFStoreWriteImplementationsFunc) PushHook(hook func(context.Context, int, chan precise.MonikerLocations) (uint32, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreWriteImplementationsFunc) SetDefaultReturn(r0 uint32, r1 error) {
	f.SetDefaultHook(func(context.Context, int, chan precise.MonikerLocations) (uint32, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreWriteImplementationsFunc) PushReturn(r0 uint32, r1 error) {
	f.PushHook(func(context.Context, int, chan precise.MonikerLocations) (uint32, error) {
		return r0, r1
	})
}

func (f *LSIFStoreWriteImplementationsFunc) nextHook() func(context.Context, int, chan precise.MonikerLocations) (uint32, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteImplementationsFunc) appendCall(r0 LSIFStoreWriteImplementationsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteImplementationsFuncCall
// objects describing the invocations of this function.
func (f *LSIFStoreWriteImplementationsFunc) History() []LSIFStoreWriteImplementationsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteImplementationsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteImplementationsFuncCall is an object that describes an
// invocation of method WriteImplementations on an instance of
// MockLSIFStore.
type LSIFStoreWriteImplementationsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan precise.MonikerLocations
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 uint32
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteImplementationsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteImplementationsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStoreWriteMetaFunc describes the behavior when the WriteMeta method
// of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteMetaFunc struct {
	defaultHook func(context.Context, int, precise.MetaData) error
	hooks       []func(context.Context, int, precise.MetaData) error
	history     []LSIFStoreWriteMetaFuncCall
	mutex       sync.Mutex
}

// WriteMeta delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) WriteMeta(v0 context.Context, v1 int, v2 precise.MetaData) error {
	r0 := m.WriteMetaFunc.nextHook()(v0, v1, v2)
	m.WriteMetaFunc.appendCall(LSIFStoreWriteMetaFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteMeta method of
// the parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreWriteMetaFunc) SetDefaultHook(hook func(context.Context, int, precise.MetaData) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteMeta method of the parent MockLSIFStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreWriteMetaFunc) PushHook(hook func(context.Context, int, precise.MetaData) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreWriteMetaFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, precise.MetaData) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreWriteMetaFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, precise.MetaData) error {
		return r0
	})
}

func (f *LSIFStoreWriteMetaFunc) nextHook() func(context.Context, int, precise.MetaData) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteMetaFunc) appendCall(r0 LSIFStoreWriteMetaFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteMetaFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteMetaFunc) History() []LSIFStoreWriteMetaFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteMetaFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteMetaFuncCall is an object that describes an invocation of
// method WriteMeta on an instance of MockLSIFStore.
type LSIFStoreWriteMetaFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 precise.MetaData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteMetaFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteMetaFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreWriteReferencesFunc describes the behavior when the
// WriteReferences method of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteReferencesFunc struct {
	defaultHook func(context.Context, int, chan precise.MonikerLocations) (uint32, error)
	hooks       []func(context.Context, int, chan precise.MonikerLocations) (uint32, error)
	history     []LSIFStoreWriteReferencesFuncCall
	mutex       sync.Mutex
}

// WriteReferences delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteReferences(v0 context.Context, v1 int, v2 chan precise.MonikerLocations) (uint32, error) {
	r0, r1 := m.WriteReferencesFunc.nextHook()(v0, v1, v2)
	m.WriteReferencesFunc.appendCall(LSIFStoreWriteReferencesFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the WriteReferences
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreWriteReferencesFunc) SetDefaultHook(hook func(context.Context, int, chan precise.MonikerLocations) (uint32, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteReferences method of the parent MockLSIFStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreWriteReferencesFunc) PushHook(hook func(context.Context, int, chan precise.MonikerLocations) (uint32, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreWriteReferencesFunc) SetDefaultReturn(r0 uint32, r1 error) {
	f.SetDefaultHook(func(context.Context, int, chan precise.MonikerLocations) (uint32, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreWriteReferencesFunc) PushReturn(r0 uint32, r1 error) {
	f.PushHook(func(context.Context, int, chan precise.MonikerLocations) (uint32, error) {
		return r0, r1
	})
}

func (f *LSIFStoreWriteReferencesFunc) nextHook() func(context.Context, int, chan precise.MonikerLocations) (uint32, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteReferencesFunc) appendCall(r0 LSIFStoreWriteReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteReferencesFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteReferencesFunc) History() []LSIFStoreWriteReferencesFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteReferencesFuncCall is an object that describes an
// invocation of method WriteReferences on an instance of MockLSIFStore.
type LSIFStoreWriteReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan precise.MonikerLocations
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 uint32
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStoreWriteResultChunksFunc describes the behavior when the
// WriteResultChunks method of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteResultChunksFunc struct {
	defaultHook func(context.Context, int, chan precise.IndexedResultChunkData) (uint32, error)
	hooks       []func(context.Context, int, chan precise.IndexedResultChunkData) (uint32, error)
	history     []LSIFStoreWriteResultChunksFuncCall
	mutex       sync.Mutex
}

// WriteResultChunks delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteResultChunks(v0 context.Context, v1 int, v2 chan precise.IndexedResultChunkData) (uint32, error) {
	r0, r1 := m.WriteResultChunksFunc.nextHook()(v0, v1, v2)
	m.WriteResultChunksFunc.appendCall(LSIFStoreWriteResultChunksFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the WriteResultChunks
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreWriteResultChunksFunc) SetDefaultHook(hook func(context.Context, int, chan precise.IndexedResultChunkData) (uint32, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteResultChunks method of the parent MockLSIFStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreWriteResultChunksFunc) PushHook(hook func(context.Context, int, chan precise.IndexedResultChunkData) (uint32, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreWriteResultChunksFunc) SetDefaultReturn(r0 uint32, r1 error) {
	f.SetDefaultHook(func(context.Context, int, chan precise.IndexedResultChunkData) (uint32, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreWriteResultChunksFunc) PushReturn(r0 uint32, r1 error) {
	f.PushHook(func(context.Context, int, chan precise.IndexedResultChunkData) (uint32, error) {
		return r0, r1
	})
}

func (f *LSIFStoreWriteResultChunksFunc) nextHook() func(context.Context, int, chan precise.IndexedResultChunkData) (uint32, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteResultChunksFunc) appendCall(r0 LSIFStoreWriteResultChunksFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteResultChunksFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteResultChunksFunc) History() []LSIFStoreWriteResultChunksFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteResultChunksFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteResultChunksFuncCall is an object that describes an
// invocation of method WriteResultChunks on an instance of MockLSIFStore.
type LSIFStoreWriteResultChunksFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan precise.IndexedResultChunkData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 uint32
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteResultChunksFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteResultChunksFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockWorkerStore is a mock implementation of the Store interface (from the
// package
// github.com/sourcegraph/sourcegraph/internal/workerutil/dbworker/store)
// used for unit testing.
type MockWorkerStore struct {
	// AddExecutionLogEntryFunc is an instance of a mock function object
	// controlling the behavior of the method AddExecutionLogEntry.
	AddExecutionLogEntryFunc *WorkerStoreAddExecutionLogEntryFunc
	// DequeueFunc is an instance of a mock function object controlling the
	// behavior of the method Dequeue.
	DequeueFunc *WorkerStoreDequeueFunc
	// HandleFunc is an instance of a mock function object controlling the
	// behavior of the method Handle.
	HandleFunc *WorkerStoreHandleFunc
	// HeartbeatFunc is an instance of a mock function object controlling
	// the behavior of the method Heartbeat.
	HeartbeatFunc *WorkerStoreHeartbeatFunc
	// MarkCompleteFunc is an instance of a mock function object controlling
	// the behavior of the method MarkComplete.
	MarkCompleteFunc *WorkerStoreMarkCompleteFunc
	// MarkErroredFunc is an instance of a mock function object controlling
	// the behavior of the method MarkErrored.
	MarkErroredFunc *WorkerStoreMarkErroredFunc
	// MarkFailedFunc is an instance of a mock function object controlling
	// the behavior of the method MarkFailed.
	MarkFailedFunc *WorkerStoreMarkFailedFunc
	// MaxDurationInQueueFunc is an instance of a mock function object
	// controlling the behavior of the method MaxDurationInQueue.
	MaxDurationInQueueFunc *WorkerStoreMaxDurationInQueueFunc
	// QueuedCountFunc is an instance of a mock function object controlling
	// the behavior of the method QueuedCount.
	QueuedCountFunc *WorkerStoreQueuedCountFunc
	// RequeueFunc is an instance of a mock function object controlling the
	// behavior of the method Requeue.
	RequeueFunc *WorkerStoreRequeueFunc
	// ResetStalledFunc is an instance of a mock function object controlling
	// the behavior of the method ResetStalled.
	ResetStalledFunc *WorkerStoreResetStalledFunc
	// UpdateExecutionLogEntryFunc is an instance of a mock function object
	// controlling the behavior of the method UpdateExecutionLogEntry.
	UpdateExecutionLogEntryFunc *WorkerStoreUpdateExecutionLogEntryFunc
	// WithFunc is an instance of a mock function object controlling the
	// behavior of the method With.
	WithFunc *WorkerStoreWithFunc
}

// NewMockWorkerStore creates a new mock of the Store interface. All methods
// return zero values for all results, unless overwritten.
func NewMockWorkerStore() *MockWorkerStore {
	return &MockWorkerStore{
		AddExecutionLogEntryFunc: &WorkerStoreAddExecutionLogEntryFunc{
			defaultHook: func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (r0 int, r1 error) {
				return
			},
		},
		DequeueFunc: &WorkerStoreDequeueFunc{
			defaultHook: func(context.Context, string, []*sqlf.Query) (r0 workerutil.Record, r1 bool, r2 error) {
				return
			},
		},
		HandleFunc: &WorkerStoreHandleFunc{
			defaultHook: func() (r0 basestore.TransactableHandle) {
				return
			},
		},
		HeartbeatFunc: &WorkerStoreHeartbeatFunc{
			defaultHook: func(context.Context, []int, store.HeartbeatOptions) (r0 []int, r1 error) {
				return
			},
		},
		MarkCompleteFunc: &WorkerStoreMarkCompleteFunc{
			defaultHook: func(context.Context, int, store.MarkFinalOptions) (r0 bool, r1 error) {
				return
			},
		},
		MarkErroredFunc: &WorkerStoreMarkErroredFunc{
			defaultHook: func(context.Context, int, string, store.MarkFinalOptions) (r0 bool, r1 error) {
				return
			},
		},
		MarkFailedFunc: &WorkerStoreMarkFailedFunc{
			defaultHook: func(context.Context, int, string, store.MarkFinalOptions) (r0 bool, r1 error) {
				return
			},
		},
		MaxDurationInQueueFunc: &WorkerStoreMaxDurationInQueueFunc{
			defaultHook: func(context.Context) (r0 time.Duration, r1 error) {
				return
			},
		},
		QueuedCountFunc: &WorkerStoreQueuedCountFunc{
			defaultHook: func(context.Context, bool) (r0 int, r1 error) {
				return
			},
		},
		RequeueFunc: &WorkerStoreRequeueFunc{
			defaultHook: func(context.Context, int, time.Time) (r0 error) {
				return
			},
		},
		ResetStalledFunc: &WorkerStoreResetStalledFunc{
			defaultHook: func(context.Context) (r0 map[int]time.Duration, r1 map[int]time.Duration, r2 error) {
				return
			},
		},
		UpdateExecutionLogEntryFunc: &WorkerStoreUpdateExecutionLogEntryFunc{
			defaultHook: func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (r0 error) {
				return
			},
		},
		WithFunc: &WorkerStoreWithFunc{
			defaultHook: func(basestore.ShareableStore) (r0 store.Store) {
				return
			},
		},
	}
}

// NewStrictMockWorkerStore creates a new mock of the Store interface. All
// methods panic on invocation, unless overwritten.
func NewStrictMockWorkerStore() *MockWorkerStore {
	return &MockWorkerStore{
		AddExecutionLogEntryFunc: &WorkerStoreAddExecutionLogEntryFunc{
			defaultHook: func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (int, error) {
				panic("unexpected invocation of MockWorkerStore.AddExecutionLogEntry")
			},
		},
		DequeueFunc: &WorkerStoreDequeueFunc{
			defaultHook: func(context.Context, string, []*sqlf.Query) (workerutil.Record, bool, error) {
				panic("unexpected invocation of MockWorkerStore.Dequeue")
			},
		},
		HandleFunc: &WorkerStoreHandleFunc{
			defaultHook: func() basestore.TransactableHandle {
				panic("unexpected invocation of MockWorkerStore.Handle")
			},
		},
		HeartbeatFunc: &WorkerStoreHeartbeatFunc{
			defaultHook: func(context.Context, []int, store.HeartbeatOptions) ([]int, error) {
				panic("unexpected invocation of MockWorkerStore.Heartbeat")
			},
		},
		MarkCompleteFunc: &WorkerStoreMarkCompleteFunc{
			defaultHook: func(context.Context, int, store.MarkFinalOptions) (bool, error) {
				panic("unexpected invocation of MockWorkerStore.MarkComplete")
			},
		},
		MarkErroredFunc: &WorkerStoreMarkErroredFunc{
			defaultHook: func(context.Context, int, string, store.MarkFinalOptions) (bool, error) {
				panic("unexpected invocation of MockWorkerStore.MarkErrored")
			},
		},
		MarkFailedFunc: &WorkerStoreMarkFailedFunc{
			defaultHook: func(context.Context, int, string, store.MarkFinalOptions) (bool, error) {
				panic("unexpected invocation of MockWorkerStore.MarkFailed")
			},
		},
		MaxDurationInQueueFunc: &WorkerStoreMaxDurationInQueueFunc{
			defaultHook: func(context.Context) (time.Duration, error) {
				panic("unexpected invocation of MockWorkerStore.MaxDurationInQueue")
			},
		},
		QueuedCountFunc: &WorkerStoreQueuedCountFunc{
			defaultHook: func(context.Context, bool) (int, error) {
				panic("unexpected invocation of MockWorkerStore.QueuedCount")
			},
		},
		RequeueFunc: &WorkerStoreRequeueFunc{
			defaultHook: func(context.Context, int, time.Time) error {
				panic("unexpected invocation of MockWorkerStore.Requeue")
			},
		},
		ResetStalledFunc: &WorkerStoreResetStalledFunc{
			defaultHook: func(context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
				panic("unexpected invocation of MockWorkerStore.ResetStalled")
			},
		},
		UpdateExecutionLogEntryFunc: &WorkerStoreUpdateExecutionLogEntryFunc{
			defaultHook: func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) error {
				panic("unexpected invocation of MockWorkerStore.UpdateExecutionLogEntry")
			},
		},
		WithFunc: &WorkerStoreWithFunc{
			defaultHook: func(basestore.ShareableStore) store.Store {
				panic("unexpected invocation of MockWorkerStore.With")
			},
		},
	}
}

// NewMockWorkerStoreFrom creates a new mock of the MockWorkerStore
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockWorkerStoreFrom(i store.Store) *MockWorkerStore {
	return &MockWorkerStore{
		AddExecutionLogEntryFunc: &WorkerStoreAddExecutionLogEntryFunc{
			defaultHook: i.AddExecutionLogEntry,
		},
		DequeueFunc: &WorkerStoreDequeueFunc{
			defaultHook: i.Dequeue,
		},
		HandleFunc: &WorkerStoreHandleFunc{
			defaultHook: i.Handle,
		},
		HeartbeatFunc: &WorkerStoreHeartbeatFunc{
			defaultHook: i.Heartbeat,
		},
		MarkCompleteFunc: &WorkerStoreMarkCompleteFunc{
			defaultHook: i.MarkComplete,
		},
		MarkErroredFunc: &WorkerStoreMarkErroredFunc{
			defaultHook: i.MarkErrored,
		},
		MarkFailedFunc: &WorkerStoreMarkFailedFunc{
			defaultHook: i.MarkFailed,
		},
		MaxDurationInQueueFunc: &WorkerStoreMaxDurationInQueueFunc{
			defaultHook: i.MaxDurationInQueue,
		},
		QueuedCountFunc: &WorkerStoreQueuedCountFunc{
			defaultHook: i.QueuedCount,
		},
		RequeueFunc: &WorkerStoreRequeueFunc{
			defaultHook: i.Requeue,
		},
		ResetStalledFunc: &WorkerStoreResetStalledFunc{
			defaultHook: i.ResetStalled,
		},
		UpdateExecutionLogEntryFunc: &WorkerStoreUpdateExecutionLogEntryFunc{
			defaultHook: i.UpdateExecutionLogEntry,
		},
		WithFunc: &WorkerStoreWithFunc{
			defaultHook: i.With,
		},
	}
}

// WorkerStoreAddExecutionLogEntryFunc describes the behavior when the
// AddExecutionLogEntry method of the parent MockWorkerStore instance is
// invoked.
type WorkerStoreAddExecutionLogEntryFunc struct {
	defaultHook func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (int, error)
	hooks       []func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (int, error)
	history     []WorkerStoreAddExecutionLogEntryFuncCall
	mutex       sync.Mutex
}

// AddExecutionLogEntry delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockWorkerStore) AddExecutionLogEntry(v0 context.Context, v1 int, v2 workerutil.ExecutionLogEntry, v3 store.ExecutionLogEntryOptions) (int, error) {
	r0, r1 := m.AddExecutionLogEntryFunc.nextHook()(v0, v1, v2, v3)
	m.AddExecutionLogEntryFunc.appendCall(WorkerStoreAddExecutionLogEntryFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the AddExecutionLogEntry
// method of the parent MockWorkerStore instance is invoked and the hook
// queue is empty.
func (f *WorkerStoreAddExecutionLogEntryFunc) SetDefaultHook(hook func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// AddExecutionLogEntry method of the parent MockWorkerStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *WorkerStoreAddExecutionLogEntryFunc) PushHook(hook func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreAddExecutionLogEntryFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreAddExecutionLogEntryFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (int, error) {
		return r0, r1
	})
}

func (f *WorkerStoreAddExecutionLogEntryFunc) nextHook() func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreAddExecutionLogEntryFunc) appendCall(r0 WorkerStoreAddExecutionLogEntryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreAddExecutionLogEntryFuncCall
// objects describing the invocations of this function.
func (f *WorkerStoreAddExecutionLogEntryFunc) History() []WorkerStoreAddExecutionLogEntryFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreAddExecutionLogEntryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreAddExecutionLogEntryFuncCall is an object that describes an
// invocation of method AddExecutionLogEntry on an instance of
// MockWorkerStore.
type WorkerStoreAddExecutionLogEntryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 workerutil.ExecutionLogEntry
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 store.ExecutionLogEntryOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreAddExecutionLogEntryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreAddExecutionLogEntryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreDequeueFunc describes the behavior when the Dequeue method of
// the parent MockWorkerStore instance is invoked.
type WorkerStoreDequeueFunc struct {
	defaultHook func(context.Context, string, []*sqlf.Query) (workerutil.Record, bool, error)
	hooks       []func(context.Context, string, []*sqlf.Query) (workerutil.Record, bool, error)
	history     []WorkerStoreDequeueFuncCall
	mutex       sync.Mutex
}

// Dequeue delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore) Dequeue(v0 context.Context, v1 string, v2 []*sqlf.Query) (workerutil.Record, bool, error) {
	r0, r1, r2 := m.DequeueFunc.nextHook()(v0, v1, v2)
	m.DequeueFunc.appendCall(WorkerStoreDequeueFuncCall{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Dequeue method of
// the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreDequeueFunc) SetDefaultHook(hook func(context.Context, string, []*sqlf.Query) (workerutil.Record, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Dequeue method of the parent MockWorkerStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreDequeueFunc) PushHook(hook func(context.Context, string, []*sqlf.Query) (workerutil.Record, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreDequeueFunc) SetDefaultReturn(r0 workerutil.Record, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, string, []*sqlf.Query) (workerutil.Record, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreDequeueFunc) PushReturn(r0 workerutil.Record, r1 bool, r2 error) {
	f.PushHook(func(context.Context, string, []*sqlf.Query) (workerutil.Record, bool, error) {
		return r0, r1, r2
	})
}

func (f *WorkerStoreDequeueFunc) nextHook() func(context.Context, string, []*sqlf.Query) (workerutil.Record, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreDequeueFunc) appendCall(r0 WorkerStoreDequeueFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreDequeueFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreDequeueFunc) History() []WorkerStoreDequeueFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreDequeueFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreDequeueFuncCall is an object that describes an invocation of
// method Dequeue on an instance of MockWorkerStore.
type WorkerStoreDequeueFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []*sqlf.Query
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 workerutil.Record
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreDequeueFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreDequeueFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// WorkerStoreHandleFunc describes the behavior when the Handle method of
// the parent MockWorkerStore instance is invoked.
type WorkerStoreHandleFunc struct {
	defaultHook func() basestore.TransactableHandle
	hooks       []func() basestore.TransactableHandle
	history     []WorkerStoreHandleFuncCall
	mutex       sync.Mutex
}

// Handle delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore) Handle() basestore.TransactableHandle {
	r0 := m.HandleFunc.nextHook()()
	m.HandleFunc.appendCall(WorkerStoreHandleFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the Handle method of the
// parent MockWorkerStore instance is invoked and the hook queue is empty.
func (f *WorkerStoreHandleFunc) SetDefaultHook(hook func() basestore.TransactableHandle) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Handle method of the parent MockWorkerStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreHandleFunc) PushHook(hook func() basestore.TransactableHandle) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreHandleFunc) SetDefaultReturn(r0 basestore.TransactableHandle) {
	f.SetDefaultHook(func() basestore.TransactableHandle {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreHandleFunc) PushReturn(r0 basestore.TransactableHandle) {
	f.PushHook(func() basestore.TransactableHandle {
		return r0
	})
}

func (f *WorkerStoreHandleFunc) nextHook() func() basestore.TransactableHandle {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreHandleFunc) appendCall(r0 WorkerStoreHandleFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreHandleFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreHandleFunc) History() []WorkerStoreHandleFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreHandleFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreHandleFuncCall is an object that describes an invocation of
// method Handle on an instance of MockWorkerStore.
type WorkerStoreHandleFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 basestore.TransactableHandle
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreHandleFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreHandleFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// WorkerStoreHeartbeatFunc describes the behavior when the Heartbeat method
// of the parent MockWorkerStore instance is invoked.
type WorkerStoreHeartbeatFunc struct {
	defaultHook func(context.Context, []int, store.HeartbeatOptions) ([]int, error)
	hooks       []func(context.Context, []int, store.HeartbeatOptions) ([]int, error)
	history     []WorkerStoreHeartbeatFuncCall
	mutex       sync.Mutex
}

// Heartbeat delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore) Heartbeat(v0 context.Context, v1 []int, v2 store.HeartbeatOptions) ([]int, error) {
	r0, r1 := m.HeartbeatFunc.nextHook()(v0, v1, v2)
	m.HeartbeatFunc.appendCall(WorkerStoreHeartbeatFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Heartbeat method of
// the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreHeartbeatFunc) SetDefaultHook(hook func(context.Context, []int, store.HeartbeatOptions) ([]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Heartbeat method of the parent MockWorkerStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreHeartbeatFunc) PushHook(hook func(context.Context, []int, store.HeartbeatOptions) ([]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreHeartbeatFunc) SetDefaultReturn(r0 []int, r1 error) {
	f.SetDefaultHook(func(context.Context, []int, store.HeartbeatOptions) ([]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreHeartbeatFunc) PushReturn(r0 []int, r1 error) {
	f.PushHook(func(context.Context, []int, store.HeartbeatOptions) ([]int, error) {
		return r0, r1
	})
}

func (f *WorkerStoreHeartbeatFunc) nextHook() func(context.Context, []int, store.HeartbeatOptions) ([]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreHeartbeatFunc) appendCall(r0 WorkerStoreHeartbeatFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreHeartbeatFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreHeartbeatFunc) History() []WorkerStoreHeartbeatFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreHeartbeatFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreHeartbeatFuncCall is an object that describes an invocation of
// method Heartbeat on an instance of MockWorkerStore.
type WorkerStoreHeartbeatFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 store.HeartbeatOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreHeartbeatFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreHeartbeatFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreMarkCompleteFunc describes the behavior when the MarkComplete
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreMarkCompleteFunc struct {
	defaultHook func(context.Context, int, store.MarkFinalOptions) (bool, error)
	hooks       []func(context.Context, int, store.MarkFinalOptions) (bool, error)
	history     []WorkerStoreMarkCompleteFuncCall
	mutex       sync.Mutex
}

// MarkComplete delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore) MarkComplete(v0 context.Context, v1 int, v2 store.MarkFinalOptions) (bool, error) {
	r0, r1 := m.MarkCompleteFunc.nextHook()(v0, v1, v2)
	m.MarkCompleteFunc.appendCall(WorkerStoreMarkCompleteFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MarkComplete method
// of the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreMarkCompleteFunc) SetDefaultHook(hook func(context.Context, int, store.MarkFinalOptions) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkComplete method of the parent MockWorkerStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *WorkerStoreMarkCompleteFunc) PushHook(hook func(context.Context, int, store.MarkFinalOptions) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreMarkCompleteFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, store.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreMarkCompleteFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, store.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

func (f *WorkerStoreMarkCompleteFunc) nextHook() func(context.Context, int, store.MarkFinalOptions) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreMarkCompleteFunc) appendCall(r0 WorkerStoreMarkCompleteFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreMarkCompleteFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreMarkCompleteFunc) History() []WorkerStoreMarkCompleteFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreMarkCompleteFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreMarkCompleteFuncCall is an object that describes an invocation
// of method MarkComplete on an instance of MockWorkerStore.
type WorkerStoreMarkCompleteFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 store.MarkFinalOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreMarkCompleteFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreMarkCompleteFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreMarkErroredFunc describes the behavior when the MarkErrored
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreMarkErroredFunc struct {
	defaultHook func(context.Context, int, string, store.MarkFinalOptions) (bool, error)
	hooks       []func(context.Context, int, string, store.MarkFinalOptions) (bool, error)
	history     []WorkerStoreMarkErroredFuncCall
	mutex       sync.Mutex
}

// MarkErrored delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore) MarkErrored(v0 context.Context, v1 int, v2 string, v3 store.MarkFinalOptions) (bool, error) {
	r0, r1 := m.MarkErroredFunc.nextHook()(v0, v1, v2, v3)
	m.MarkErroredFunc.appendCall(WorkerStoreMarkErroredFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MarkErrored method
// of the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreMarkErroredFunc) SetDefaultHook(hook func(context.Context, int, string, store.MarkFinalOptions) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkErrored method of the parent MockWorkerStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *WorkerStoreMarkErroredFunc) PushHook(hook func(context.Context, int, string, store.MarkFinalOptions) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreMarkErroredFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, store.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreMarkErroredFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string, store.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

func (f *WorkerStoreMarkErroredFunc) nextHook() func(context.Context, int, string, store.MarkFinalOptions) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreMarkErroredFunc) appendCall(r0 WorkerStoreMarkErroredFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreMarkErroredFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreMarkErroredFunc) History() []WorkerStoreMarkErroredFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreMarkErroredFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreMarkErroredFuncCall is an object that describes an invocation
// of method MarkErrored on an instance of MockWorkerStore.
type WorkerStoreMarkErroredFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 store.MarkFinalOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreMarkErroredFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreMarkErroredFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreMarkFailedFunc describes the behavior when the MarkFailed
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreMarkFailedFunc struct {
	defaultHook func(context.Context, int, string, store.MarkFinalOptions) (bool, error)
	hooks       []func(context.Context, int, string, store.MarkFinalOptions) (bool, error)
	history     []WorkerStoreMarkFailedFuncCall
	mutex       sync.Mutex
}

// MarkFailed delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore) MarkFailed(v0 context.Context, v1 int, v2 string, v3 store.MarkFinalOptions) (bool, error) {
	r0, r1 := m.MarkFailedFunc.nextHook()(v0, v1, v2, v3)
	m.MarkFailedFunc.appendCall(WorkerStoreMarkFailedFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MarkFailed method of
// the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreMarkFailedFunc) SetDefaultHook(hook func(context.Context, int, string, store.MarkFinalOptions) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkFailed method of the parent MockWorkerStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreMarkFailedFunc) PushHook(hook func(context.Context, int, string, store.MarkFinalOptions) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreMarkFailedFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, store.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreMarkFailedFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string, store.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

func (f *WorkerStoreMarkFailedFunc) nextHook() func(context.Context, int, string, store.MarkFinalOptions) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreMarkFailedFunc) appendCall(r0 WorkerStoreMarkFailedFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreMarkFailedFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreMarkFailedFunc) History() []WorkerStoreMarkFailedFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreMarkFailedFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreMarkFailedFuncCall is an object that describes an invocation
// of method MarkFailed on an instance of MockWorkerStore.
type WorkerStoreMarkFailedFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 store.MarkFinalOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreMarkFailedFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreMarkFailedFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreMaxDurationInQueueFunc describes the behavior when the
// MaxDurationInQueue method of the parent MockWorkerStore instance is
// invoked.
type WorkerStoreMaxDurationInQueueFunc struct {
	defaultHook func(context.Context) (time.Duration, error)
	hooks       []func(context.Context) (time.Duration, error)
	history     []WorkerStoreMaxDurationInQueueFuncCall
	mutex       sync.Mutex
}

// MaxDurationInQueue delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockWorkerStore) MaxDurationInQueue(v0 context.Context) (time.Duration, error) {
	r0, r1 := m.MaxDurationInQueueFunc.nextHook()(v0)
	m.MaxDurationInQueueFunc.appendCall(WorkerStoreMaxDurationInQueueFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MaxDurationInQueue
// method of the parent MockWorkerStore instance is invoked and the hook
// queue is empty.
func (f *WorkerStoreMaxDurationInQueueFunc) SetDefaultHook(hook func(context.Context) (time.Duration, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MaxDurationInQueue method of the parent MockWorkerStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *WorkerStoreMaxDurationInQueueFunc) PushHook(hook func(context.Context) (time.Duration, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreMaxDurationInQueueFunc) SetDefaultReturn(r0 time.Duration, r1 error) {
	f.SetDefaultHook(func(context.Context) (time.Duration, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreMaxDurationInQueueFunc) PushReturn(r0 time.Duration, r1 error) {
	f.PushHook(func(context.Context) (time.Duration, error) {
		return r0, r1
	})
}

func (f *WorkerStoreMaxDurationInQueueFunc) nextHook() func(context.Context) (time.Duration, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreMaxDurationInQueueFunc) appendCall(r0 WorkerStoreMaxDurationInQueueFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreMaxDurationInQueueFuncCall
// objects describing the invocations of this function.
func (f *WorkerStoreMaxDurationInQueueFunc) History() []WorkerStoreMaxDurationInQueueFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreMaxDurationInQueueFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreMaxDurationInQueueFuncCall is an object that describes an
// invocation of method MaxDurationInQueue on an instance of
// MockWorkerStore.
type WorkerStoreMaxDurationInQueueFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 time.Duration
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreMaxDurationInQueueFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreMaxDurationInQueueFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreQueuedCountFunc describes the behavior when the QueuedCount
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreQueuedCountFunc struct {
	defaultHook func(context.Context, bool) (int, error)
	hooks       []func(context.Context, bool) (int, error)
	history     []WorkerStoreQueuedCountFuncCall
	mutex       sync.Mutex
}

// QueuedCount delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore) QueuedCount(v0 context.Context, v1 bool) (int, error) {
	r0, r1 := m.QueuedCountFunc.nextHook()(v0, v1)
	m.QueuedCountFunc.appendCall(WorkerStoreQueuedCountFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the QueuedCount method
// of the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreQueuedCountFunc) SetDefaultHook(hook func(context.Context, bool) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// QueuedCount method of the parent MockWorkerStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *WorkerStoreQueuedCountFunc) PushHook(hook func(context.Context, bool) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreQueuedCountFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, bool) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreQueuedCountFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, bool) (int, error) {
		return r0, r1
	})
}

func (f *WorkerStoreQueuedCountFunc) nextHook() func(context.Context, bool) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreQueuedCountFunc) appendCall(r0 WorkerStoreQueuedCountFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreQueuedCountFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreQueuedCountFunc) History() []WorkerStoreQueuedCountFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreQueuedCountFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreQueuedCountFuncCall is an object that describes an invocation
// of method QueuedCount on an instance of MockWorkerStore.
type WorkerStoreQueuedCountFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 bool
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreQueuedCountFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreQueuedCountFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreRequeueFunc describes the behavior when the Requeue method of
// the parent MockWorkerStore instance is invoked.
type WorkerStoreRequeueFunc struct {
	defaultHook func(context.Context, int, time.Time) error
	hooks       []func(context.Context, int, time.Time) error
	history     []WorkerStoreRequeueFuncCall
	mutex       sync.Mutex
}

// Requeue delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore) Requeue(v0 context.Context, v1 int, v2 time.Time) error {
	r0 := m.RequeueFunc.nextHook()(v0, v1, v2)
	m.RequeueFunc.appendCall(WorkerStoreRequeueFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Requeue method of
// the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreRequeueFunc) SetDefaultHook(hook func(context.Context, int, time.Time) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Requeue method of the parent MockWorkerStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreRequeueFunc) PushHook(hook func(context.Context, int, time.Time) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreRequeueFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreRequeueFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

func (f *WorkerStoreRequeueFunc) nextHook() func(context.Context, int, time.Time) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreRequeueFunc) appendCall(r0 WorkerStoreRequeueFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreRequeueFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreRequeueFunc) History() []WorkerStoreRequeueFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreRequeueFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreRequeueFuncCall is an object that describes an invocation of
// method Requeue on an instance of MockWorkerStore.
type WorkerStoreRequeueFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreRequeueFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreRequeueFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// WorkerStoreResetStalledFunc describes the behavior when the ResetStalled
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreResetStalledFunc struct {
	defaultHook func(context.Context) (map[int]time.Duration, map[int]time.Duration, error)
	hooks       []func(context.Context) (map[int]time.Duration, map[int]time.Duration, error)
	history     []WorkerStoreResetStalledFuncCall
	mutex       sync.Mutex
}

// ResetStalled delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore) ResetStalled(v0 context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
	r0, r1, r2 := m.ResetStalledFunc.nextHook()(v0)
	m.ResetStalledFunc.appendCall(WorkerStoreResetStalledFuncCall{v0, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the ResetStalled method
// of the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreResetStalledFunc) SetDefaultHook(hook func(context.Context) (map[int]time.Duration, map[int]time.Duration, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ResetStalled method of the parent MockWorkerStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *WorkerStoreResetStalledFunc) PushHook(hook func(context.Context) (map[int]time.Duration, map[int]time.Duration, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreResetStalledFunc) SetDefaultReturn(r0 map[int]time.Duration, r1 map[int]time.Duration, r2 error) {
	f.SetDefaultHook(func(context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreResetStalledFunc) PushReturn(r0 map[int]time.Duration, r1 map[int]time.Duration, r2 error) {
	f.PushHook(func(context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
		return r0, r1, r2
	})
}

func (f *WorkerStoreResetStalledFunc) nextHook() func(context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreResetStalledFunc) appendCall(r0 WorkerStoreResetStalledFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreResetStalledFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreResetStalledFunc) History() []WorkerStoreResetStalledFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreResetStalledFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreResetStalledFuncCall is an object that describes an invocation
// of method ResetStalled on an instance of MockWorkerStore.
type WorkerStoreResetStalledFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[int]time.Duration
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 map[int]time.Duration
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreResetStalledFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreResetStalledFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// WorkerStoreUpdateExecutionLogEntryFunc describes the behavior when the
// UpdateExecutionLogEntry method of the parent MockWorkerStore instance is
// invoked.
type WorkerStoreUpdateExecutionLogEntryFunc struct {
	defaultHook func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) error
	hooks       []func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) error
	history     []WorkerStoreUpdateExecutionLogEntryFuncCall
	mutex       sync.Mutex
}

// UpdateExecutionLogEntry delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockWorkerStore) UpdateExecutionLogEntry(v0 context.Context, v1 int, v2 int, v3 workerutil.ExecutionLogEntry, v4 store.ExecutionLogEntryOptions) error {
	r0 := m.UpdateExecutionLogEntryFunc.nextHook()(v0, v1, v2, v3, v4)
	m.UpdateExecutionLogEntryFunc.appendCall(WorkerStoreUpdateExecutionLogEntryFuncCall{v0, v1, v2, v3, v4, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdateExecutionLogEntry method of the parent MockWorkerStore instance is
// invoked and the hook queue is empty.
func (f *WorkerStoreUpdateExecutionLogEntryFunc) SetDefaultHook(hook func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateExecutionLogEntry method of the parent MockWorkerStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *WorkerStoreUpdateExecutionLogEntryFunc) PushHook(hook func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreUpdateExecutionLogEntryFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreUpdateExecutionLogEntryFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) error {
		return r0
	})
}

func (f *WorkerStoreUpdateExecutionLogEntryFunc) nextHook() func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreUpdateExecutionLogEntryFunc) appendCall(r0 WorkerStoreUpdateExecutionLogEntryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreUpdateExecutionLogEntryFuncCall
// objects describing the invocations of this function.
func (f *WorkerStoreUpdateExecutionLogEntryFunc) History() []WorkerStoreUpdateExecutionLogEntryFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreUpdateExecutionLogEntryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreUpdateExecutionLogEntryFuncCall is an object that describes an
// invocation of method UpdateExecutionLogEntry on an instance of
// MockWorkerStore.
type WorkerStoreUpdateExecutionLogEntryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 workerutil.ExecutionLogEntry
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 store.ExecutionLogEntryOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreUpdateExecutionLogEntryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreUpdateExecutionLogEntryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// WorkerStoreWithFunc describes the behavior when the With method of the
// parent MockWorkerStore instance is invoked.
type WorkerStoreWithFunc struct {
	defaultHook func(basestore.ShareableStore) store.Store
	hooks       []func(basestore.ShareableStore) store.Store
	history     []WorkerStoreWithFuncCall
	mutex       sync.Mutex
}

// With delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore) With(v0 basestore.ShareableStore) store.Store {
	r0 := m.WithFunc.nextHook()(v0)
	m.WithFunc.appendCall(WorkerStoreWithFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the With method of the
// parent MockWorkerStore instance is invoked and the hook queue is empty.
func (f *WorkerStoreWithFunc) SetDefaultHook(hook func(basestore.ShareableStore) store.Store) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// With method of the parent MockWorkerStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreWithFunc) PushHook(hook func(basestore.ShareableStore) store.Store) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreWithFunc) SetDefaultReturn(r0 store.Store) {
	f.SetDefaultHook(func(basestore.ShareableStore) store.Store {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreWithFunc) PushReturn(r0 store.Store) {
	f.PushHook(func(basestore.ShareableStore) store.Store {
		return r0
	})
}

func (f *WorkerStoreWithFunc) nextHook() func(basestore.ShareableStore) store.Store {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreWithFunc) appendCall(r0 WorkerStoreWithFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreWithFuncCall objects describing
// the invocations of this function.
func (f *WorkerStoreWithFunc) History() []WorkerStoreWithFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreWithFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreWithFuncCall is an object that describes an invocation of
// method With on an instance of MockWorkerStore.
type WorkerStoreWithFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 basestore.ShareableStore
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Store
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreWithFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreWithFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}
