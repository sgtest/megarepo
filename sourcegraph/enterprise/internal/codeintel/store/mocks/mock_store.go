// Code generated by github.com/efritz/go-mockgen 0.1.0; DO NOT EDIT.

package mocks

import (
	"context"
	types "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/bundles/types"
	store "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/store"
	"sync"
	"time"
)

// MockStore is a mock implementation of the Store interface (from the
// package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/store)
// used for unit testing.
type MockStore struct {
	// AddUploadPartFunc is an instance of a mock function object
	// controlling the behavior of the method AddUploadPart.
	AddUploadPartFunc *StoreAddUploadPartFunc
	// DeleteIndexByIDFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteIndexByID.
	DeleteIndexByIDFunc *StoreDeleteIndexByIDFunc
	// DeleteOldestDumpFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteOldestDump.
	DeleteOldestDumpFunc *StoreDeleteOldestDumpFunc
	// DeleteOverlappingDumpsFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteOverlappingDumps.
	DeleteOverlappingDumpsFunc *StoreDeleteOverlappingDumpsFunc
	// DeleteUploadByIDFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteUploadByID.
	DeleteUploadByIDFunc *StoreDeleteUploadByIDFunc
	// DequeueFunc is an instance of a mock function object controlling the
	// behavior of the method Dequeue.
	DequeueFunc *StoreDequeueFunc
	// DequeueIndexFunc is an instance of a mock function object controlling
	// the behavior of the method DequeueIndex.
	DequeueIndexFunc *StoreDequeueIndexFunc
	// DoneFunc is an instance of a mock function object controlling the
	// behavior of the method Done.
	DoneFunc *StoreDoneFunc
	// FindClosestDumpsFunc is an instance of a mock function object
	// controlling the behavior of the method FindClosestDumps.
	FindClosestDumpsFunc *StoreFindClosestDumpsFunc
	// GetDumpByIDFunc is an instance of a mock function object controlling
	// the behavior of the method GetDumpByID.
	GetDumpByIDFunc *StoreGetDumpByIDFunc
	// GetIndexByIDFunc is an instance of a mock function object controlling
	// the behavior of the method GetIndexByID.
	GetIndexByIDFunc *StoreGetIndexByIDFunc
	// GetIndexesFunc is an instance of a mock function object controlling
	// the behavior of the method GetIndexes.
	GetIndexesFunc *StoreGetIndexesFunc
	// GetPackageFunc is an instance of a mock function object controlling
	// the behavior of the method GetPackage.
	GetPackageFunc *StoreGetPackageFunc
	// GetStatesFunc is an instance of a mock function object controlling
	// the behavior of the method GetStates.
	GetStatesFunc *StoreGetStatesFunc
	// GetUploadByIDFunc is an instance of a mock function object
	// controlling the behavior of the method GetUploadByID.
	GetUploadByIDFunc *StoreGetUploadByIDFunc
	// GetUploadsFunc is an instance of a mock function object controlling
	// the behavior of the method GetUploads.
	GetUploadsFunc *StoreGetUploadsFunc
	// HasCommitFunc is an instance of a mock function object controlling
	// the behavior of the method HasCommit.
	HasCommitFunc *StoreHasCommitFunc
	// IndexQueueSizeFunc is an instance of a mock function object
	// controlling the behavior of the method IndexQueueSize.
	IndexQueueSizeFunc *StoreIndexQueueSizeFunc
	// IndexableRepositoriesFunc is an instance of a mock function object
	// controlling the behavior of the method IndexableRepositories.
	IndexableRepositoriesFunc *StoreIndexableRepositoriesFunc
	// InsertIndexFunc is an instance of a mock function object controlling
	// the behavior of the method InsertIndex.
	InsertIndexFunc *StoreInsertIndexFunc
	// InsertUploadFunc is an instance of a mock function object controlling
	// the behavior of the method InsertUpload.
	InsertUploadFunc *StoreInsertUploadFunc
	// IsQueuedFunc is an instance of a mock function object controlling the
	// behavior of the method IsQueued.
	IsQueuedFunc *StoreIsQueuedFunc
	// MarkCompleteFunc is an instance of a mock function object controlling
	// the behavior of the method MarkComplete.
	MarkCompleteFunc *StoreMarkCompleteFunc
	// MarkErroredFunc is an instance of a mock function object controlling
	// the behavior of the method MarkErrored.
	MarkErroredFunc *StoreMarkErroredFunc
	// MarkIndexCompleteFunc is an instance of a mock function object
	// controlling the behavior of the method MarkIndexComplete.
	MarkIndexCompleteFunc *StoreMarkIndexCompleteFunc
	// MarkIndexErroredFunc is an instance of a mock function object
	// controlling the behavior of the method MarkIndexErrored.
	MarkIndexErroredFunc *StoreMarkIndexErroredFunc
	// MarkQueuedFunc is an instance of a mock function object controlling
	// the behavior of the method MarkQueued.
	MarkQueuedFunc *StoreMarkQueuedFunc
	// PackageReferencePagerFunc is an instance of a mock function object
	// controlling the behavior of the method PackageReferencePager.
	PackageReferencePagerFunc *StorePackageReferencePagerFunc
	// QueueSizeFunc is an instance of a mock function object controlling
	// the behavior of the method QueueSize.
	QueueSizeFunc *StoreQueueSizeFunc
	// RepoNameFunc is an instance of a mock function object controlling the
	// behavior of the method RepoName.
	RepoNameFunc *StoreRepoNameFunc
	// RepoUsageStatisticsFunc is an instance of a mock function object
	// controlling the behavior of the method RepoUsageStatistics.
	RepoUsageStatisticsFunc *StoreRepoUsageStatisticsFunc
	// RequeueFunc is an instance of a mock function object controlling the
	// behavior of the method Requeue.
	RequeueFunc *StoreRequeueFunc
	// RequeueIndexFunc is an instance of a mock function object controlling
	// the behavior of the method RequeueIndex.
	RequeueIndexFunc *StoreRequeueIndexFunc
	// ResetStalledFunc is an instance of a mock function object controlling
	// the behavior of the method ResetStalled.
	ResetStalledFunc *StoreResetStalledFunc
	// ResetStalledIndexesFunc is an instance of a mock function object
	// controlling the behavior of the method ResetStalledIndexes.
	ResetStalledIndexesFunc *StoreResetStalledIndexesFunc
	// RollbackToSavepointFunc is an instance of a mock function object
	// controlling the behavior of the method RollbackToSavepoint.
	RollbackToSavepointFunc *StoreRollbackToSavepointFunc
	// SameRepoPagerFunc is an instance of a mock function object
	// controlling the behavior of the method SameRepoPager.
	SameRepoPagerFunc *StoreSameRepoPagerFunc
	// SavepointFunc is an instance of a mock function object controlling
	// the behavior of the method Savepoint.
	SavepointFunc *StoreSavepointFunc
	// TransactFunc is an instance of a mock function object controlling the
	// behavior of the method Transact.
	TransactFunc *StoreTransactFunc
	// UpdateCommitsFunc is an instance of a mock function object
	// controlling the behavior of the method UpdateCommits.
	UpdateCommitsFunc *StoreUpdateCommitsFunc
	// UpdateDumpsVisibleFromTipFunc is an instance of a mock function
	// object controlling the behavior of the method
	// UpdateDumpsVisibleFromTip.
	UpdateDumpsVisibleFromTipFunc *StoreUpdateDumpsVisibleFromTipFunc
	// UpdateIndexableRepositoryFunc is an instance of a mock function
	// object controlling the behavior of the method
	// UpdateIndexableRepository.
	UpdateIndexableRepositoryFunc *StoreUpdateIndexableRepositoryFunc
	// UpdatePackageReferencesFunc is an instance of a mock function object
	// controlling the behavior of the method UpdatePackageReferences.
	UpdatePackageReferencesFunc *StoreUpdatePackageReferencesFunc
	// UpdatePackagesFunc is an instance of a mock function object
	// controlling the behavior of the method UpdatePackages.
	UpdatePackagesFunc *StoreUpdatePackagesFunc
}

// NewMockStore creates a new mock of the Store interface. All methods
// return zero values for all results, unless overwritten.
func NewMockStore() *MockStore {
	return &MockStore{
		AddUploadPartFunc: &StoreAddUploadPartFunc{
			defaultHook: func(context.Context, int, int) error {
				return nil
			},
		},
		DeleteIndexByIDFunc: &StoreDeleteIndexByIDFunc{
			defaultHook: func(context.Context, int) (bool, error) {
				return false, nil
			},
		},
		DeleteOldestDumpFunc: &StoreDeleteOldestDumpFunc{
			defaultHook: func(context.Context) (int, bool, error) {
				return 0, false, nil
			},
		},
		DeleteOverlappingDumpsFunc: &StoreDeleteOverlappingDumpsFunc{
			defaultHook: func(context.Context, int, string, string, string) error {
				return nil
			},
		},
		DeleteUploadByIDFunc: &StoreDeleteUploadByIDFunc{
			defaultHook: func(context.Context, int, store.GetTipCommitFunc) (bool, error) {
				return false, nil
			},
		},
		DequeueFunc: &StoreDequeueFunc{
			defaultHook: func(context.Context) (store.Upload, store.Store, bool, error) {
				return store.Upload{}, nil, false, nil
			},
		},
		DequeueIndexFunc: &StoreDequeueIndexFunc{
			defaultHook: func(context.Context) (store.Index, store.Store, bool, error) {
				return store.Index{}, nil, false, nil
			},
		},
		DoneFunc: &StoreDoneFunc{
			defaultHook: func(error) error {
				return nil
			},
		},
		FindClosestDumpsFunc: &StoreFindClosestDumpsFunc{
			defaultHook: func(context.Context, int, string, string, bool, string) ([]store.Dump, error) {
				return nil, nil
			},
		},
		GetDumpByIDFunc: &StoreGetDumpByIDFunc{
			defaultHook: func(context.Context, int) (store.Dump, bool, error) {
				return store.Dump{}, false, nil
			},
		},
		GetIndexByIDFunc: &StoreGetIndexByIDFunc{
			defaultHook: func(context.Context, int) (store.Index, bool, error) {
				return store.Index{}, false, nil
			},
		},
		GetIndexesFunc: &StoreGetIndexesFunc{
			defaultHook: func(context.Context, store.GetIndexesOptions) ([]store.Index, int, error) {
				return nil, 0, nil
			},
		},
		GetPackageFunc: &StoreGetPackageFunc{
			defaultHook: func(context.Context, string, string, string) (store.Dump, bool, error) {
				return store.Dump{}, false, nil
			},
		},
		GetStatesFunc: &StoreGetStatesFunc{
			defaultHook: func(context.Context, []int) (map[int]string, error) {
				return nil, nil
			},
		},
		GetUploadByIDFunc: &StoreGetUploadByIDFunc{
			defaultHook: func(context.Context, int) (store.Upload, bool, error) {
				return store.Upload{}, false, nil
			},
		},
		GetUploadsFunc: &StoreGetUploadsFunc{
			defaultHook: func(context.Context, store.GetUploadsOptions) ([]store.Upload, int, error) {
				return nil, 0, nil
			},
		},
		HasCommitFunc: &StoreHasCommitFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				return false, nil
			},
		},
		IndexQueueSizeFunc: &StoreIndexQueueSizeFunc{
			defaultHook: func(context.Context) (int, error) {
				return 0, nil
			},
		},
		IndexableRepositoriesFunc: &StoreIndexableRepositoriesFunc{
			defaultHook: func(context.Context, store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error) {
				return nil, nil
			},
		},
		InsertIndexFunc: &StoreInsertIndexFunc{
			defaultHook: func(context.Context, store.Index) (int, error) {
				return 0, nil
			},
		},
		InsertUploadFunc: &StoreInsertUploadFunc{
			defaultHook: func(context.Context, store.Upload) (int, error) {
				return 0, nil
			},
		},
		IsQueuedFunc: &StoreIsQueuedFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				return false, nil
			},
		},
		MarkCompleteFunc: &StoreMarkCompleteFunc{
			defaultHook: func(context.Context, int) error {
				return nil
			},
		},
		MarkErroredFunc: &StoreMarkErroredFunc{
			defaultHook: func(context.Context, int, string) error {
				return nil
			},
		},
		MarkIndexCompleteFunc: &StoreMarkIndexCompleteFunc{
			defaultHook: func(context.Context, int) error {
				return nil
			},
		},
		MarkIndexErroredFunc: &StoreMarkIndexErroredFunc{
			defaultHook: func(context.Context, int, string) error {
				return nil
			},
		},
		MarkQueuedFunc: &StoreMarkQueuedFunc{
			defaultHook: func(context.Context, int) error {
				return nil
			},
		},
		PackageReferencePagerFunc: &StorePackageReferencePagerFunc{
			defaultHook: func(context.Context, string, string, string, int, int) (int, store.ReferencePager, error) {
				return 0, nil, nil
			},
		},
		QueueSizeFunc: &StoreQueueSizeFunc{
			defaultHook: func(context.Context) (int, error) {
				return 0, nil
			},
		},
		RepoNameFunc: &StoreRepoNameFunc{
			defaultHook: func(context.Context, int) (string, error) {
				return "", nil
			},
		},
		RepoUsageStatisticsFunc: &StoreRepoUsageStatisticsFunc{
			defaultHook: func(context.Context) ([]store.RepoUsageStatistics, error) {
				return nil, nil
			},
		},
		RequeueFunc: &StoreRequeueFunc{
			defaultHook: func(context.Context, int, time.Time) error {
				return nil
			},
		},
		RequeueIndexFunc: &StoreRequeueIndexFunc{
			defaultHook: func(context.Context, int, time.Time) error {
				return nil
			},
		},
		ResetStalledFunc: &StoreResetStalledFunc{
			defaultHook: func(context.Context, time.Time) ([]int, []int, error) {
				return nil, nil, nil
			},
		},
		ResetStalledIndexesFunc: &StoreResetStalledIndexesFunc{
			defaultHook: func(context.Context, time.Time) ([]int, []int, error) {
				return nil, nil, nil
			},
		},
		RollbackToSavepointFunc: &StoreRollbackToSavepointFunc{
			defaultHook: func(context.Context, string) error {
				return nil
			},
		},
		SameRepoPagerFunc: &StoreSameRepoPagerFunc{
			defaultHook: func(context.Context, int, string, string, string, string, int) (int, store.ReferencePager, error) {
				return 0, nil, nil
			},
		},
		SavepointFunc: &StoreSavepointFunc{
			defaultHook: func(context.Context) (string, error) {
				return "", nil
			},
		},
		TransactFunc: &StoreTransactFunc{
			defaultHook: func(context.Context) (store.Store, error) {
				return nil, nil
			},
		},
		UpdateCommitsFunc: &StoreUpdateCommitsFunc{
			defaultHook: func(context.Context, int, map[string][]string) error {
				return nil
			},
		},
		UpdateDumpsVisibleFromTipFunc: &StoreUpdateDumpsVisibleFromTipFunc{
			defaultHook: func(context.Context, int, string) error {
				return nil
			},
		},
		UpdateIndexableRepositoryFunc: &StoreUpdateIndexableRepositoryFunc{
			defaultHook: func(context.Context, store.UpdateableIndexableRepository) error {
				return nil
			},
		},
		UpdatePackageReferencesFunc: &StoreUpdatePackageReferencesFunc{
			defaultHook: func(context.Context, []types.PackageReference) error {
				return nil
			},
		},
		UpdatePackagesFunc: &StoreUpdatePackagesFunc{
			defaultHook: func(context.Context, []types.Package) error {
				return nil
			},
		},
	}
}

// NewMockStoreFrom creates a new mock of the MockStore interface. All
// methods delegate to the given implementation, unless overwritten.
func NewMockStoreFrom(i store.Store) *MockStore {
	return &MockStore{
		AddUploadPartFunc: &StoreAddUploadPartFunc{
			defaultHook: i.AddUploadPart,
		},
		DeleteIndexByIDFunc: &StoreDeleteIndexByIDFunc{
			defaultHook: i.DeleteIndexByID,
		},
		DeleteOldestDumpFunc: &StoreDeleteOldestDumpFunc{
			defaultHook: i.DeleteOldestDump,
		},
		DeleteOverlappingDumpsFunc: &StoreDeleteOverlappingDumpsFunc{
			defaultHook: i.DeleteOverlappingDumps,
		},
		DeleteUploadByIDFunc: &StoreDeleteUploadByIDFunc{
			defaultHook: i.DeleteUploadByID,
		},
		DequeueFunc: &StoreDequeueFunc{
			defaultHook: i.Dequeue,
		},
		DequeueIndexFunc: &StoreDequeueIndexFunc{
			defaultHook: i.DequeueIndex,
		},
		DoneFunc: &StoreDoneFunc{
			defaultHook: i.Done,
		},
		FindClosestDumpsFunc: &StoreFindClosestDumpsFunc{
			defaultHook: i.FindClosestDumps,
		},
		GetDumpByIDFunc: &StoreGetDumpByIDFunc{
			defaultHook: i.GetDumpByID,
		},
		GetIndexByIDFunc: &StoreGetIndexByIDFunc{
			defaultHook: i.GetIndexByID,
		},
		GetIndexesFunc: &StoreGetIndexesFunc{
			defaultHook: i.GetIndexes,
		},
		GetPackageFunc: &StoreGetPackageFunc{
			defaultHook: i.GetPackage,
		},
		GetStatesFunc: &StoreGetStatesFunc{
			defaultHook: i.GetStates,
		},
		GetUploadByIDFunc: &StoreGetUploadByIDFunc{
			defaultHook: i.GetUploadByID,
		},
		GetUploadsFunc: &StoreGetUploadsFunc{
			defaultHook: i.GetUploads,
		},
		HasCommitFunc: &StoreHasCommitFunc{
			defaultHook: i.HasCommit,
		},
		IndexQueueSizeFunc: &StoreIndexQueueSizeFunc{
			defaultHook: i.IndexQueueSize,
		},
		IndexableRepositoriesFunc: &StoreIndexableRepositoriesFunc{
			defaultHook: i.IndexableRepositories,
		},
		InsertIndexFunc: &StoreInsertIndexFunc{
			defaultHook: i.InsertIndex,
		},
		InsertUploadFunc: &StoreInsertUploadFunc{
			defaultHook: i.InsertUpload,
		},
		IsQueuedFunc: &StoreIsQueuedFunc{
			defaultHook: i.IsQueued,
		},
		MarkCompleteFunc: &StoreMarkCompleteFunc{
			defaultHook: i.MarkComplete,
		},
		MarkErroredFunc: &StoreMarkErroredFunc{
			defaultHook: i.MarkErrored,
		},
		MarkIndexCompleteFunc: &StoreMarkIndexCompleteFunc{
			defaultHook: i.MarkIndexComplete,
		},
		MarkIndexErroredFunc: &StoreMarkIndexErroredFunc{
			defaultHook: i.MarkIndexErrored,
		},
		MarkQueuedFunc: &StoreMarkQueuedFunc{
			defaultHook: i.MarkQueued,
		},
		PackageReferencePagerFunc: &StorePackageReferencePagerFunc{
			defaultHook: i.PackageReferencePager,
		},
		QueueSizeFunc: &StoreQueueSizeFunc{
			defaultHook: i.QueueSize,
		},
		RepoNameFunc: &StoreRepoNameFunc{
			defaultHook: i.RepoName,
		},
		RepoUsageStatisticsFunc: &StoreRepoUsageStatisticsFunc{
			defaultHook: i.RepoUsageStatistics,
		},
		RequeueFunc: &StoreRequeueFunc{
			defaultHook: i.Requeue,
		},
		RequeueIndexFunc: &StoreRequeueIndexFunc{
			defaultHook: i.RequeueIndex,
		},
		ResetStalledFunc: &StoreResetStalledFunc{
			defaultHook: i.ResetStalled,
		},
		ResetStalledIndexesFunc: &StoreResetStalledIndexesFunc{
			defaultHook: i.ResetStalledIndexes,
		},
		RollbackToSavepointFunc: &StoreRollbackToSavepointFunc{
			defaultHook: i.RollbackToSavepoint,
		},
		SameRepoPagerFunc: &StoreSameRepoPagerFunc{
			defaultHook: i.SameRepoPager,
		},
		SavepointFunc: &StoreSavepointFunc{
			defaultHook: i.Savepoint,
		},
		TransactFunc: &StoreTransactFunc{
			defaultHook: i.Transact,
		},
		UpdateCommitsFunc: &StoreUpdateCommitsFunc{
			defaultHook: i.UpdateCommits,
		},
		UpdateDumpsVisibleFromTipFunc: &StoreUpdateDumpsVisibleFromTipFunc{
			defaultHook: i.UpdateDumpsVisibleFromTip,
		},
		UpdateIndexableRepositoryFunc: &StoreUpdateIndexableRepositoryFunc{
			defaultHook: i.UpdateIndexableRepository,
		},
		UpdatePackageReferencesFunc: &StoreUpdatePackageReferencesFunc{
			defaultHook: i.UpdatePackageReferences,
		},
		UpdatePackagesFunc: &StoreUpdatePackagesFunc{
			defaultHook: i.UpdatePackages,
		},
	}
}

// StoreAddUploadPartFunc describes the behavior when the AddUploadPart
// method of the parent MockStore instance is invoked.
type StoreAddUploadPartFunc struct {
	defaultHook func(context.Context, int, int) error
	hooks       []func(context.Context, int, int) error
	history     []StoreAddUploadPartFuncCall
	mutex       sync.Mutex
}

// AddUploadPart delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) AddUploadPart(v0 context.Context, v1 int, v2 int) error {
	r0 := m.AddUploadPartFunc.nextHook()(v0, v1, v2)
	m.AddUploadPartFunc.appendCall(StoreAddUploadPartFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the AddUploadPart method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreAddUploadPartFunc) SetDefaultHook(hook func(context.Context, int, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// AddUploadPart method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreAddUploadPartFunc) PushHook(hook func(context.Context, int, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreAddUploadPartFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreAddUploadPartFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, int) error {
		return r0
	})
}

func (f *StoreAddUploadPartFunc) nextHook() func(context.Context, int, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreAddUploadPartFunc) appendCall(r0 StoreAddUploadPartFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreAddUploadPartFuncCall objects
// describing the invocations of this function.
func (f *StoreAddUploadPartFunc) History() []StoreAddUploadPartFuncCall {
	f.mutex.Lock()
	history := make([]StoreAddUploadPartFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreAddUploadPartFuncCall is an object that describes an invocation of
// method AddUploadPart on an instance of MockStore.
type StoreAddUploadPartFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreAddUploadPartFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreAddUploadPartFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreDeleteIndexByIDFunc describes the behavior when the DeleteIndexByID
// method of the parent MockStore instance is invoked.
type StoreDeleteIndexByIDFunc struct {
	defaultHook func(context.Context, int) (bool, error)
	hooks       []func(context.Context, int) (bool, error)
	history     []StoreDeleteIndexByIDFuncCall
	mutex       sync.Mutex
}

// DeleteIndexByID delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) DeleteIndexByID(v0 context.Context, v1 int) (bool, error) {
	r0, r1 := m.DeleteIndexByIDFunc.nextHook()(v0, v1)
	m.DeleteIndexByIDFunc.appendCall(StoreDeleteIndexByIDFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DeleteIndexByID
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreDeleteIndexByIDFunc) SetDefaultHook(hook func(context.Context, int) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteIndexByID method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreDeleteIndexByIDFunc) PushHook(hook func(context.Context, int) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDeleteIndexByIDFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDeleteIndexByIDFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

func (f *StoreDeleteIndexByIDFunc) nextHook() func(context.Context, int) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteIndexByIDFunc) appendCall(r0 StoreDeleteIndexByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteIndexByIDFuncCall objects
// describing the invocations of this function.
func (f *StoreDeleteIndexByIDFunc) History() []StoreDeleteIndexByIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteIndexByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteIndexByIDFuncCall is an object that describes an invocation of
// method DeleteIndexByID on an instance of MockStore.
type StoreDeleteIndexByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteIndexByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteIndexByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreDeleteOldestDumpFunc describes the behavior when the
// DeleteOldestDump method of the parent MockStore instance is invoked.
type StoreDeleteOldestDumpFunc struct {
	defaultHook func(context.Context) (int, bool, error)
	hooks       []func(context.Context) (int, bool, error)
	history     []StoreDeleteOldestDumpFuncCall
	mutex       sync.Mutex
}

// DeleteOldestDump delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) DeleteOldestDump(v0 context.Context) (int, bool, error) {
	r0, r1, r2 := m.DeleteOldestDumpFunc.nextHook()(v0)
	m.DeleteOldestDumpFunc.appendCall(StoreDeleteOldestDumpFuncCall{v0, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the DeleteOldestDump
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreDeleteOldestDumpFunc) SetDefaultHook(hook func(context.Context) (int, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteOldestDump method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreDeleteOldestDumpFunc) PushHook(hook func(context.Context) (int, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDeleteOldestDumpFunc) SetDefaultReturn(r0 int, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context) (int, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDeleteOldestDumpFunc) PushReturn(r0 int, r1 bool, r2 error) {
	f.PushHook(func(context.Context) (int, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreDeleteOldestDumpFunc) nextHook() func(context.Context) (int, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteOldestDumpFunc) appendCall(r0 StoreDeleteOldestDumpFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteOldestDumpFuncCall objects
// describing the invocations of this function.
func (f *StoreDeleteOldestDumpFunc) History() []StoreDeleteOldestDumpFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteOldestDumpFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteOldestDumpFuncCall is an object that describes an invocation
// of method DeleteOldestDump on an instance of MockStore.
type StoreDeleteOldestDumpFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteOldestDumpFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteOldestDumpFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreDeleteOverlappingDumpsFunc describes the behavior when the
// DeleteOverlappingDumps method of the parent MockStore instance is
// invoked.
type StoreDeleteOverlappingDumpsFunc struct {
	defaultHook func(context.Context, int, string, string, string) error
	hooks       []func(context.Context, int, string, string, string) error
	history     []StoreDeleteOverlappingDumpsFuncCall
	mutex       sync.Mutex
}

// DeleteOverlappingDumps delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) DeleteOverlappingDumps(v0 context.Context, v1 int, v2 string, v3 string, v4 string) error {
	r0 := m.DeleteOverlappingDumpsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.DeleteOverlappingDumpsFunc.appendCall(StoreDeleteOverlappingDumpsFuncCall{v0, v1, v2, v3, v4, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// DeleteOverlappingDumps method of the parent MockStore instance is invoked
// and the hook queue is empty.
func (f *StoreDeleteOverlappingDumpsFunc) SetDefaultHook(hook func(context.Context, int, string, string, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteOverlappingDumps method of the parent MockStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreDeleteOverlappingDumpsFunc) PushHook(hook func(context.Context, int, string, string, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDeleteOverlappingDumpsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, string) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDeleteOverlappingDumpsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string, string, string) error {
		return r0
	})
}

func (f *StoreDeleteOverlappingDumpsFunc) nextHook() func(context.Context, int, string, string, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteOverlappingDumpsFunc) appendCall(r0 StoreDeleteOverlappingDumpsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteOverlappingDumpsFuncCall objects
// describing the invocations of this function.
func (f *StoreDeleteOverlappingDumpsFunc) History() []StoreDeleteOverlappingDumpsFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteOverlappingDumpsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteOverlappingDumpsFuncCall is an object that describes an
// invocation of method DeleteOverlappingDumps on an instance of MockStore.
type StoreDeleteOverlappingDumpsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteOverlappingDumpsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteOverlappingDumpsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreDeleteUploadByIDFunc describes the behavior when the
// DeleteUploadByID method of the parent MockStore instance is invoked.
type StoreDeleteUploadByIDFunc struct {
	defaultHook func(context.Context, int, store.GetTipCommitFunc) (bool, error)
	hooks       []func(context.Context, int, store.GetTipCommitFunc) (bool, error)
	history     []StoreDeleteUploadByIDFuncCall
	mutex       sync.Mutex
}

// DeleteUploadByID delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) DeleteUploadByID(v0 context.Context, v1 int, v2 store.GetTipCommitFunc) (bool, error) {
	r0, r1 := m.DeleteUploadByIDFunc.nextHook()(v0, v1, v2)
	m.DeleteUploadByIDFunc.appendCall(StoreDeleteUploadByIDFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DeleteUploadByID
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreDeleteUploadByIDFunc) SetDefaultHook(hook func(context.Context, int, store.GetTipCommitFunc) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteUploadByID method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreDeleteUploadByIDFunc) PushHook(hook func(context.Context, int, store.GetTipCommitFunc) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDeleteUploadByIDFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, store.GetTipCommitFunc) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDeleteUploadByIDFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, store.GetTipCommitFunc) (bool, error) {
		return r0, r1
	})
}

func (f *StoreDeleteUploadByIDFunc) nextHook() func(context.Context, int, store.GetTipCommitFunc) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteUploadByIDFunc) appendCall(r0 StoreDeleteUploadByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteUploadByIDFuncCall objects
// describing the invocations of this function.
func (f *StoreDeleteUploadByIDFunc) History() []StoreDeleteUploadByIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteUploadByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteUploadByIDFuncCall is an object that describes an invocation
// of method DeleteUploadByID on an instance of MockStore.
type StoreDeleteUploadByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 store.GetTipCommitFunc
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteUploadByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteUploadByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreDequeueFunc describes the behavior when the Dequeue method of the
// parent MockStore instance is invoked.
type StoreDequeueFunc struct {
	defaultHook func(context.Context) (store.Upload, store.Store, bool, error)
	hooks       []func(context.Context) (store.Upload, store.Store, bool, error)
	history     []StoreDequeueFuncCall
	mutex       sync.Mutex
}

// Dequeue delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Dequeue(v0 context.Context) (store.Upload, store.Store, bool, error) {
	r0, r1, r2, r3 := m.DequeueFunc.nextHook()(v0)
	m.DequeueFunc.appendCall(StoreDequeueFuncCall{v0, r0, r1, r2, r3})
	return r0, r1, r2, r3
}

// SetDefaultHook sets function that is called when the Dequeue method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreDequeueFunc) SetDefaultHook(hook func(context.Context) (store.Upload, store.Store, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Dequeue method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreDequeueFunc) PushHook(hook func(context.Context) (store.Upload, store.Store, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDequeueFunc) SetDefaultReturn(r0 store.Upload, r1 store.Store, r2 bool, r3 error) {
	f.SetDefaultHook(func(context.Context) (store.Upload, store.Store, bool, error) {
		return r0, r1, r2, r3
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDequeueFunc) PushReturn(r0 store.Upload, r1 store.Store, r2 bool, r3 error) {
	f.PushHook(func(context.Context) (store.Upload, store.Store, bool, error) {
		return r0, r1, r2, r3
	})
}

func (f *StoreDequeueFunc) nextHook() func(context.Context) (store.Upload, store.Store, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDequeueFunc) appendCall(r0 StoreDequeueFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDequeueFuncCall objects describing the
// invocations of this function.
func (f *StoreDequeueFunc) History() []StoreDequeueFuncCall {
	f.mutex.Lock()
	history := make([]StoreDequeueFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDequeueFuncCall is an object that describes an invocation of method
// Dequeue on an instance of MockStore.
type StoreDequeueFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 store.Store
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 bool
	// Result3 is the value of the 4th result returned from this method
	// invocation.
	Result3 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDequeueFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDequeueFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2, c.Result3}
}

// StoreDequeueIndexFunc describes the behavior when the DequeueIndex method
// of the parent MockStore instance is invoked.
type StoreDequeueIndexFunc struct {
	defaultHook func(context.Context) (store.Index, store.Store, bool, error)
	hooks       []func(context.Context) (store.Index, store.Store, bool, error)
	history     []StoreDequeueIndexFuncCall
	mutex       sync.Mutex
}

// DequeueIndex delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) DequeueIndex(v0 context.Context) (store.Index, store.Store, bool, error) {
	r0, r1, r2, r3 := m.DequeueIndexFunc.nextHook()(v0)
	m.DequeueIndexFunc.appendCall(StoreDequeueIndexFuncCall{v0, r0, r1, r2, r3})
	return r0, r1, r2, r3
}

// SetDefaultHook sets function that is called when the DequeueIndex method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreDequeueIndexFunc) SetDefaultHook(hook func(context.Context) (store.Index, store.Store, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DequeueIndex method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreDequeueIndexFunc) PushHook(hook func(context.Context) (store.Index, store.Store, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDequeueIndexFunc) SetDefaultReturn(r0 store.Index, r1 store.Store, r2 bool, r3 error) {
	f.SetDefaultHook(func(context.Context) (store.Index, store.Store, bool, error) {
		return r0, r1, r2, r3
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDequeueIndexFunc) PushReturn(r0 store.Index, r1 store.Store, r2 bool, r3 error) {
	f.PushHook(func(context.Context) (store.Index, store.Store, bool, error) {
		return r0, r1, r2, r3
	})
}

func (f *StoreDequeueIndexFunc) nextHook() func(context.Context) (store.Index, store.Store, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDequeueIndexFunc) appendCall(r0 StoreDequeueIndexFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDequeueIndexFuncCall objects
// describing the invocations of this function.
func (f *StoreDequeueIndexFunc) History() []StoreDequeueIndexFuncCall {
	f.mutex.Lock()
	history := make([]StoreDequeueIndexFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDequeueIndexFuncCall is an object that describes an invocation of
// method DequeueIndex on an instance of MockStore.
type StoreDequeueIndexFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 store.Store
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 bool
	// Result3 is the value of the 4th result returned from this method
	// invocation.
	Result3 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDequeueIndexFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDequeueIndexFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2, c.Result3}
}

// StoreDoneFunc describes the behavior when the Done method of the parent
// MockStore instance is invoked.
type StoreDoneFunc struct {
	defaultHook func(error) error
	hooks       []func(error) error
	history     []StoreDoneFuncCall
	mutex       sync.Mutex
}

// Done delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Done(v0 error) error {
	r0 := m.DoneFunc.nextHook()(v0)
	m.DoneFunc.appendCall(StoreDoneFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Done method of the
// parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreDoneFunc) SetDefaultHook(hook func(error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Done method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreDoneFunc) PushHook(hook func(error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDoneFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(error) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDoneFunc) PushReturn(r0 error) {
	f.PushHook(func(error) error {
		return r0
	})
}

func (f *StoreDoneFunc) nextHook() func(error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDoneFunc) appendCall(r0 StoreDoneFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDoneFuncCall objects describing the
// invocations of this function.
func (f *StoreDoneFunc) History() []StoreDoneFuncCall {
	f.mutex.Lock()
	history := make([]StoreDoneFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDoneFuncCall is an object that describes an invocation of method
// Done on an instance of MockStore.
type StoreDoneFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDoneFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDoneFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreFindClosestDumpsFunc describes the behavior when the
// FindClosestDumps method of the parent MockStore instance is invoked.
type StoreFindClosestDumpsFunc struct {
	defaultHook func(context.Context, int, string, string, bool, string) ([]store.Dump, error)
	hooks       []func(context.Context, int, string, string, bool, string) ([]store.Dump, error)
	history     []StoreFindClosestDumpsFuncCall
	mutex       sync.Mutex
}

// FindClosestDumps delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) FindClosestDumps(v0 context.Context, v1 int, v2 string, v3 string, v4 bool, v5 string) ([]store.Dump, error) {
	r0, r1 := m.FindClosestDumpsFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.FindClosestDumpsFunc.appendCall(StoreFindClosestDumpsFuncCall{v0, v1, v2, v3, v4, v5, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the FindClosestDumps
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreFindClosestDumpsFunc) SetDefaultHook(hook func(context.Context, int, string, string, bool, string) ([]store.Dump, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// FindClosestDumps method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreFindClosestDumpsFunc) PushHook(hook func(context.Context, int, string, string, bool, string) ([]store.Dump, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreFindClosestDumpsFunc) SetDefaultReturn(r0 []store.Dump, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, bool, string) ([]store.Dump, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreFindClosestDumpsFunc) PushReturn(r0 []store.Dump, r1 error) {
	f.PushHook(func(context.Context, int, string, string, bool, string) ([]store.Dump, error) {
		return r0, r1
	})
}

func (f *StoreFindClosestDumpsFunc) nextHook() func(context.Context, int, string, string, bool, string) ([]store.Dump, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreFindClosestDumpsFunc) appendCall(r0 StoreFindClosestDumpsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreFindClosestDumpsFuncCall objects
// describing the invocations of this function.
func (f *StoreFindClosestDumpsFunc) History() []StoreFindClosestDumpsFuncCall {
	f.mutex.Lock()
	history := make([]StoreFindClosestDumpsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreFindClosestDumpsFuncCall is an object that describes an invocation
// of method FindClosestDumps on an instance of MockStore.
type StoreFindClosestDumpsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 bool
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []store.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreFindClosestDumpsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreFindClosestDumpsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetDumpByIDFunc describes the behavior when the GetDumpByID method
// of the parent MockStore instance is invoked.
type StoreGetDumpByIDFunc struct {
	defaultHook func(context.Context, int) (store.Dump, bool, error)
	hooks       []func(context.Context, int) (store.Dump, bool, error)
	history     []StoreGetDumpByIDFuncCall
	mutex       sync.Mutex
}

// GetDumpByID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetDumpByID(v0 context.Context, v1 int) (store.Dump, bool, error) {
	r0, r1, r2 := m.GetDumpByIDFunc.nextHook()(v0, v1)
	m.GetDumpByIDFunc.appendCall(StoreGetDumpByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetDumpByID method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetDumpByIDFunc) SetDefaultHook(hook func(context.Context, int) (store.Dump, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetDumpByID method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetDumpByIDFunc) PushHook(hook func(context.Context, int) (store.Dump, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreGetDumpByIDFunc) SetDefaultReturn(r0 store.Dump, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (store.Dump, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreGetDumpByIDFunc) PushReturn(r0 store.Dump, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (store.Dump, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetDumpByIDFunc) nextHook() func(context.Context, int) (store.Dump, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetDumpByIDFunc) appendCall(r0 StoreGetDumpByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetDumpByIDFuncCall objects describing
// the invocations of this function.
func (f *StoreGetDumpByIDFunc) History() []StoreGetDumpByIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetDumpByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetDumpByIDFuncCall is an object that describes an invocation of
// method GetDumpByID on an instance of MockStore.
type StoreGetDumpByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetDumpByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetDumpByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetIndexByIDFunc describes the behavior when the GetIndexByID method
// of the parent MockStore instance is invoked.
type StoreGetIndexByIDFunc struct {
	defaultHook func(context.Context, int) (store.Index, bool, error)
	hooks       []func(context.Context, int) (store.Index, bool, error)
	history     []StoreGetIndexByIDFuncCall
	mutex       sync.Mutex
}

// GetIndexByID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetIndexByID(v0 context.Context, v1 int) (store.Index, bool, error) {
	r0, r1, r2 := m.GetIndexByIDFunc.nextHook()(v0, v1)
	m.GetIndexByIDFunc.appendCall(StoreGetIndexByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetIndexByID method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetIndexByIDFunc) SetDefaultHook(hook func(context.Context, int) (store.Index, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexByID method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetIndexByIDFunc) PushHook(hook func(context.Context, int) (store.Index, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreGetIndexByIDFunc) SetDefaultReturn(r0 store.Index, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (store.Index, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreGetIndexByIDFunc) PushReturn(r0 store.Index, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (store.Index, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetIndexByIDFunc) nextHook() func(context.Context, int) (store.Index, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetIndexByIDFunc) appendCall(r0 StoreGetIndexByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetIndexByIDFuncCall objects
// describing the invocations of this function.
func (f *StoreGetIndexByIDFunc) History() []StoreGetIndexByIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetIndexByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetIndexByIDFuncCall is an object that describes an invocation of
// method GetIndexByID on an instance of MockStore.
type StoreGetIndexByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetIndexByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetIndexByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetIndexesFunc describes the behavior when the GetIndexes method of
// the parent MockStore instance is invoked.
type StoreGetIndexesFunc struct {
	defaultHook func(context.Context, store.GetIndexesOptions) ([]store.Index, int, error)
	hooks       []func(context.Context, store.GetIndexesOptions) ([]store.Index, int, error)
	history     []StoreGetIndexesFuncCall
	mutex       sync.Mutex
}

// GetIndexes delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetIndexes(v0 context.Context, v1 store.GetIndexesOptions) ([]store.Index, int, error) {
	r0, r1, r2 := m.GetIndexesFunc.nextHook()(v0, v1)
	m.GetIndexesFunc.appendCall(StoreGetIndexesFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetIndexes method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetIndexesFunc) SetDefaultHook(hook func(context.Context, store.GetIndexesOptions) ([]store.Index, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexes method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetIndexesFunc) PushHook(hook func(context.Context, store.GetIndexesOptions) ([]store.Index, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreGetIndexesFunc) SetDefaultReturn(r0 []store.Index, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, store.GetIndexesOptions) ([]store.Index, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreGetIndexesFunc) PushReturn(r0 []store.Index, r1 int, r2 error) {
	f.PushHook(func(context.Context, store.GetIndexesOptions) ([]store.Index, int, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetIndexesFunc) nextHook() func(context.Context, store.GetIndexesOptions) ([]store.Index, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetIndexesFunc) appendCall(r0 StoreGetIndexesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetIndexesFuncCall objects describing
// the invocations of this function.
func (f *StoreGetIndexesFunc) History() []StoreGetIndexesFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetIndexesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetIndexesFuncCall is an object that describes an invocation of
// method GetIndexes on an instance of MockStore.
type StoreGetIndexesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 store.GetIndexesOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []store.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetIndexesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetIndexesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetPackageFunc describes the behavior when the GetPackage method of
// the parent MockStore instance is invoked.
type StoreGetPackageFunc struct {
	defaultHook func(context.Context, string, string, string) (store.Dump, bool, error)
	hooks       []func(context.Context, string, string, string) (store.Dump, bool, error)
	history     []StoreGetPackageFuncCall
	mutex       sync.Mutex
}

// GetPackage delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetPackage(v0 context.Context, v1 string, v2 string, v3 string) (store.Dump, bool, error) {
	r0, r1, r2 := m.GetPackageFunc.nextHook()(v0, v1, v2, v3)
	m.GetPackageFunc.appendCall(StoreGetPackageFuncCall{v0, v1, v2, v3, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetPackage method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetPackageFunc) SetDefaultHook(hook func(context.Context, string, string, string) (store.Dump, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetPackage method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetPackageFunc) PushHook(hook func(context.Context, string, string, string) (store.Dump, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreGetPackageFunc) SetDefaultReturn(r0 store.Dump, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, string, string, string) (store.Dump, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreGetPackageFunc) PushReturn(r0 store.Dump, r1 bool, r2 error) {
	f.PushHook(func(context.Context, string, string, string) (store.Dump, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetPackageFunc) nextHook() func(context.Context, string, string, string) (store.Dump, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetPackageFunc) appendCall(r0 StoreGetPackageFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetPackageFuncCall objects describing
// the invocations of this function.
func (f *StoreGetPackageFunc) History() []StoreGetPackageFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetPackageFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetPackageFuncCall is an object that describes an invocation of
// method GetPackage on an instance of MockStore.
type StoreGetPackageFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetPackageFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetPackageFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetStatesFunc describes the behavior when the GetStates method of
// the parent MockStore instance is invoked.
type StoreGetStatesFunc struct {
	defaultHook func(context.Context, []int) (map[int]string, error)
	hooks       []func(context.Context, []int) (map[int]string, error)
	history     []StoreGetStatesFuncCall
	mutex       sync.Mutex
}

// GetStates delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) GetStates(v0 context.Context, v1 []int) (map[int]string, error) {
	r0, r1 := m.GetStatesFunc.nextHook()(v0, v1)
	m.GetStatesFunc.appendCall(StoreGetStatesFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetStates method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetStatesFunc) SetDefaultHook(hook func(context.Context, []int) (map[int]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetStates method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreGetStatesFunc) PushHook(hook func(context.Context, []int) (map[int]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreGetStatesFunc) SetDefaultReturn(r0 map[int]string, r1 error) {
	f.SetDefaultHook(func(context.Context, []int) (map[int]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreGetStatesFunc) PushReturn(r0 map[int]string, r1 error) {
	f.PushHook(func(context.Context, []int) (map[int]string, error) {
		return r0, r1
	})
}

func (f *StoreGetStatesFunc) nextHook() func(context.Context, []int) (map[int]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetStatesFunc) appendCall(r0 StoreGetStatesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetStatesFuncCall objects describing
// the invocations of this function.
func (f *StoreGetStatesFunc) History() []StoreGetStatesFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetStatesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetStatesFuncCall is an object that describes an invocation of
// method GetStates on an instance of MockStore.
type StoreGetStatesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[int]string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetStatesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetStatesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetUploadByIDFunc describes the behavior when the GetUploadByID
// method of the parent MockStore instance is invoked.
type StoreGetUploadByIDFunc struct {
	defaultHook func(context.Context, int) (store.Upload, bool, error)
	hooks       []func(context.Context, int) (store.Upload, bool, error)
	history     []StoreGetUploadByIDFuncCall
	mutex       sync.Mutex
}

// GetUploadByID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetUploadByID(v0 context.Context, v1 int) (store.Upload, bool, error) {
	r0, r1, r2 := m.GetUploadByIDFunc.nextHook()(v0, v1)
	m.GetUploadByIDFunc.appendCall(StoreGetUploadByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetUploadByID method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetUploadByIDFunc) SetDefaultHook(hook func(context.Context, int) (store.Upload, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadByID method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetUploadByIDFunc) PushHook(hook func(context.Context, int) (store.Upload, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreGetUploadByIDFunc) SetDefaultReturn(r0 store.Upload, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (store.Upload, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreGetUploadByIDFunc) PushReturn(r0 store.Upload, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (store.Upload, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetUploadByIDFunc) nextHook() func(context.Context, int) (store.Upload, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetUploadByIDFunc) appendCall(r0 StoreGetUploadByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetUploadByIDFuncCall objects
// describing the invocations of this function.
func (f *StoreGetUploadByIDFunc) History() []StoreGetUploadByIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetUploadByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetUploadByIDFuncCall is an object that describes an invocation of
// method GetUploadByID on an instance of MockStore.
type StoreGetUploadByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetUploadByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetUploadByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetUploadsFunc describes the behavior when the GetUploads method of
// the parent MockStore instance is invoked.
type StoreGetUploadsFunc struct {
	defaultHook func(context.Context, store.GetUploadsOptions) ([]store.Upload, int, error)
	hooks       []func(context.Context, store.GetUploadsOptions) ([]store.Upload, int, error)
	history     []StoreGetUploadsFuncCall
	mutex       sync.Mutex
}

// GetUploads delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetUploads(v0 context.Context, v1 store.GetUploadsOptions) ([]store.Upload, int, error) {
	r0, r1, r2 := m.GetUploadsFunc.nextHook()(v0, v1)
	m.GetUploadsFunc.appendCall(StoreGetUploadsFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetUploads method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetUploadsFunc) SetDefaultHook(hook func(context.Context, store.GetUploadsOptions) ([]store.Upload, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploads method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetUploadsFunc) PushHook(hook func(context.Context, store.GetUploadsOptions) ([]store.Upload, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreGetUploadsFunc) SetDefaultReturn(r0 []store.Upload, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, store.GetUploadsOptions) ([]store.Upload, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreGetUploadsFunc) PushReturn(r0 []store.Upload, r1 int, r2 error) {
	f.PushHook(func(context.Context, store.GetUploadsOptions) ([]store.Upload, int, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetUploadsFunc) nextHook() func(context.Context, store.GetUploadsOptions) ([]store.Upload, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetUploadsFunc) appendCall(r0 StoreGetUploadsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetUploadsFuncCall objects describing
// the invocations of this function.
func (f *StoreGetUploadsFunc) History() []StoreGetUploadsFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetUploadsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetUploadsFuncCall is an object that describes an invocation of
// method GetUploads on an instance of MockStore.
type StoreGetUploadsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 store.GetUploadsOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []store.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetUploadsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetUploadsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreHasCommitFunc describes the behavior when the HasCommit method of
// the parent MockStore instance is invoked.
type StoreHasCommitFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []StoreHasCommitFuncCall
	mutex       sync.Mutex
}

// HasCommit delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) HasCommit(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.HasCommitFunc.nextHook()(v0, v1, v2)
	m.HasCommitFunc.appendCall(StoreHasCommitFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the HasCommit method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreHasCommitFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// HasCommit method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreHasCommitFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreHasCommitFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreHasCommitFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *StoreHasCommitFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreHasCommitFunc) appendCall(r0 StoreHasCommitFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreHasCommitFuncCall objects describing
// the invocations of this function.
func (f *StoreHasCommitFunc) History() []StoreHasCommitFuncCall {
	f.mutex.Lock()
	history := make([]StoreHasCommitFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreHasCommitFuncCall is an object that describes an invocation of
// method HasCommit on an instance of MockStore.
type StoreHasCommitFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreHasCommitFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreHasCommitFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreIndexQueueSizeFunc describes the behavior when the IndexQueueSize
// method of the parent MockStore instance is invoked.
type StoreIndexQueueSizeFunc struct {
	defaultHook func(context.Context) (int, error)
	hooks       []func(context.Context) (int, error)
	history     []StoreIndexQueueSizeFuncCall
	mutex       sync.Mutex
}

// IndexQueueSize delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) IndexQueueSize(v0 context.Context) (int, error) {
	r0, r1 := m.IndexQueueSizeFunc.nextHook()(v0)
	m.IndexQueueSizeFunc.appendCall(StoreIndexQueueSizeFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the IndexQueueSize
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreIndexQueueSizeFunc) SetDefaultHook(hook func(context.Context) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// IndexQueueSize method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreIndexQueueSizeFunc) PushHook(hook func(context.Context) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreIndexQueueSizeFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreIndexQueueSizeFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

func (f *StoreIndexQueueSizeFunc) nextHook() func(context.Context) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreIndexQueueSizeFunc) appendCall(r0 StoreIndexQueueSizeFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreIndexQueueSizeFuncCall objects
// describing the invocations of this function.
func (f *StoreIndexQueueSizeFunc) History() []StoreIndexQueueSizeFuncCall {
	f.mutex.Lock()
	history := make([]StoreIndexQueueSizeFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreIndexQueueSizeFuncCall is an object that describes an invocation of
// method IndexQueueSize on an instance of MockStore.
type StoreIndexQueueSizeFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreIndexQueueSizeFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreIndexQueueSizeFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreIndexableRepositoriesFunc describes the behavior when the
// IndexableRepositories method of the parent MockStore instance is invoked.
type StoreIndexableRepositoriesFunc struct {
	defaultHook func(context.Context, store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error)
	hooks       []func(context.Context, store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error)
	history     []StoreIndexableRepositoriesFuncCall
	mutex       sync.Mutex
}

// IndexableRepositories delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) IndexableRepositories(v0 context.Context, v1 store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error) {
	r0, r1 := m.IndexableRepositoriesFunc.nextHook()(v0, v1)
	m.IndexableRepositoriesFunc.appendCall(StoreIndexableRepositoriesFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// IndexableRepositories method of the parent MockStore instance is invoked
// and the hook queue is empty.
func (f *StoreIndexableRepositoriesFunc) SetDefaultHook(hook func(context.Context, store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// IndexableRepositories method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreIndexableRepositoriesFunc) PushHook(hook func(context.Context, store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreIndexableRepositoriesFunc) SetDefaultReturn(r0 []store.IndexableRepository, r1 error) {
	f.SetDefaultHook(func(context.Context, store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreIndexableRepositoriesFunc) PushReturn(r0 []store.IndexableRepository, r1 error) {
	f.PushHook(func(context.Context, store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error) {
		return r0, r1
	})
}

func (f *StoreIndexableRepositoriesFunc) nextHook() func(context.Context, store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreIndexableRepositoriesFunc) appendCall(r0 StoreIndexableRepositoriesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreIndexableRepositoriesFuncCall objects
// describing the invocations of this function.
func (f *StoreIndexableRepositoriesFunc) History() []StoreIndexableRepositoriesFuncCall {
	f.mutex.Lock()
	history := make([]StoreIndexableRepositoriesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreIndexableRepositoriesFuncCall is an object that describes an
// invocation of method IndexableRepositories on an instance of MockStore.
type StoreIndexableRepositoriesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 store.IndexableRepositoryQueryOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []store.IndexableRepository
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreIndexableRepositoriesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreIndexableRepositoriesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreInsertIndexFunc describes the behavior when the InsertIndex method
// of the parent MockStore instance is invoked.
type StoreInsertIndexFunc struct {
	defaultHook func(context.Context, store.Index) (int, error)
	hooks       []func(context.Context, store.Index) (int, error)
	history     []StoreInsertIndexFuncCall
	mutex       sync.Mutex
}

// InsertIndex delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) InsertIndex(v0 context.Context, v1 store.Index) (int, error) {
	r0, r1 := m.InsertIndexFunc.nextHook()(v0, v1)
	m.InsertIndexFunc.appendCall(StoreInsertIndexFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the InsertIndex method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreInsertIndexFunc) SetDefaultHook(hook func(context.Context, store.Index) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertIndex method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreInsertIndexFunc) PushHook(hook func(context.Context, store.Index) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreInsertIndexFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, store.Index) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreInsertIndexFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, store.Index) (int, error) {
		return r0, r1
	})
}

func (f *StoreInsertIndexFunc) nextHook() func(context.Context, store.Index) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreInsertIndexFunc) appendCall(r0 StoreInsertIndexFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreInsertIndexFuncCall objects describing
// the invocations of this function.
func (f *StoreInsertIndexFunc) History() []StoreInsertIndexFuncCall {
	f.mutex.Lock()
	history := make([]StoreInsertIndexFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreInsertIndexFuncCall is an object that describes an invocation of
// method InsertIndex on an instance of MockStore.
type StoreInsertIndexFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 store.Index
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreInsertIndexFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreInsertIndexFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreInsertUploadFunc describes the behavior when the InsertUpload method
// of the parent MockStore instance is invoked.
type StoreInsertUploadFunc struct {
	defaultHook func(context.Context, store.Upload) (int, error)
	hooks       []func(context.Context, store.Upload) (int, error)
	history     []StoreInsertUploadFuncCall
	mutex       sync.Mutex
}

// InsertUpload delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) InsertUpload(v0 context.Context, v1 store.Upload) (int, error) {
	r0, r1 := m.InsertUploadFunc.nextHook()(v0, v1)
	m.InsertUploadFunc.appendCall(StoreInsertUploadFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the InsertUpload method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreInsertUploadFunc) SetDefaultHook(hook func(context.Context, store.Upload) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertUpload method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreInsertUploadFunc) PushHook(hook func(context.Context, store.Upload) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreInsertUploadFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, store.Upload) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreInsertUploadFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, store.Upload) (int, error) {
		return r0, r1
	})
}

func (f *StoreInsertUploadFunc) nextHook() func(context.Context, store.Upload) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreInsertUploadFunc) appendCall(r0 StoreInsertUploadFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreInsertUploadFuncCall objects
// describing the invocations of this function.
func (f *StoreInsertUploadFunc) History() []StoreInsertUploadFuncCall {
	f.mutex.Lock()
	history := make([]StoreInsertUploadFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreInsertUploadFuncCall is an object that describes an invocation of
// method InsertUpload on an instance of MockStore.
type StoreInsertUploadFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 store.Upload
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreInsertUploadFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreInsertUploadFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreIsQueuedFunc describes the behavior when the IsQueued method of the
// parent MockStore instance is invoked.
type StoreIsQueuedFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []StoreIsQueuedFuncCall
	mutex       sync.Mutex
}

// IsQueued delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) IsQueued(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.IsQueuedFunc.nextHook()(v0, v1, v2)
	m.IsQueuedFunc.appendCall(StoreIsQueuedFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the IsQueued method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreIsQueuedFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// IsQueued method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreIsQueuedFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreIsQueuedFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreIsQueuedFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *StoreIsQueuedFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreIsQueuedFunc) appendCall(r0 StoreIsQueuedFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreIsQueuedFuncCall objects describing
// the invocations of this function.
func (f *StoreIsQueuedFunc) History() []StoreIsQueuedFuncCall {
	f.mutex.Lock()
	history := make([]StoreIsQueuedFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreIsQueuedFuncCall is an object that describes an invocation of method
// IsQueued on an instance of MockStore.
type StoreIsQueuedFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreIsQueuedFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreIsQueuedFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreMarkCompleteFunc describes the behavior when the MarkComplete method
// of the parent MockStore instance is invoked.
type StoreMarkCompleteFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []StoreMarkCompleteFuncCall
	mutex       sync.Mutex
}

// MarkComplete delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) MarkComplete(v0 context.Context, v1 int) error {
	r0 := m.MarkCompleteFunc.nextHook()(v0, v1)
	m.MarkCompleteFunc.appendCall(StoreMarkCompleteFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the MarkComplete method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreMarkCompleteFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkComplete method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreMarkCompleteFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreMarkCompleteFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreMarkCompleteFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *StoreMarkCompleteFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreMarkCompleteFunc) appendCall(r0 StoreMarkCompleteFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreMarkCompleteFuncCall objects
// describing the invocations of this function.
func (f *StoreMarkCompleteFunc) History() []StoreMarkCompleteFuncCall {
	f.mutex.Lock()
	history := make([]StoreMarkCompleteFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreMarkCompleteFuncCall is an object that describes an invocation of
// method MarkComplete on an instance of MockStore.
type StoreMarkCompleteFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreMarkCompleteFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreMarkCompleteFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreMarkErroredFunc describes the behavior when the MarkErrored method
// of the parent MockStore instance is invoked.
type StoreMarkErroredFunc struct {
	defaultHook func(context.Context, int, string) error
	hooks       []func(context.Context, int, string) error
	history     []StoreMarkErroredFuncCall
	mutex       sync.Mutex
}

// MarkErrored delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) MarkErrored(v0 context.Context, v1 int, v2 string) error {
	r0 := m.MarkErroredFunc.nextHook()(v0, v1, v2)
	m.MarkErroredFunc.appendCall(StoreMarkErroredFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the MarkErrored method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreMarkErroredFunc) SetDefaultHook(hook func(context.Context, int, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkErrored method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreMarkErroredFunc) PushHook(hook func(context.Context, int, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreMarkErroredFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreMarkErroredFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string) error {
		return r0
	})
}

func (f *StoreMarkErroredFunc) nextHook() func(context.Context, int, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreMarkErroredFunc) appendCall(r0 StoreMarkErroredFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreMarkErroredFuncCall objects describing
// the invocations of this function.
func (f *StoreMarkErroredFunc) History() []StoreMarkErroredFuncCall {
	f.mutex.Lock()
	history := make([]StoreMarkErroredFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreMarkErroredFuncCall is an object that describes an invocation of
// method MarkErrored on an instance of MockStore.
type StoreMarkErroredFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreMarkErroredFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreMarkErroredFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreMarkIndexCompleteFunc describes the behavior when the
// MarkIndexComplete method of the parent MockStore instance is invoked.
type StoreMarkIndexCompleteFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []StoreMarkIndexCompleteFuncCall
	mutex       sync.Mutex
}

// MarkIndexComplete delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) MarkIndexComplete(v0 context.Context, v1 int) error {
	r0 := m.MarkIndexCompleteFunc.nextHook()(v0, v1)
	m.MarkIndexCompleteFunc.appendCall(StoreMarkIndexCompleteFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the MarkIndexComplete
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreMarkIndexCompleteFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkIndexComplete method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreMarkIndexCompleteFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreMarkIndexCompleteFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreMarkIndexCompleteFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *StoreMarkIndexCompleteFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreMarkIndexCompleteFunc) appendCall(r0 StoreMarkIndexCompleteFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreMarkIndexCompleteFuncCall objects
// describing the invocations of this function.
func (f *StoreMarkIndexCompleteFunc) History() []StoreMarkIndexCompleteFuncCall {
	f.mutex.Lock()
	history := make([]StoreMarkIndexCompleteFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreMarkIndexCompleteFuncCall is an object that describes an invocation
// of method MarkIndexComplete on an instance of MockStore.
type StoreMarkIndexCompleteFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreMarkIndexCompleteFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreMarkIndexCompleteFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreMarkIndexErroredFunc describes the behavior when the
// MarkIndexErrored method of the parent MockStore instance is invoked.
type StoreMarkIndexErroredFunc struct {
	defaultHook func(context.Context, int, string) error
	hooks       []func(context.Context, int, string) error
	history     []StoreMarkIndexErroredFuncCall
	mutex       sync.Mutex
}

// MarkIndexErrored delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) MarkIndexErrored(v0 context.Context, v1 int, v2 string) error {
	r0 := m.MarkIndexErroredFunc.nextHook()(v0, v1, v2)
	m.MarkIndexErroredFunc.appendCall(StoreMarkIndexErroredFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the MarkIndexErrored
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreMarkIndexErroredFunc) SetDefaultHook(hook func(context.Context, int, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkIndexErrored method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreMarkIndexErroredFunc) PushHook(hook func(context.Context, int, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreMarkIndexErroredFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreMarkIndexErroredFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string) error {
		return r0
	})
}

func (f *StoreMarkIndexErroredFunc) nextHook() func(context.Context, int, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreMarkIndexErroredFunc) appendCall(r0 StoreMarkIndexErroredFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreMarkIndexErroredFuncCall objects
// describing the invocations of this function.
func (f *StoreMarkIndexErroredFunc) History() []StoreMarkIndexErroredFuncCall {
	f.mutex.Lock()
	history := make([]StoreMarkIndexErroredFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreMarkIndexErroredFuncCall is an object that describes an invocation
// of method MarkIndexErrored on an instance of MockStore.
type StoreMarkIndexErroredFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreMarkIndexErroredFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreMarkIndexErroredFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreMarkQueuedFunc describes the behavior when the MarkQueued method of
// the parent MockStore instance is invoked.
type StoreMarkQueuedFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []StoreMarkQueuedFuncCall
	mutex       sync.Mutex
}

// MarkQueued delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) MarkQueued(v0 context.Context, v1 int) error {
	r0 := m.MarkQueuedFunc.nextHook()(v0, v1)
	m.MarkQueuedFunc.appendCall(StoreMarkQueuedFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the MarkQueued method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreMarkQueuedFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkQueued method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreMarkQueuedFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreMarkQueuedFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreMarkQueuedFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *StoreMarkQueuedFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreMarkQueuedFunc) appendCall(r0 StoreMarkQueuedFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreMarkQueuedFuncCall objects describing
// the invocations of this function.
func (f *StoreMarkQueuedFunc) History() []StoreMarkQueuedFuncCall {
	f.mutex.Lock()
	history := make([]StoreMarkQueuedFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreMarkQueuedFuncCall is an object that describes an invocation of
// method MarkQueued on an instance of MockStore.
type StoreMarkQueuedFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreMarkQueuedFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreMarkQueuedFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StorePackageReferencePagerFunc describes the behavior when the
// PackageReferencePager method of the parent MockStore instance is invoked.
type StorePackageReferencePagerFunc struct {
	defaultHook func(context.Context, string, string, string, int, int) (int, store.ReferencePager, error)
	hooks       []func(context.Context, string, string, string, int, int) (int, store.ReferencePager, error)
	history     []StorePackageReferencePagerFuncCall
	mutex       sync.Mutex
}

// PackageReferencePager delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) PackageReferencePager(v0 context.Context, v1 string, v2 string, v3 string, v4 int, v5 int) (int, store.ReferencePager, error) {
	r0, r1, r2 := m.PackageReferencePagerFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.PackageReferencePagerFunc.appendCall(StorePackageReferencePagerFuncCall{v0, v1, v2, v3, v4, v5, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// PackageReferencePager method of the parent MockStore instance is invoked
// and the hook queue is empty.
func (f *StorePackageReferencePagerFunc) SetDefaultHook(hook func(context.Context, string, string, string, int, int) (int, store.ReferencePager, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// PackageReferencePager method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StorePackageReferencePagerFunc) PushHook(hook func(context.Context, string, string, string, int, int) (int, store.ReferencePager, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StorePackageReferencePagerFunc) SetDefaultReturn(r0 int, r1 store.ReferencePager, r2 error) {
	f.SetDefaultHook(func(context.Context, string, string, string, int, int) (int, store.ReferencePager, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StorePackageReferencePagerFunc) PushReturn(r0 int, r1 store.ReferencePager, r2 error) {
	f.PushHook(func(context.Context, string, string, string, int, int) (int, store.ReferencePager, error) {
		return r0, r1, r2
	})
}

func (f *StorePackageReferencePagerFunc) nextHook() func(context.Context, string, string, string, int, int) (int, store.ReferencePager, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StorePackageReferencePagerFunc) appendCall(r0 StorePackageReferencePagerFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StorePackageReferencePagerFuncCall objects
// describing the invocations of this function.
func (f *StorePackageReferencePagerFunc) History() []StorePackageReferencePagerFuncCall {
	f.mutex.Lock()
	history := make([]StorePackageReferencePagerFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StorePackageReferencePagerFuncCall is an object that describes an
// invocation of method PackageReferencePager on an instance of MockStore.
type StorePackageReferencePagerFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 store.ReferencePager
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StorePackageReferencePagerFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StorePackageReferencePagerFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreQueueSizeFunc describes the behavior when the QueueSize method of
// the parent MockStore instance is invoked.
type StoreQueueSizeFunc struct {
	defaultHook func(context.Context) (int, error)
	hooks       []func(context.Context) (int, error)
	history     []StoreQueueSizeFuncCall
	mutex       sync.Mutex
}

// QueueSize delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) QueueSize(v0 context.Context) (int, error) {
	r0, r1 := m.QueueSizeFunc.nextHook()(v0)
	m.QueueSizeFunc.appendCall(StoreQueueSizeFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the QueueSize method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreQueueSizeFunc) SetDefaultHook(hook func(context.Context) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// QueueSize method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreQueueSizeFunc) PushHook(hook func(context.Context) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreQueueSizeFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreQueueSizeFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

func (f *StoreQueueSizeFunc) nextHook() func(context.Context) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreQueueSizeFunc) appendCall(r0 StoreQueueSizeFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreQueueSizeFuncCall objects describing
// the invocations of this function.
func (f *StoreQueueSizeFunc) History() []StoreQueueSizeFuncCall {
	f.mutex.Lock()
	history := make([]StoreQueueSizeFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreQueueSizeFuncCall is an object that describes an invocation of
// method QueueSize on an instance of MockStore.
type StoreQueueSizeFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreQueueSizeFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreQueueSizeFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreRepoNameFunc describes the behavior when the RepoName method of the
// parent MockStore instance is invoked.
type StoreRepoNameFunc struct {
	defaultHook func(context.Context, int) (string, error)
	hooks       []func(context.Context, int) (string, error)
	history     []StoreRepoNameFuncCall
	mutex       sync.Mutex
}

// RepoName delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) RepoName(v0 context.Context, v1 int) (string, error) {
	r0, r1 := m.RepoNameFunc.nextHook()(v0, v1)
	m.RepoNameFunc.appendCall(StoreRepoNameFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepoName method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreRepoNameFunc) SetDefaultHook(hook func(context.Context, int) (string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoName method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreRepoNameFunc) PushHook(hook func(context.Context, int) (string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreRepoNameFunc) SetDefaultReturn(r0 string, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreRepoNameFunc) PushReturn(r0 string, r1 error) {
	f.PushHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

func (f *StoreRepoNameFunc) nextHook() func(context.Context, int) (string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreRepoNameFunc) appendCall(r0 StoreRepoNameFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreRepoNameFuncCall objects describing
// the invocations of this function.
func (f *StoreRepoNameFunc) History() []StoreRepoNameFuncCall {
	f.mutex.Lock()
	history := make([]StoreRepoNameFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreRepoNameFuncCall is an object that describes an invocation of method
// RepoName on an instance of MockStore.
type StoreRepoNameFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreRepoNameFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreRepoNameFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreRepoUsageStatisticsFunc describes the behavior when the
// RepoUsageStatistics method of the parent MockStore instance is invoked.
type StoreRepoUsageStatisticsFunc struct {
	defaultHook func(context.Context) ([]store.RepoUsageStatistics, error)
	hooks       []func(context.Context) ([]store.RepoUsageStatistics, error)
	history     []StoreRepoUsageStatisticsFuncCall
	mutex       sync.Mutex
}

// RepoUsageStatistics delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) RepoUsageStatistics(v0 context.Context) ([]store.RepoUsageStatistics, error) {
	r0, r1 := m.RepoUsageStatisticsFunc.nextHook()(v0)
	m.RepoUsageStatisticsFunc.appendCall(StoreRepoUsageStatisticsFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepoUsageStatistics
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreRepoUsageStatisticsFunc) SetDefaultHook(hook func(context.Context) ([]store.RepoUsageStatistics, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoUsageStatistics method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreRepoUsageStatisticsFunc) PushHook(hook func(context.Context) ([]store.RepoUsageStatistics, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreRepoUsageStatisticsFunc) SetDefaultReturn(r0 []store.RepoUsageStatistics, r1 error) {
	f.SetDefaultHook(func(context.Context) ([]store.RepoUsageStatistics, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreRepoUsageStatisticsFunc) PushReturn(r0 []store.RepoUsageStatistics, r1 error) {
	f.PushHook(func(context.Context) ([]store.RepoUsageStatistics, error) {
		return r0, r1
	})
}

func (f *StoreRepoUsageStatisticsFunc) nextHook() func(context.Context) ([]store.RepoUsageStatistics, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreRepoUsageStatisticsFunc) appendCall(r0 StoreRepoUsageStatisticsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreRepoUsageStatisticsFuncCall objects
// describing the invocations of this function.
func (f *StoreRepoUsageStatisticsFunc) History() []StoreRepoUsageStatisticsFuncCall {
	f.mutex.Lock()
	history := make([]StoreRepoUsageStatisticsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreRepoUsageStatisticsFuncCall is an object that describes an
// invocation of method RepoUsageStatistics on an instance of MockStore.
type StoreRepoUsageStatisticsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []store.RepoUsageStatistics
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreRepoUsageStatisticsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreRepoUsageStatisticsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreRequeueFunc describes the behavior when the Requeue method of the
// parent MockStore instance is invoked.
type StoreRequeueFunc struct {
	defaultHook func(context.Context, int, time.Time) error
	hooks       []func(context.Context, int, time.Time) error
	history     []StoreRequeueFuncCall
	mutex       sync.Mutex
}

// Requeue delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Requeue(v0 context.Context, v1 int, v2 time.Time) error {
	r0 := m.RequeueFunc.nextHook()(v0, v1, v2)
	m.RequeueFunc.appendCall(StoreRequeueFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Requeue method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreRequeueFunc) SetDefaultHook(hook func(context.Context, int, time.Time) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Requeue method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreRequeueFunc) PushHook(hook func(context.Context, int, time.Time) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreRequeueFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreRequeueFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

func (f *StoreRequeueFunc) nextHook() func(context.Context, int, time.Time) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreRequeueFunc) appendCall(r0 StoreRequeueFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreRequeueFuncCall objects describing the
// invocations of this function.
func (f *StoreRequeueFunc) History() []StoreRequeueFuncCall {
	f.mutex.Lock()
	history := make([]StoreRequeueFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreRequeueFuncCall is an object that describes an invocation of method
// Requeue on an instance of MockStore.
type StoreRequeueFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreRequeueFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreRequeueFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreRequeueIndexFunc describes the behavior when the RequeueIndex method
// of the parent MockStore instance is invoked.
type StoreRequeueIndexFunc struct {
	defaultHook func(context.Context, int, time.Time) error
	hooks       []func(context.Context, int, time.Time) error
	history     []StoreRequeueIndexFuncCall
	mutex       sync.Mutex
}

// RequeueIndex delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) RequeueIndex(v0 context.Context, v1 int, v2 time.Time) error {
	r0 := m.RequeueIndexFunc.nextHook()(v0, v1, v2)
	m.RequeueIndexFunc.appendCall(StoreRequeueIndexFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the RequeueIndex method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreRequeueIndexFunc) SetDefaultHook(hook func(context.Context, int, time.Time) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RequeueIndex method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreRequeueIndexFunc) PushHook(hook func(context.Context, int, time.Time) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreRequeueIndexFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreRequeueIndexFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

func (f *StoreRequeueIndexFunc) nextHook() func(context.Context, int, time.Time) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreRequeueIndexFunc) appendCall(r0 StoreRequeueIndexFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreRequeueIndexFuncCall objects
// describing the invocations of this function.
func (f *StoreRequeueIndexFunc) History() []StoreRequeueIndexFuncCall {
	f.mutex.Lock()
	history := make([]StoreRequeueIndexFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreRequeueIndexFuncCall is an object that describes an invocation of
// method RequeueIndex on an instance of MockStore.
type StoreRequeueIndexFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreRequeueIndexFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreRequeueIndexFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreResetStalledFunc describes the behavior when the ResetStalled method
// of the parent MockStore instance is invoked.
type StoreResetStalledFunc struct {
	defaultHook func(context.Context, time.Time) ([]int, []int, error)
	hooks       []func(context.Context, time.Time) ([]int, []int, error)
	history     []StoreResetStalledFuncCall
	mutex       sync.Mutex
}

// ResetStalled delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) ResetStalled(v0 context.Context, v1 time.Time) ([]int, []int, error) {
	r0, r1, r2 := m.ResetStalledFunc.nextHook()(v0, v1)
	m.ResetStalledFunc.appendCall(StoreResetStalledFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the ResetStalled method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreResetStalledFunc) SetDefaultHook(hook func(context.Context, time.Time) ([]int, []int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ResetStalled method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreResetStalledFunc) PushHook(hook func(context.Context, time.Time) ([]int, []int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreResetStalledFunc) SetDefaultReturn(r0 []int, r1 []int, r2 error) {
	f.SetDefaultHook(func(context.Context, time.Time) ([]int, []int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreResetStalledFunc) PushReturn(r0 []int, r1 []int, r2 error) {
	f.PushHook(func(context.Context, time.Time) ([]int, []int, error) {
		return r0, r1, r2
	})
}

func (f *StoreResetStalledFunc) nextHook() func(context.Context, time.Time) ([]int, []int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreResetStalledFunc) appendCall(r0 StoreResetStalledFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreResetStalledFuncCall objects
// describing the invocations of this function.
func (f *StoreResetStalledFunc) History() []StoreResetStalledFuncCall {
	f.mutex.Lock()
	history := make([]StoreResetStalledFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreResetStalledFuncCall is an object that describes an invocation of
// method ResetStalled on an instance of MockStore.
type StoreResetStalledFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 []int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreResetStalledFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreResetStalledFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreResetStalledIndexesFunc describes the behavior when the
// ResetStalledIndexes method of the parent MockStore instance is invoked.
type StoreResetStalledIndexesFunc struct {
	defaultHook func(context.Context, time.Time) ([]int, []int, error)
	hooks       []func(context.Context, time.Time) ([]int, []int, error)
	history     []StoreResetStalledIndexesFuncCall
	mutex       sync.Mutex
}

// ResetStalledIndexes delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) ResetStalledIndexes(v0 context.Context, v1 time.Time) ([]int, []int, error) {
	r0, r1, r2 := m.ResetStalledIndexesFunc.nextHook()(v0, v1)
	m.ResetStalledIndexesFunc.appendCall(StoreResetStalledIndexesFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the ResetStalledIndexes
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreResetStalledIndexesFunc) SetDefaultHook(hook func(context.Context, time.Time) ([]int, []int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ResetStalledIndexes method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreResetStalledIndexesFunc) PushHook(hook func(context.Context, time.Time) ([]int, []int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreResetStalledIndexesFunc) SetDefaultReturn(r0 []int, r1 []int, r2 error) {
	f.SetDefaultHook(func(context.Context, time.Time) ([]int, []int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreResetStalledIndexesFunc) PushReturn(r0 []int, r1 []int, r2 error) {
	f.PushHook(func(context.Context, time.Time) ([]int, []int, error) {
		return r0, r1, r2
	})
}

func (f *StoreResetStalledIndexesFunc) nextHook() func(context.Context, time.Time) ([]int, []int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreResetStalledIndexesFunc) appendCall(r0 StoreResetStalledIndexesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreResetStalledIndexesFuncCall objects
// describing the invocations of this function.
func (f *StoreResetStalledIndexesFunc) History() []StoreResetStalledIndexesFuncCall {
	f.mutex.Lock()
	history := make([]StoreResetStalledIndexesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreResetStalledIndexesFuncCall is an object that describes an
// invocation of method ResetStalledIndexes on an instance of MockStore.
type StoreResetStalledIndexesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 []int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreResetStalledIndexesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreResetStalledIndexesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreRollbackToSavepointFunc describes the behavior when the
// RollbackToSavepoint method of the parent MockStore instance is invoked.
type StoreRollbackToSavepointFunc struct {
	defaultHook func(context.Context, string) error
	hooks       []func(context.Context, string) error
	history     []StoreRollbackToSavepointFuncCall
	mutex       sync.Mutex
}

// RollbackToSavepoint delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) RollbackToSavepoint(v0 context.Context, v1 string) error {
	r0 := m.RollbackToSavepointFunc.nextHook()(v0, v1)
	m.RollbackToSavepointFunc.appendCall(StoreRollbackToSavepointFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the RollbackToSavepoint
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreRollbackToSavepointFunc) SetDefaultHook(hook func(context.Context, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RollbackToSavepoint method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreRollbackToSavepointFunc) PushHook(hook func(context.Context, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreRollbackToSavepointFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, string) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreRollbackToSavepointFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, string) error {
		return r0
	})
}

func (f *StoreRollbackToSavepointFunc) nextHook() func(context.Context, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreRollbackToSavepointFunc) appendCall(r0 StoreRollbackToSavepointFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreRollbackToSavepointFuncCall objects
// describing the invocations of this function.
func (f *StoreRollbackToSavepointFunc) History() []StoreRollbackToSavepointFuncCall {
	f.mutex.Lock()
	history := make([]StoreRollbackToSavepointFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreRollbackToSavepointFuncCall is an object that describes an
// invocation of method RollbackToSavepoint on an instance of MockStore.
type StoreRollbackToSavepointFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreRollbackToSavepointFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreRollbackToSavepointFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreSameRepoPagerFunc describes the behavior when the SameRepoPager
// method of the parent MockStore instance is invoked.
type StoreSameRepoPagerFunc struct {
	defaultHook func(context.Context, int, string, string, string, string, int) (int, store.ReferencePager, error)
	hooks       []func(context.Context, int, string, string, string, string, int) (int, store.ReferencePager, error)
	history     []StoreSameRepoPagerFuncCall
	mutex       sync.Mutex
}

// SameRepoPager delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) SameRepoPager(v0 context.Context, v1 int, v2 string, v3 string, v4 string, v5 string, v6 int) (int, store.ReferencePager, error) {
	r0, r1, r2 := m.SameRepoPagerFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6)
	m.SameRepoPagerFunc.appendCall(StoreSameRepoPagerFuncCall{v0, v1, v2, v3, v4, v5, v6, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the SameRepoPager method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreSameRepoPagerFunc) SetDefaultHook(hook func(context.Context, int, string, string, string, string, int) (int, store.ReferencePager, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SameRepoPager method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreSameRepoPagerFunc) PushHook(hook func(context.Context, int, string, string, string, string, int) (int, store.ReferencePager, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreSameRepoPagerFunc) SetDefaultReturn(r0 int, r1 store.ReferencePager, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, string, string, int) (int, store.ReferencePager, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreSameRepoPagerFunc) PushReturn(r0 int, r1 store.ReferencePager, r2 error) {
	f.PushHook(func(context.Context, int, string, string, string, string, int) (int, store.ReferencePager, error) {
		return r0, r1, r2
	})
}

func (f *StoreSameRepoPagerFunc) nextHook() func(context.Context, int, string, string, string, string, int) (int, store.ReferencePager, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreSameRepoPagerFunc) appendCall(r0 StoreSameRepoPagerFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreSameRepoPagerFuncCall objects
// describing the invocations of this function.
func (f *StoreSameRepoPagerFunc) History() []StoreSameRepoPagerFuncCall {
	f.mutex.Lock()
	history := make([]StoreSameRepoPagerFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreSameRepoPagerFuncCall is an object that describes an invocation of
// method SameRepoPager on an instance of MockStore.
type StoreSameRepoPagerFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 string
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 store.ReferencePager
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreSameRepoPagerFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreSameRepoPagerFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreSavepointFunc describes the behavior when the Savepoint method of
// the parent MockStore instance is invoked.
type StoreSavepointFunc struct {
	defaultHook func(context.Context) (string, error)
	hooks       []func(context.Context) (string, error)
	history     []StoreSavepointFuncCall
	mutex       sync.Mutex
}

// Savepoint delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Savepoint(v0 context.Context) (string, error) {
	r0, r1 := m.SavepointFunc.nextHook()(v0)
	m.SavepointFunc.appendCall(StoreSavepointFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Savepoint method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreSavepointFunc) SetDefaultHook(hook func(context.Context) (string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Savepoint method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreSavepointFunc) PushHook(hook func(context.Context) (string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreSavepointFunc) SetDefaultReturn(r0 string, r1 error) {
	f.SetDefaultHook(func(context.Context) (string, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreSavepointFunc) PushReturn(r0 string, r1 error) {
	f.PushHook(func(context.Context) (string, error) {
		return r0, r1
	})
}

func (f *StoreSavepointFunc) nextHook() func(context.Context) (string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreSavepointFunc) appendCall(r0 StoreSavepointFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreSavepointFuncCall objects describing
// the invocations of this function.
func (f *StoreSavepointFunc) History() []StoreSavepointFuncCall {
	f.mutex.Lock()
	history := make([]StoreSavepointFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreSavepointFuncCall is an object that describes an invocation of
// method Savepoint on an instance of MockStore.
type StoreSavepointFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreSavepointFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreSavepointFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreTransactFunc describes the behavior when the Transact method of the
// parent MockStore instance is invoked.
type StoreTransactFunc struct {
	defaultHook func(context.Context) (store.Store, error)
	hooks       []func(context.Context) (store.Store, error)
	history     []StoreTransactFuncCall
	mutex       sync.Mutex
}

// Transact delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Transact(v0 context.Context) (store.Store, error) {
	r0, r1 := m.TransactFunc.nextHook()(v0)
	m.TransactFunc.appendCall(StoreTransactFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Transact method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreTransactFunc) SetDefaultHook(hook func(context.Context) (store.Store, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Transact method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreTransactFunc) PushHook(hook func(context.Context) (store.Store, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreTransactFunc) SetDefaultReturn(r0 store.Store, r1 error) {
	f.SetDefaultHook(func(context.Context) (store.Store, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreTransactFunc) PushReturn(r0 store.Store, r1 error) {
	f.PushHook(func(context.Context) (store.Store, error) {
		return r0, r1
	})
}

func (f *StoreTransactFunc) nextHook() func(context.Context) (store.Store, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreTransactFunc) appendCall(r0 StoreTransactFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreTransactFuncCall objects describing
// the invocations of this function.
func (f *StoreTransactFunc) History() []StoreTransactFuncCall {
	f.mutex.Lock()
	history := make([]StoreTransactFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreTransactFuncCall is an object that describes an invocation of method
// Transact on an instance of MockStore.
type StoreTransactFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Store
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreTransactFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreTransactFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreUpdateCommitsFunc describes the behavior when the UpdateCommits
// method of the parent MockStore instance is invoked.
type StoreUpdateCommitsFunc struct {
	defaultHook func(context.Context, int, map[string][]string) error
	hooks       []func(context.Context, int, map[string][]string) error
	history     []StoreUpdateCommitsFuncCall
	mutex       sync.Mutex
}

// UpdateCommits delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) UpdateCommits(v0 context.Context, v1 int, v2 map[string][]string) error {
	r0 := m.UpdateCommitsFunc.nextHook()(v0, v1, v2)
	m.UpdateCommitsFunc.appendCall(StoreUpdateCommitsFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the UpdateCommits method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreUpdateCommitsFunc) SetDefaultHook(hook func(context.Context, int, map[string][]string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateCommits method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreUpdateCommitsFunc) PushHook(hook func(context.Context, int, map[string][]string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreUpdateCommitsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, map[string][]string) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreUpdateCommitsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, map[string][]string) error {
		return r0
	})
}

func (f *StoreUpdateCommitsFunc) nextHook() func(context.Context, int, map[string][]string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreUpdateCommitsFunc) appendCall(r0 StoreUpdateCommitsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreUpdateCommitsFuncCall objects
// describing the invocations of this function.
func (f *StoreUpdateCommitsFunc) History() []StoreUpdateCommitsFuncCall {
	f.mutex.Lock()
	history := make([]StoreUpdateCommitsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreUpdateCommitsFuncCall is an object that describes an invocation of
// method UpdateCommits on an instance of MockStore.
type StoreUpdateCommitsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 map[string][]string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreUpdateCommitsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreUpdateCommitsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreUpdateDumpsVisibleFromTipFunc describes the behavior when the
// UpdateDumpsVisibleFromTip method of the parent MockStore instance is
// invoked.
type StoreUpdateDumpsVisibleFromTipFunc struct {
	defaultHook func(context.Context, int, string) error
	hooks       []func(context.Context, int, string) error
	history     []StoreUpdateDumpsVisibleFromTipFuncCall
	mutex       sync.Mutex
}

// UpdateDumpsVisibleFromTip delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) UpdateDumpsVisibleFromTip(v0 context.Context, v1 int, v2 string) error {
	r0 := m.UpdateDumpsVisibleFromTipFunc.nextHook()(v0, v1, v2)
	m.UpdateDumpsVisibleFromTipFunc.appendCall(StoreUpdateDumpsVisibleFromTipFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdateDumpsVisibleFromTip method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreUpdateDumpsVisibleFromTipFunc) SetDefaultHook(hook func(context.Context, int, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateDumpsVisibleFromTip method of the parent MockStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreUpdateDumpsVisibleFromTipFunc) PushHook(hook func(context.Context, int, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreUpdateDumpsVisibleFromTipFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreUpdateDumpsVisibleFromTipFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string) error {
		return r0
	})
}

func (f *StoreUpdateDumpsVisibleFromTipFunc) nextHook() func(context.Context, int, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreUpdateDumpsVisibleFromTipFunc) appendCall(r0 StoreUpdateDumpsVisibleFromTipFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreUpdateDumpsVisibleFromTipFuncCall
// objects describing the invocations of this function.
func (f *StoreUpdateDumpsVisibleFromTipFunc) History() []StoreUpdateDumpsVisibleFromTipFuncCall {
	f.mutex.Lock()
	history := make([]StoreUpdateDumpsVisibleFromTipFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreUpdateDumpsVisibleFromTipFuncCall is an object that describes an
// invocation of method UpdateDumpsVisibleFromTip on an instance of
// MockStore.
type StoreUpdateDumpsVisibleFromTipFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreUpdateDumpsVisibleFromTipFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreUpdateDumpsVisibleFromTipFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreUpdateIndexableRepositoryFunc describes the behavior when the
// UpdateIndexableRepository method of the parent MockStore instance is
// invoked.
type StoreUpdateIndexableRepositoryFunc struct {
	defaultHook func(context.Context, store.UpdateableIndexableRepository) error
	hooks       []func(context.Context, store.UpdateableIndexableRepository) error
	history     []StoreUpdateIndexableRepositoryFuncCall
	mutex       sync.Mutex
}

// UpdateIndexableRepository delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) UpdateIndexableRepository(v0 context.Context, v1 store.UpdateableIndexableRepository) error {
	r0 := m.UpdateIndexableRepositoryFunc.nextHook()(v0, v1)
	m.UpdateIndexableRepositoryFunc.appendCall(StoreUpdateIndexableRepositoryFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdateIndexableRepository method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreUpdateIndexableRepositoryFunc) SetDefaultHook(hook func(context.Context, store.UpdateableIndexableRepository) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateIndexableRepository method of the parent MockStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreUpdateIndexableRepositoryFunc) PushHook(hook func(context.Context, store.UpdateableIndexableRepository) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreUpdateIndexableRepositoryFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, store.UpdateableIndexableRepository) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreUpdateIndexableRepositoryFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, store.UpdateableIndexableRepository) error {
		return r0
	})
}

func (f *StoreUpdateIndexableRepositoryFunc) nextHook() func(context.Context, store.UpdateableIndexableRepository) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreUpdateIndexableRepositoryFunc) appendCall(r0 StoreUpdateIndexableRepositoryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreUpdateIndexableRepositoryFuncCall
// objects describing the invocations of this function.
func (f *StoreUpdateIndexableRepositoryFunc) History() []StoreUpdateIndexableRepositoryFuncCall {
	f.mutex.Lock()
	history := make([]StoreUpdateIndexableRepositoryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreUpdateIndexableRepositoryFuncCall is an object that describes an
// invocation of method UpdateIndexableRepository on an instance of
// MockStore.
type StoreUpdateIndexableRepositoryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 store.UpdateableIndexableRepository
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreUpdateIndexableRepositoryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreUpdateIndexableRepositoryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreUpdatePackageReferencesFunc describes the behavior when the
// UpdatePackageReferences method of the parent MockStore instance is
// invoked.
type StoreUpdatePackageReferencesFunc struct {
	defaultHook func(context.Context, []types.PackageReference) error
	hooks       []func(context.Context, []types.PackageReference) error
	history     []StoreUpdatePackageReferencesFuncCall
	mutex       sync.Mutex
}

// UpdatePackageReferences delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) UpdatePackageReferences(v0 context.Context, v1 []types.PackageReference) error {
	r0 := m.UpdatePackageReferencesFunc.nextHook()(v0, v1)
	m.UpdatePackageReferencesFunc.appendCall(StoreUpdatePackageReferencesFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdatePackageReferences method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreUpdatePackageReferencesFunc) SetDefaultHook(hook func(context.Context, []types.PackageReference) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdatePackageReferences method of the parent MockStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreUpdatePackageReferencesFunc) PushHook(hook func(context.Context, []types.PackageReference) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreUpdatePackageReferencesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, []types.PackageReference) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreUpdatePackageReferencesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, []types.PackageReference) error {
		return r0
	})
}

func (f *StoreUpdatePackageReferencesFunc) nextHook() func(context.Context, []types.PackageReference) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreUpdatePackageReferencesFunc) appendCall(r0 StoreUpdatePackageReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreUpdatePackageReferencesFuncCall
// objects describing the invocations of this function.
func (f *StoreUpdatePackageReferencesFunc) History() []StoreUpdatePackageReferencesFuncCall {
	f.mutex.Lock()
	history := make([]StoreUpdatePackageReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreUpdatePackageReferencesFuncCall is an object that describes an
// invocation of method UpdatePackageReferences on an instance of MockStore.
type StoreUpdatePackageReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []types.PackageReference
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreUpdatePackageReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreUpdatePackageReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreUpdatePackagesFunc describes the behavior when the UpdatePackages
// method of the parent MockStore instance is invoked.
type StoreUpdatePackagesFunc struct {
	defaultHook func(context.Context, []types.Package) error
	hooks       []func(context.Context, []types.Package) error
	history     []StoreUpdatePackagesFuncCall
	mutex       sync.Mutex
}

// UpdatePackages delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) UpdatePackages(v0 context.Context, v1 []types.Package) error {
	r0 := m.UpdatePackagesFunc.nextHook()(v0, v1)
	m.UpdatePackagesFunc.appendCall(StoreUpdatePackagesFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the UpdatePackages
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreUpdatePackagesFunc) SetDefaultHook(hook func(context.Context, []types.Package) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdatePackages method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreUpdatePackagesFunc) PushHook(hook func(context.Context, []types.Package) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreUpdatePackagesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, []types.Package) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreUpdatePackagesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, []types.Package) error {
		return r0
	})
}

func (f *StoreUpdatePackagesFunc) nextHook() func(context.Context, []types.Package) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreUpdatePackagesFunc) appendCall(r0 StoreUpdatePackagesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreUpdatePackagesFuncCall objects
// describing the invocations of this function.
func (f *StoreUpdatePackagesFunc) History() []StoreUpdatePackagesFuncCall {
	f.mutex.Lock()
	history := make([]StoreUpdatePackagesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreUpdatePackagesFuncCall is an object that describes an invocation of
// method UpdatePackages on an instance of MockStore.
type StoreUpdatePackagesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []types.Package
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreUpdatePackagesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreUpdatePackagesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}
