// Code generated by go-mockgen 1.3.7; DO NOT EDIT.
//
// This file was generated by running `sg generate` (or `go-mockgen`) at the root of
// this repository. To add additional mocks to this or another package, add a new entry
// to the mockgen.yaml file in the root of this repository.

package background

import (
	"context"
	"io"
	"sync"
	"time"

	regexp "github.com/grafana/regexp"
	sqlf "github.com/keegancsmith/sqlf"
	scip "github.com/sourcegraph/scip/bindings/go/scip"
	enterprise "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/policies/enterprise"
	shared "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/policies/shared"
	types "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/shared/types"
	lsifstore "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/uploads/internal/lsifstore"
	store "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/uploads/internal/store"
	shared1 "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/uploads/shared"
	api "github.com/sourcegraph/sourcegraph/internal/api"
	authz "github.com/sourcegraph/sourcegraph/internal/authz"
	basestore "github.com/sourcegraph/sourcegraph/internal/database/basestore"
	executor "github.com/sourcegraph/sourcegraph/internal/executor"
	gitserver "github.com/sourcegraph/sourcegraph/internal/gitserver"
	gitdomain "github.com/sourcegraph/sourcegraph/internal/gitserver/gitdomain"
	protocol "github.com/sourcegraph/sourcegraph/internal/gitserver/protocol"
	observation "github.com/sourcegraph/sourcegraph/internal/observation"
	types1 "github.com/sourcegraph/sourcegraph/internal/types"
	workerutil "github.com/sourcegraph/sourcegraph/internal/workerutil"
	store1 "github.com/sourcegraph/sourcegraph/internal/workerutil/dbworker/store"
	precise "github.com/sourcegraph/sourcegraph/lib/codeintel/precise"
)

// MockGitserverClient is a mock implementation of the GitserverClient
// interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/uploads/internal/background)
// used for unit testing.
type MockGitserverClient struct {
	// ArchiveReaderFunc is an instance of a mock function object
	// controlling the behavior of the method ArchiveReader.
	ArchiveReaderFunc *GitserverClientArchiveReaderFunc
	// CommitDateFunc is an instance of a mock function object controlling
	// the behavior of the method CommitDate.
	CommitDateFunc *GitserverClientCommitDateFunc
	// CommitExistsFunc is an instance of a mock function object controlling
	// the behavior of the method CommitExists.
	CommitExistsFunc *GitserverClientCommitExistsFunc
	// CommitGraphFunc is an instance of a mock function object controlling
	// the behavior of the method CommitGraph.
	CommitGraphFunc *GitserverClientCommitGraphFunc
	// CommitsUniqueToBranchFunc is an instance of a mock function object
	// controlling the behavior of the method CommitsUniqueToBranch.
	CommitsUniqueToBranchFunc *GitserverClientCommitsUniqueToBranchFunc
	// DefaultBranchContainsFunc is an instance of a mock function object
	// controlling the behavior of the method DefaultBranchContains.
	DefaultBranchContainsFunc *GitserverClientDefaultBranchContainsFunc
	// DirectoryChildrenFunc is an instance of a mock function object
	// controlling the behavior of the method DirectoryChildren.
	DirectoryChildrenFunc *GitserverClientDirectoryChildrenFunc
	// FileExistsFunc is an instance of a mock function object controlling
	// the behavior of the method FileExists.
	FileExistsFunc *GitserverClientFileExistsFunc
	// HeadFunc is an instance of a mock function object controlling the
	// behavior of the method Head.
	HeadFunc *GitserverClientHeadFunc
	// ListFilesFunc is an instance of a mock function object controlling
	// the behavior of the method ListFiles.
	ListFilesFunc *GitserverClientListFilesFunc
	// ListTagsFunc is an instance of a mock function object controlling the
	// behavior of the method ListTags.
	ListTagsFunc *GitserverClientListTagsFunc
	// RawContentsFunc is an instance of a mock function object controlling
	// the behavior of the method RawContents.
	RawContentsFunc *GitserverClientRawContentsFunc
	// RefDescriptionsFunc is an instance of a mock function object
	// controlling the behavior of the method RefDescriptions.
	RefDescriptionsFunc *GitserverClientRefDescriptionsFunc
	// RequestRepoUpdateFunc is an instance of a mock function object
	// controlling the behavior of the method RequestRepoUpdate.
	RequestRepoUpdateFunc *GitserverClientRequestRepoUpdateFunc
	// ResolveRevisionFunc is an instance of a mock function object
	// controlling the behavior of the method ResolveRevision.
	ResolveRevisionFunc *GitserverClientResolveRevisionFunc
}

// NewMockGitserverClient creates a new mock of the GitserverClient
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockGitserverClient() *MockGitserverClient {
	return &MockGitserverClient{
		ArchiveReaderFunc: &GitserverClientArchiveReaderFunc{
			defaultHook: func(context.Context, authz.SubRepoPermissionChecker, api.RepoName, gitserver.ArchiveOptions) (r0 io.ReadCloser, r1 error) {
				return
			},
		},
		CommitDateFunc: &GitserverClientCommitDateFunc{
			defaultHook: func(context.Context, int, string) (r0 string, r1 time.Time, r2 bool, r3 error) {
				return
			},
		},
		CommitExistsFunc: &GitserverClientCommitExistsFunc{
			defaultHook: func(context.Context, int, string) (r0 bool, r1 error) {
				return
			},
		},
		CommitGraphFunc: &GitserverClientCommitGraphFunc{
			defaultHook: func(context.Context, int, gitserver.CommitGraphOptions) (r0 *gitdomain.CommitGraph, r1 error) {
				return
			},
		},
		CommitsUniqueToBranchFunc: &GitserverClientCommitsUniqueToBranchFunc{
			defaultHook: func(context.Context, int, string, bool, *time.Time) (r0 map[string]time.Time, r1 error) {
				return
			},
		},
		DefaultBranchContainsFunc: &GitserverClientDefaultBranchContainsFunc{
			defaultHook: func(context.Context, int, string) (r0 bool, r1 error) {
				return
			},
		},
		DirectoryChildrenFunc: &GitserverClientDirectoryChildrenFunc{
			defaultHook: func(context.Context, int, string, []string) (r0 map[string][]string, r1 error) {
				return
			},
		},
		FileExistsFunc: &GitserverClientFileExistsFunc{
			defaultHook: func(context.Context, int, string, string) (r0 bool, r1 error) {
				return
			},
		},
		HeadFunc: &GitserverClientHeadFunc{
			defaultHook: func(context.Context, int) (r0 string, r1 bool, r2 error) {
				return
			},
		},
		ListFilesFunc: &GitserverClientListFilesFunc{
			defaultHook: func(context.Context, int, string, *regexp.Regexp) (r0 []string, r1 error) {
				return
			},
		},
		ListTagsFunc: &GitserverClientListTagsFunc{
			defaultHook: func(context.Context, api.RepoName, ...string) (r0 []*gitdomain.Tag, r1 error) {
				return
			},
		},
		RawContentsFunc: &GitserverClientRawContentsFunc{
			defaultHook: func(context.Context, int, string, string) (r0 []byte, r1 error) {
				return
			},
		},
		RefDescriptionsFunc: &GitserverClientRefDescriptionsFunc{
			defaultHook: func(context.Context, int, ...string) (r0 map[string][]gitdomain.RefDescription, r1 error) {
				return
			},
		},
		RequestRepoUpdateFunc: &GitserverClientRequestRepoUpdateFunc{
			defaultHook: func(context.Context, api.RepoName, time.Duration) (r0 *protocol.RepoUpdateResponse, r1 error) {
				return
			},
		},
		ResolveRevisionFunc: &GitserverClientResolveRevisionFunc{
			defaultHook: func(context.Context, int, string) (r0 api.CommitID, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockGitserverClient creates a new mock of the GitserverClient
// interface. All methods panic on invocation, unless overwritten.
func NewStrictMockGitserverClient() *MockGitserverClient {
	return &MockGitserverClient{
		ArchiveReaderFunc: &GitserverClientArchiveReaderFunc{
			defaultHook: func(context.Context, authz.SubRepoPermissionChecker, api.RepoName, gitserver.ArchiveOptions) (io.ReadCloser, error) {
				panic("unexpected invocation of MockGitserverClient.ArchiveReader")
			},
		},
		CommitDateFunc: &GitserverClientCommitDateFunc{
			defaultHook: func(context.Context, int, string) (string, time.Time, bool, error) {
				panic("unexpected invocation of MockGitserverClient.CommitDate")
			},
		},
		CommitExistsFunc: &GitserverClientCommitExistsFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				panic("unexpected invocation of MockGitserverClient.CommitExists")
			},
		},
		CommitGraphFunc: &GitserverClientCommitGraphFunc{
			defaultHook: func(context.Context, int, gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error) {
				panic("unexpected invocation of MockGitserverClient.CommitGraph")
			},
		},
		CommitsUniqueToBranchFunc: &GitserverClientCommitsUniqueToBranchFunc{
			defaultHook: func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error) {
				panic("unexpected invocation of MockGitserverClient.CommitsUniqueToBranch")
			},
		},
		DefaultBranchContainsFunc: &GitserverClientDefaultBranchContainsFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				panic("unexpected invocation of MockGitserverClient.DefaultBranchContains")
			},
		},
		DirectoryChildrenFunc: &GitserverClientDirectoryChildrenFunc{
			defaultHook: func(context.Context, int, string, []string) (map[string][]string, error) {
				panic("unexpected invocation of MockGitserverClient.DirectoryChildren")
			},
		},
		FileExistsFunc: &GitserverClientFileExistsFunc{
			defaultHook: func(context.Context, int, string, string) (bool, error) {
				panic("unexpected invocation of MockGitserverClient.FileExists")
			},
		},
		HeadFunc: &GitserverClientHeadFunc{
			defaultHook: func(context.Context, int) (string, bool, error) {
				panic("unexpected invocation of MockGitserverClient.Head")
			},
		},
		ListFilesFunc: &GitserverClientListFilesFunc{
			defaultHook: func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
				panic("unexpected invocation of MockGitserverClient.ListFiles")
			},
		},
		ListTagsFunc: &GitserverClientListTagsFunc{
			defaultHook: func(context.Context, api.RepoName, ...string) ([]*gitdomain.Tag, error) {
				panic("unexpected invocation of MockGitserverClient.ListTags")
			},
		},
		RawContentsFunc: &GitserverClientRawContentsFunc{
			defaultHook: func(context.Context, int, string, string) ([]byte, error) {
				panic("unexpected invocation of MockGitserverClient.RawContents")
			},
		},
		RefDescriptionsFunc: &GitserverClientRefDescriptionsFunc{
			defaultHook: func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error) {
				panic("unexpected invocation of MockGitserverClient.RefDescriptions")
			},
		},
		RequestRepoUpdateFunc: &GitserverClientRequestRepoUpdateFunc{
			defaultHook: func(context.Context, api.RepoName, time.Duration) (*protocol.RepoUpdateResponse, error) {
				panic("unexpected invocation of MockGitserverClient.RequestRepoUpdate")
			},
		},
		ResolveRevisionFunc: &GitserverClientResolveRevisionFunc{
			defaultHook: func(context.Context, int, string) (api.CommitID, error) {
				panic("unexpected invocation of MockGitserverClient.ResolveRevision")
			},
		},
	}
}

// NewMockGitserverClientFrom creates a new mock of the MockGitserverClient
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockGitserverClientFrom(i GitserverClient) *MockGitserverClient {
	return &MockGitserverClient{
		ArchiveReaderFunc: &GitserverClientArchiveReaderFunc{
			defaultHook: i.ArchiveReader,
		},
		CommitDateFunc: &GitserverClientCommitDateFunc{
			defaultHook: i.CommitDate,
		},
		CommitExistsFunc: &GitserverClientCommitExistsFunc{
			defaultHook: i.CommitExists,
		},
		CommitGraphFunc: &GitserverClientCommitGraphFunc{
			defaultHook: i.CommitGraph,
		},
		CommitsUniqueToBranchFunc: &GitserverClientCommitsUniqueToBranchFunc{
			defaultHook: i.CommitsUniqueToBranch,
		},
		DefaultBranchContainsFunc: &GitserverClientDefaultBranchContainsFunc{
			defaultHook: i.DefaultBranchContains,
		},
		DirectoryChildrenFunc: &GitserverClientDirectoryChildrenFunc{
			defaultHook: i.DirectoryChildren,
		},
		FileExistsFunc: &GitserverClientFileExistsFunc{
			defaultHook: i.FileExists,
		},
		HeadFunc: &GitserverClientHeadFunc{
			defaultHook: i.Head,
		},
		ListFilesFunc: &GitserverClientListFilesFunc{
			defaultHook: i.ListFiles,
		},
		ListTagsFunc: &GitserverClientListTagsFunc{
			defaultHook: i.ListTags,
		},
		RawContentsFunc: &GitserverClientRawContentsFunc{
			defaultHook: i.RawContents,
		},
		RefDescriptionsFunc: &GitserverClientRefDescriptionsFunc{
			defaultHook: i.RefDescriptions,
		},
		RequestRepoUpdateFunc: &GitserverClientRequestRepoUpdateFunc{
			defaultHook: i.RequestRepoUpdate,
		},
		ResolveRevisionFunc: &GitserverClientResolveRevisionFunc{
			defaultHook: i.ResolveRevision,
		},
	}
}

// GitserverClientArchiveReaderFunc describes the behavior when the
// ArchiveReader method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientArchiveReaderFunc struct {
	defaultHook func(context.Context, authz.SubRepoPermissionChecker, api.RepoName, gitserver.ArchiveOptions) (io.ReadCloser, error)
	hooks       []func(context.Context, authz.SubRepoPermissionChecker, api.RepoName, gitserver.ArchiveOptions) (io.ReadCloser, error)
	history     []GitserverClientArchiveReaderFuncCall
	mutex       sync.Mutex
}

// ArchiveReader delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverClient) ArchiveReader(v0 context.Context, v1 authz.SubRepoPermissionChecker, v2 api.RepoName, v3 gitserver.ArchiveOptions) (io.ReadCloser, error) {
	r0, r1 := m.ArchiveReaderFunc.nextHook()(v0, v1, v2, v3)
	m.ArchiveReaderFunc.appendCall(GitserverClientArchiveReaderFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ArchiveReader method
// of the parent MockGitserverClient instance is invoked and the hook queue
// is empty.
func (f *GitserverClientArchiveReaderFunc) SetDefaultHook(hook func(context.Context, authz.SubRepoPermissionChecker, api.RepoName, gitserver.ArchiveOptions) (io.ReadCloser, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ArchiveReader method of the parent MockGitserverClient instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitserverClientArchiveReaderFunc) PushHook(hook func(context.Context, authz.SubRepoPermissionChecker, api.RepoName, gitserver.ArchiveOptions) (io.ReadCloser, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientArchiveReaderFunc) SetDefaultReturn(r0 io.ReadCloser, r1 error) {
	f.SetDefaultHook(func(context.Context, authz.SubRepoPermissionChecker, api.RepoName, gitserver.ArchiveOptions) (io.ReadCloser, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientArchiveReaderFunc) PushReturn(r0 io.ReadCloser, r1 error) {
	f.PushHook(func(context.Context, authz.SubRepoPermissionChecker, api.RepoName, gitserver.ArchiveOptions) (io.ReadCloser, error) {
		return r0, r1
	})
}

func (f *GitserverClientArchiveReaderFunc) nextHook() func(context.Context, authz.SubRepoPermissionChecker, api.RepoName, gitserver.ArchiveOptions) (io.ReadCloser, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientArchiveReaderFunc) appendCall(r0 GitserverClientArchiveReaderFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientArchiveReaderFuncCall
// objects describing the invocations of this function.
func (f *GitserverClientArchiveReaderFunc) History() []GitserverClientArchiveReaderFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientArchiveReaderFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientArchiveReaderFuncCall is an object that describes an
// invocation of method ArchiveReader on an instance of MockGitserverClient.
type GitserverClientArchiveReaderFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 authz.SubRepoPermissionChecker
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 api.RepoName
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 gitserver.ArchiveOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 io.ReadCloser
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientArchiveReaderFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientArchiveReaderFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientCommitDateFunc describes the behavior when the CommitDate
// method of the parent MockGitserverClient instance is invoked.
type GitserverClientCommitDateFunc struct {
	defaultHook func(context.Context, int, string) (string, time.Time, bool, error)
	hooks       []func(context.Context, int, string) (string, time.Time, bool, error)
	history     []GitserverClientCommitDateFuncCall
	mutex       sync.Mutex
}

// CommitDate delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverClient) CommitDate(v0 context.Context, v1 int, v2 string) (string, time.Time, bool, error) {
	r0, r1, r2, r3 := m.CommitDateFunc.nextHook()(v0, v1, v2)
	m.CommitDateFunc.appendCall(GitserverClientCommitDateFuncCall{v0, v1, v2, r0, r1, r2, r3})
	return r0, r1, r2, r3
}

// SetDefaultHook sets function that is called when the CommitDate method of
// the parent MockGitserverClient instance is invoked and the hook queue is
// empty.
func (f *GitserverClientCommitDateFunc) SetDefaultHook(hook func(context.Context, int, string) (string, time.Time, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitDate method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientCommitDateFunc) PushHook(hook func(context.Context, int, string) (string, time.Time, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientCommitDateFunc) SetDefaultReturn(r0 string, r1 time.Time, r2 bool, r3 error) {
	f.SetDefaultHook(func(context.Context, int, string) (string, time.Time, bool, error) {
		return r0, r1, r2, r3
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientCommitDateFunc) PushReturn(r0 string, r1 time.Time, r2 bool, r3 error) {
	f.PushHook(func(context.Context, int, string) (string, time.Time, bool, error) {
		return r0, r1, r2, r3
	})
}

func (f *GitserverClientCommitDateFunc) nextHook() func(context.Context, int, string) (string, time.Time, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientCommitDateFunc) appendCall(r0 GitserverClientCommitDateFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientCommitDateFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientCommitDateFunc) History() []GitserverClientCommitDateFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientCommitDateFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientCommitDateFuncCall is an object that describes an
// invocation of method CommitDate on an instance of MockGitserverClient.
type GitserverClientCommitDateFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 time.Time
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 bool
	// Result3 is the value of the 4th result returned from this method
	// invocation.
	Result3 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientCommitDateFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientCommitDateFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2, c.Result3}
}

// GitserverClientCommitExistsFunc describes the behavior when the
// CommitExists method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientCommitExistsFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []GitserverClientCommitExistsFuncCall
	mutex       sync.Mutex
}

// CommitExists delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverClient) CommitExists(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.CommitExistsFunc.nextHook()(v0, v1, v2)
	m.CommitExistsFunc.appendCall(GitserverClientCommitExistsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the CommitExists method
// of the parent MockGitserverClient instance is invoked and the hook queue
// is empty.
func (f *GitserverClientCommitExistsFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitExists method of the parent MockGitserverClient instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitserverClientCommitExistsFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientCommitExistsFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientCommitExistsFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *GitserverClientCommitExistsFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientCommitExistsFunc) appendCall(r0 GitserverClientCommitExistsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientCommitExistsFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientCommitExistsFunc) History() []GitserverClientCommitExistsFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientCommitExistsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientCommitExistsFuncCall is an object that describes an
// invocation of method CommitExists on an instance of MockGitserverClient.
type GitserverClientCommitExistsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientCommitExistsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientCommitExistsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientCommitGraphFunc describes the behavior when the
// CommitGraph method of the parent MockGitserverClient instance is invoked.
type GitserverClientCommitGraphFunc struct {
	defaultHook func(context.Context, int, gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error)
	hooks       []func(context.Context, int, gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error)
	history     []GitserverClientCommitGraphFuncCall
	mutex       sync.Mutex
}

// CommitGraph delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverClient) CommitGraph(v0 context.Context, v1 int, v2 gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error) {
	r0, r1 := m.CommitGraphFunc.nextHook()(v0, v1, v2)
	m.CommitGraphFunc.appendCall(GitserverClientCommitGraphFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the CommitGraph method
// of the parent MockGitserverClient instance is invoked and the hook queue
// is empty.
func (f *GitserverClientCommitGraphFunc) SetDefaultHook(hook func(context.Context, int, gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitGraph method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientCommitGraphFunc) PushHook(hook func(context.Context, int, gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientCommitGraphFunc) SetDefaultReturn(r0 *gitdomain.CommitGraph, r1 error) {
	f.SetDefaultHook(func(context.Context, int, gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientCommitGraphFunc) PushReturn(r0 *gitdomain.CommitGraph, r1 error) {
	f.PushHook(func(context.Context, int, gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error) {
		return r0, r1
	})
}

func (f *GitserverClientCommitGraphFunc) nextHook() func(context.Context, int, gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientCommitGraphFunc) appendCall(r0 GitserverClientCommitGraphFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientCommitGraphFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientCommitGraphFunc) History() []GitserverClientCommitGraphFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientCommitGraphFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientCommitGraphFuncCall is an object that describes an
// invocation of method CommitGraph on an instance of MockGitserverClient.
type GitserverClientCommitGraphFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 gitserver.CommitGraphOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *gitdomain.CommitGraph
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientCommitGraphFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientCommitGraphFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientCommitsUniqueToBranchFunc describes the behavior when the
// CommitsUniqueToBranch method of the parent MockGitserverClient instance
// is invoked.
type GitserverClientCommitsUniqueToBranchFunc struct {
	defaultHook func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error)
	hooks       []func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error)
	history     []GitserverClientCommitsUniqueToBranchFuncCall
	mutex       sync.Mutex
}

// CommitsUniqueToBranch delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockGitserverClient) CommitsUniqueToBranch(v0 context.Context, v1 int, v2 string, v3 bool, v4 *time.Time) (map[string]time.Time, error) {
	r0, r1 := m.CommitsUniqueToBranchFunc.nextHook()(v0, v1, v2, v3, v4)
	m.CommitsUniqueToBranchFunc.appendCall(GitserverClientCommitsUniqueToBranchFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CommitsUniqueToBranch method of the parent MockGitserverClient instance
// is invoked and the hook queue is empty.
func (f *GitserverClientCommitsUniqueToBranchFunc) SetDefaultHook(hook func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitsUniqueToBranch method of the parent MockGitserverClient instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *GitserverClientCommitsUniqueToBranchFunc) PushHook(hook func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientCommitsUniqueToBranchFunc) SetDefaultReturn(r0 map[string]time.Time, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientCommitsUniqueToBranchFunc) PushReturn(r0 map[string]time.Time, r1 error) {
	f.PushHook(func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error) {
		return r0, r1
	})
}

func (f *GitserverClientCommitsUniqueToBranchFunc) nextHook() func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientCommitsUniqueToBranchFunc) appendCall(r0 GitserverClientCommitsUniqueToBranchFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// GitserverClientCommitsUniqueToBranchFuncCall objects describing the
// invocations of this function.
func (f *GitserverClientCommitsUniqueToBranchFunc) History() []GitserverClientCommitsUniqueToBranchFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientCommitsUniqueToBranchFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientCommitsUniqueToBranchFuncCall is an object that describes
// an invocation of method CommitsUniqueToBranch on an instance of
// MockGitserverClient.
type GitserverClientCommitsUniqueToBranchFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 bool
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 *time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[string]time.Time
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientCommitsUniqueToBranchFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientCommitsUniqueToBranchFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientDefaultBranchContainsFunc describes the behavior when the
// DefaultBranchContains method of the parent MockGitserverClient instance
// is invoked.
type GitserverClientDefaultBranchContainsFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []GitserverClientDefaultBranchContainsFuncCall
	mutex       sync.Mutex
}

// DefaultBranchContains delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockGitserverClient) DefaultBranchContains(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.DefaultBranchContainsFunc.nextHook()(v0, v1, v2)
	m.DefaultBranchContainsFunc.appendCall(GitserverClientDefaultBranchContainsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// DefaultBranchContains method of the parent MockGitserverClient instance
// is invoked and the hook queue is empty.
func (f *GitserverClientDefaultBranchContainsFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DefaultBranchContains method of the parent MockGitserverClient instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *GitserverClientDefaultBranchContainsFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientDefaultBranchContainsFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientDefaultBranchContainsFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *GitserverClientDefaultBranchContainsFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientDefaultBranchContainsFunc) appendCall(r0 GitserverClientDefaultBranchContainsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// GitserverClientDefaultBranchContainsFuncCall objects describing the
// invocations of this function.
func (f *GitserverClientDefaultBranchContainsFunc) History() []GitserverClientDefaultBranchContainsFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientDefaultBranchContainsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientDefaultBranchContainsFuncCall is an object that describes
// an invocation of method DefaultBranchContains on an instance of
// MockGitserverClient.
type GitserverClientDefaultBranchContainsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientDefaultBranchContainsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientDefaultBranchContainsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientDirectoryChildrenFunc describes the behavior when the
// DirectoryChildren method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientDirectoryChildrenFunc struct {
	defaultHook func(context.Context, int, string, []string) (map[string][]string, error)
	hooks       []func(context.Context, int, string, []string) (map[string][]string, error)
	history     []GitserverClientDirectoryChildrenFuncCall
	mutex       sync.Mutex
}

// DirectoryChildren delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockGitserverClient) DirectoryChildren(v0 context.Context, v1 int, v2 string, v3 []string) (map[string][]string, error) {
	r0, r1 := m.DirectoryChildrenFunc.nextHook()(v0, v1, v2, v3)
	m.DirectoryChildrenFunc.appendCall(GitserverClientDirectoryChildrenFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DirectoryChildren
// method of the parent MockGitserverClient instance is invoked and the hook
// queue is empty.
func (f *GitserverClientDirectoryChildrenFunc) SetDefaultHook(hook func(context.Context, int, string, []string) (map[string][]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DirectoryChildren method of the parent MockGitserverClient instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *GitserverClientDirectoryChildrenFunc) PushHook(hook func(context.Context, int, string, []string) (map[string][]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientDirectoryChildrenFunc) SetDefaultReturn(r0 map[string][]string, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, []string) (map[string][]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientDirectoryChildrenFunc) PushReturn(r0 map[string][]string, r1 error) {
	f.PushHook(func(context.Context, int, string, []string) (map[string][]string, error) {
		return r0, r1
	})
}

func (f *GitserverClientDirectoryChildrenFunc) nextHook() func(context.Context, int, string, []string) (map[string][]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientDirectoryChildrenFunc) appendCall(r0 GitserverClientDirectoryChildrenFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientDirectoryChildrenFuncCall
// objects describing the invocations of this function.
func (f *GitserverClientDirectoryChildrenFunc) History() []GitserverClientDirectoryChildrenFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientDirectoryChildrenFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientDirectoryChildrenFuncCall is an object that describes an
// invocation of method DirectoryChildren on an instance of
// MockGitserverClient.
type GitserverClientDirectoryChildrenFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 []string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[string][]string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientDirectoryChildrenFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientDirectoryChildrenFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientFileExistsFunc describes the behavior when the FileExists
// method of the parent MockGitserverClient instance is invoked.
type GitserverClientFileExistsFunc struct {
	defaultHook func(context.Context, int, string, string) (bool, error)
	hooks       []func(context.Context, int, string, string) (bool, error)
	history     []GitserverClientFileExistsFuncCall
	mutex       sync.Mutex
}

// FileExists delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverClient) FileExists(v0 context.Context, v1 int, v2 string, v3 string) (bool, error) {
	r0, r1 := m.FileExistsFunc.nextHook()(v0, v1, v2, v3)
	m.FileExistsFunc.appendCall(GitserverClientFileExistsFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the FileExists method of
// the parent MockGitserverClient instance is invoked and the hook queue is
// empty.
func (f *GitserverClientFileExistsFunc) SetDefaultHook(hook func(context.Context, int, string, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// FileExists method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientFileExistsFunc) PushHook(hook func(context.Context, int, string, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientFileExistsFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientFileExistsFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string, string) (bool, error) {
		return r0, r1
	})
}

func (f *GitserverClientFileExistsFunc) nextHook() func(context.Context, int, string, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientFileExistsFunc) appendCall(r0 GitserverClientFileExistsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientFileExistsFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientFileExistsFunc) History() []GitserverClientFileExistsFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientFileExistsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientFileExistsFuncCall is an object that describes an
// invocation of method FileExists on an instance of MockGitserverClient.
type GitserverClientFileExistsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientFileExistsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientFileExistsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientHeadFunc describes the behavior when the Head method of
// the parent MockGitserverClient instance is invoked.
type GitserverClientHeadFunc struct {
	defaultHook func(context.Context, int) (string, bool, error)
	hooks       []func(context.Context, int) (string, bool, error)
	history     []GitserverClientHeadFuncCall
	mutex       sync.Mutex
}

// Head delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockGitserverClient) Head(v0 context.Context, v1 int) (string, bool, error) {
	r0, r1, r2 := m.HeadFunc.nextHook()(v0, v1)
	m.HeadFunc.appendCall(GitserverClientHeadFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Head method of the
// parent MockGitserverClient instance is invoked and the hook queue is
// empty.
func (f *GitserverClientHeadFunc) SetDefaultHook(hook func(context.Context, int) (string, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Head method of the parent MockGitserverClient instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *GitserverClientHeadFunc) PushHook(hook func(context.Context, int) (string, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientHeadFunc) SetDefaultReturn(r0 string, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (string, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientHeadFunc) PushReturn(r0 string, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (string, bool, error) {
		return r0, r1, r2
	})
}

func (f *GitserverClientHeadFunc) nextHook() func(context.Context, int) (string, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientHeadFunc) appendCall(r0 GitserverClientHeadFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientHeadFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientHeadFunc) History() []GitserverClientHeadFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientHeadFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientHeadFuncCall is an object that describes an invocation of
// method Head on an instance of MockGitserverClient.
type GitserverClientHeadFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientHeadFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientHeadFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// GitserverClientListFilesFunc describes the behavior when the ListFiles
// method of the parent MockGitserverClient instance is invoked.
type GitserverClientListFilesFunc struct {
	defaultHook func(context.Context, int, string, *regexp.Regexp) ([]string, error)
	hooks       []func(context.Context, int, string, *regexp.Regexp) ([]string, error)
	history     []GitserverClientListFilesFuncCall
	mutex       sync.Mutex
}

// ListFiles delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockGitserverClient) ListFiles(v0 context.Context, v1 int, v2 string, v3 *regexp.Regexp) ([]string, error) {
	r0, r1 := m.ListFilesFunc.nextHook()(v0, v1, v2, v3)
	m.ListFilesFunc.appendCall(GitserverClientListFilesFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ListFiles method of
// the parent MockGitserverClient instance is invoked and the hook queue is
// empty.
func (f *GitserverClientListFilesFunc) SetDefaultHook(hook func(context.Context, int, string, *regexp.Regexp) ([]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ListFiles method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientListFilesFunc) PushHook(hook func(context.Context, int, string, *regexp.Regexp) ([]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientListFilesFunc) SetDefaultReturn(r0 []string, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientListFilesFunc) PushReturn(r0 []string, r1 error) {
	f.PushHook(func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
		return r0, r1
	})
}

func (f *GitserverClientListFilesFunc) nextHook() func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientListFilesFunc) appendCall(r0 GitserverClientListFilesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientListFilesFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientListFilesFunc) History() []GitserverClientListFilesFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientListFilesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientListFilesFuncCall is an object that describes an
// invocation of method ListFiles on an instance of MockGitserverClient.
type GitserverClientListFilesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 *regexp.Regexp
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientListFilesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientListFilesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientListTagsFunc describes the behavior when the ListTags
// method of the parent MockGitserverClient instance is invoked.
type GitserverClientListTagsFunc struct {
	defaultHook func(context.Context, api.RepoName, ...string) ([]*gitdomain.Tag, error)
	hooks       []func(context.Context, api.RepoName, ...string) ([]*gitdomain.Tag, error)
	history     []GitserverClientListTagsFuncCall
	mutex       sync.Mutex
}

// ListTags delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockGitserverClient) ListTags(v0 context.Context, v1 api.RepoName, v2 ...string) ([]*gitdomain.Tag, error) {
	r0, r1 := m.ListTagsFunc.nextHook()(v0, v1, v2...)
	m.ListTagsFunc.appendCall(GitserverClientListTagsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ListTags method of
// the parent MockGitserverClient instance is invoked and the hook queue is
// empty.
func (f *GitserverClientListTagsFunc) SetDefaultHook(hook func(context.Context, api.RepoName, ...string) ([]*gitdomain.Tag, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ListTags method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientListTagsFunc) PushHook(hook func(context.Context, api.RepoName, ...string) ([]*gitdomain.Tag, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientListTagsFunc) SetDefaultReturn(r0 []*gitdomain.Tag, r1 error) {
	f.SetDefaultHook(func(context.Context, api.RepoName, ...string) ([]*gitdomain.Tag, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientListTagsFunc) PushReturn(r0 []*gitdomain.Tag, r1 error) {
	f.PushHook(func(context.Context, api.RepoName, ...string) ([]*gitdomain.Tag, error) {
		return r0, r1
	})
}

func (f *GitserverClientListTagsFunc) nextHook() func(context.Context, api.RepoName, ...string) ([]*gitdomain.Tag, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientListTagsFunc) appendCall(r0 GitserverClientListTagsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientListTagsFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientListTagsFunc) History() []GitserverClientListTagsFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientListTagsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientListTagsFuncCall is an object that describes an invocation
// of method ListTags on an instance of MockGitserverClient.
type GitserverClientListTagsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 api.RepoName
	// Arg2 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg2 []string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []*gitdomain.Tag
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c GitserverClientListTagsFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg2 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0, c.Arg1}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientListTagsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientRawContentsFunc describes the behavior when the
// RawContents method of the parent MockGitserverClient instance is invoked.
type GitserverClientRawContentsFunc struct {
	defaultHook func(context.Context, int, string, string) ([]byte, error)
	hooks       []func(context.Context, int, string, string) ([]byte, error)
	history     []GitserverClientRawContentsFuncCall
	mutex       sync.Mutex
}

// RawContents delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverClient) RawContents(v0 context.Context, v1 int, v2 string, v3 string) ([]byte, error) {
	r0, r1 := m.RawContentsFunc.nextHook()(v0, v1, v2, v3)
	m.RawContentsFunc.appendCall(GitserverClientRawContentsFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RawContents method
// of the parent MockGitserverClient instance is invoked and the hook queue
// is empty.
func (f *GitserverClientRawContentsFunc) SetDefaultHook(hook func(context.Context, int, string, string) ([]byte, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RawContents method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientRawContentsFunc) PushHook(hook func(context.Context, int, string, string) ([]byte, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientRawContentsFunc) SetDefaultReturn(r0 []byte, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string) ([]byte, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientRawContentsFunc) PushReturn(r0 []byte, r1 error) {
	f.PushHook(func(context.Context, int, string, string) ([]byte, error) {
		return r0, r1
	})
}

func (f *GitserverClientRawContentsFunc) nextHook() func(context.Context, int, string, string) ([]byte, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientRawContentsFunc) appendCall(r0 GitserverClientRawContentsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientRawContentsFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientRawContentsFunc) History() []GitserverClientRawContentsFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientRawContentsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientRawContentsFuncCall is an object that describes an
// invocation of method RawContents on an instance of MockGitserverClient.
type GitserverClientRawContentsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []byte
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientRawContentsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientRawContentsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientRefDescriptionsFunc describes the behavior when the
// RefDescriptions method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientRefDescriptionsFunc struct {
	defaultHook func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error)
	hooks       []func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error)
	history     []GitserverClientRefDescriptionsFuncCall
	mutex       sync.Mutex
}

// RefDescriptions delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockGitserverClient) RefDescriptions(v0 context.Context, v1 int, v2 ...string) (map[string][]gitdomain.RefDescription, error) {
	r0, r1 := m.RefDescriptionsFunc.nextHook()(v0, v1, v2...)
	m.RefDescriptionsFunc.appendCall(GitserverClientRefDescriptionsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RefDescriptions
// method of the parent MockGitserverClient instance is invoked and the hook
// queue is empty.
func (f *GitserverClientRefDescriptionsFunc) SetDefaultHook(hook func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RefDescriptions method of the parent MockGitserverClient instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitserverClientRefDescriptionsFunc) PushHook(hook func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientRefDescriptionsFunc) SetDefaultReturn(r0 map[string][]gitdomain.RefDescription, r1 error) {
	f.SetDefaultHook(func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientRefDescriptionsFunc) PushReturn(r0 map[string][]gitdomain.RefDescription, r1 error) {
	f.PushHook(func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error) {
		return r0, r1
	})
}

func (f *GitserverClientRefDescriptionsFunc) nextHook() func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientRefDescriptionsFunc) appendCall(r0 GitserverClientRefDescriptionsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientRefDescriptionsFuncCall
// objects describing the invocations of this function.
func (f *GitserverClientRefDescriptionsFunc) History() []GitserverClientRefDescriptionsFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientRefDescriptionsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientRefDescriptionsFuncCall is an object that describes an
// invocation of method RefDescriptions on an instance of
// MockGitserverClient.
type GitserverClientRefDescriptionsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg2 []string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[string][]gitdomain.RefDescription
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c GitserverClientRefDescriptionsFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg2 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0, c.Arg1}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientRefDescriptionsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientRequestRepoUpdateFunc describes the behavior when the
// RequestRepoUpdate method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientRequestRepoUpdateFunc struct {
	defaultHook func(context.Context, api.RepoName, time.Duration) (*protocol.RepoUpdateResponse, error)
	hooks       []func(context.Context, api.RepoName, time.Duration) (*protocol.RepoUpdateResponse, error)
	history     []GitserverClientRequestRepoUpdateFuncCall
	mutex       sync.Mutex
}

// RequestRepoUpdate delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockGitserverClient) RequestRepoUpdate(v0 context.Context, v1 api.RepoName, v2 time.Duration) (*protocol.RepoUpdateResponse, error) {
	r0, r1 := m.RequestRepoUpdateFunc.nextHook()(v0, v1, v2)
	m.RequestRepoUpdateFunc.appendCall(GitserverClientRequestRepoUpdateFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RequestRepoUpdate
// method of the parent MockGitserverClient instance is invoked and the hook
// queue is empty.
func (f *GitserverClientRequestRepoUpdateFunc) SetDefaultHook(hook func(context.Context, api.RepoName, time.Duration) (*protocol.RepoUpdateResponse, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RequestRepoUpdate method of the parent MockGitserverClient instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *GitserverClientRequestRepoUpdateFunc) PushHook(hook func(context.Context, api.RepoName, time.Duration) (*protocol.RepoUpdateResponse, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientRequestRepoUpdateFunc) SetDefaultReturn(r0 *protocol.RepoUpdateResponse, r1 error) {
	f.SetDefaultHook(func(context.Context, api.RepoName, time.Duration) (*protocol.RepoUpdateResponse, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientRequestRepoUpdateFunc) PushReturn(r0 *protocol.RepoUpdateResponse, r1 error) {
	f.PushHook(func(context.Context, api.RepoName, time.Duration) (*protocol.RepoUpdateResponse, error) {
		return r0, r1
	})
}

func (f *GitserverClientRequestRepoUpdateFunc) nextHook() func(context.Context, api.RepoName, time.Duration) (*protocol.RepoUpdateResponse, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientRequestRepoUpdateFunc) appendCall(r0 GitserverClientRequestRepoUpdateFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientRequestRepoUpdateFuncCall
// objects describing the invocations of this function.
func (f *GitserverClientRequestRepoUpdateFunc) History() []GitserverClientRequestRepoUpdateFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientRequestRepoUpdateFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientRequestRepoUpdateFuncCall is an object that describes an
// invocation of method RequestRepoUpdate on an instance of
// MockGitserverClient.
type GitserverClientRequestRepoUpdateFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 api.RepoName
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Duration
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *protocol.RepoUpdateResponse
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientRequestRepoUpdateFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientRequestRepoUpdateFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientResolveRevisionFunc describes the behavior when the
// ResolveRevision method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientResolveRevisionFunc struct {
	defaultHook func(context.Context, int, string) (api.CommitID, error)
	hooks       []func(context.Context, int, string) (api.CommitID, error)
	history     []GitserverClientResolveRevisionFuncCall
	mutex       sync.Mutex
}

// ResolveRevision delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockGitserverClient) ResolveRevision(v0 context.Context, v1 int, v2 string) (api.CommitID, error) {
	r0, r1 := m.ResolveRevisionFunc.nextHook()(v0, v1, v2)
	m.ResolveRevisionFunc.appendCall(GitserverClientResolveRevisionFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ResolveRevision
// method of the parent MockGitserverClient instance is invoked and the hook
// queue is empty.
func (f *GitserverClientResolveRevisionFunc) SetDefaultHook(hook func(context.Context, int, string) (api.CommitID, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ResolveRevision method of the parent MockGitserverClient instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitserverClientResolveRevisionFunc) PushHook(hook func(context.Context, int, string) (api.CommitID, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientResolveRevisionFunc) SetDefaultReturn(r0 api.CommitID, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (api.CommitID, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientResolveRevisionFunc) PushReturn(r0 api.CommitID, r1 error) {
	f.PushHook(func(context.Context, int, string) (api.CommitID, error) {
		return r0, r1
	})
}

func (f *GitserverClientResolveRevisionFunc) nextHook() func(context.Context, int, string) (api.CommitID, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientResolveRevisionFunc) appendCall(r0 GitserverClientResolveRevisionFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientResolveRevisionFuncCall
// objects describing the invocations of this function.
func (f *GitserverClientResolveRevisionFunc) History() []GitserverClientResolveRevisionFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientResolveRevisionFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientResolveRevisionFuncCall is an object that describes an
// invocation of method ResolveRevision on an instance of
// MockGitserverClient.
type GitserverClientResolveRevisionFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 api.CommitID
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientResolveRevisionFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientResolveRevisionFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockPolicyMatcher is a mock implementation of the PolicyMatcher interface
// (from the package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/uploads/internal/background)
// used for unit testing.
type MockPolicyMatcher struct {
	// CommitsDescribedByPolicyFunc is an instance of a mock function object
	// controlling the behavior of the method CommitsDescribedByPolicy.
	CommitsDescribedByPolicyFunc *PolicyMatcherCommitsDescribedByPolicyFunc
}

// NewMockPolicyMatcher creates a new mock of the PolicyMatcher interface.
// All methods return zero values for all results, unless overwritten.
func NewMockPolicyMatcher() *MockPolicyMatcher {
	return &MockPolicyMatcher{
		CommitsDescribedByPolicyFunc: &PolicyMatcherCommitsDescribedByPolicyFunc{
			defaultHook: func(context.Context, int, []types.ConfigurationPolicy, time.Time, ...string) (r0 map[string][]enterprise.PolicyMatch, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockPolicyMatcher creates a new mock of the PolicyMatcher
// interface. All methods panic on invocation, unless overwritten.
func NewStrictMockPolicyMatcher() *MockPolicyMatcher {
	return &MockPolicyMatcher{
		CommitsDescribedByPolicyFunc: &PolicyMatcherCommitsDescribedByPolicyFunc{
			defaultHook: func(context.Context, int, []types.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error) {
				panic("unexpected invocation of MockPolicyMatcher.CommitsDescribedByPolicy")
			},
		},
	}
}

// NewMockPolicyMatcherFrom creates a new mock of the MockPolicyMatcher
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockPolicyMatcherFrom(i PolicyMatcher) *MockPolicyMatcher {
	return &MockPolicyMatcher{
		CommitsDescribedByPolicyFunc: &PolicyMatcherCommitsDescribedByPolicyFunc{
			defaultHook: i.CommitsDescribedByPolicy,
		},
	}
}

// PolicyMatcherCommitsDescribedByPolicyFunc describes the behavior when the
// CommitsDescribedByPolicy method of the parent MockPolicyMatcher instance
// is invoked.
type PolicyMatcherCommitsDescribedByPolicyFunc struct {
	defaultHook func(context.Context, int, []types.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error)
	hooks       []func(context.Context, int, []types.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error)
	history     []PolicyMatcherCommitsDescribedByPolicyFuncCall
	mutex       sync.Mutex
}

// CommitsDescribedByPolicy delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockPolicyMatcher) CommitsDescribedByPolicy(v0 context.Context, v1 int, v2 []types.ConfigurationPolicy, v3 time.Time, v4 ...string) (map[string][]enterprise.PolicyMatch, error) {
	r0, r1 := m.CommitsDescribedByPolicyFunc.nextHook()(v0, v1, v2, v3, v4...)
	m.CommitsDescribedByPolicyFunc.appendCall(PolicyMatcherCommitsDescribedByPolicyFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CommitsDescribedByPolicy method of the parent MockPolicyMatcher instance
// is invoked and the hook queue is empty.
func (f *PolicyMatcherCommitsDescribedByPolicyFunc) SetDefaultHook(hook func(context.Context, int, []types.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitsDescribedByPolicy method of the parent MockPolicyMatcher instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *PolicyMatcherCommitsDescribedByPolicyFunc) PushHook(hook func(context.Context, int, []types.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *PolicyMatcherCommitsDescribedByPolicyFunc) SetDefaultReturn(r0 map[string][]enterprise.PolicyMatch, r1 error) {
	f.SetDefaultHook(func(context.Context, int, []types.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *PolicyMatcherCommitsDescribedByPolicyFunc) PushReturn(r0 map[string][]enterprise.PolicyMatch, r1 error) {
	f.PushHook(func(context.Context, int, []types.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error) {
		return r0, r1
	})
}

func (f *PolicyMatcherCommitsDescribedByPolicyFunc) nextHook() func(context.Context, int, []types.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *PolicyMatcherCommitsDescribedByPolicyFunc) appendCall(r0 PolicyMatcherCommitsDescribedByPolicyFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// PolicyMatcherCommitsDescribedByPolicyFuncCall objects describing the
// invocations of this function.
func (f *PolicyMatcherCommitsDescribedByPolicyFunc) History() []PolicyMatcherCommitsDescribedByPolicyFuncCall {
	f.mutex.Lock()
	history := make([]PolicyMatcherCommitsDescribedByPolicyFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// PolicyMatcherCommitsDescribedByPolicyFuncCall is an object that describes
// an invocation of method CommitsDescribedByPolicy on an instance of
// MockPolicyMatcher.
type PolicyMatcherCommitsDescribedByPolicyFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []types.ConfigurationPolicy
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 time.Time
	// Arg4 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg4 []string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[string][]enterprise.PolicyMatch
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c PolicyMatcherCommitsDescribedByPolicyFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg4 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c PolicyMatcherCommitsDescribedByPolicyFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockPolicyService is a mock implementation of the PolicyService interface
// (from the package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/uploads/internal/background)
// used for unit testing.
type MockPolicyService struct {
	// GetConfigurationPoliciesFunc is an instance of a mock function object
	// controlling the behavior of the method GetConfigurationPolicies.
	GetConfigurationPoliciesFunc *PolicyServiceGetConfigurationPoliciesFunc
}

// NewMockPolicyService creates a new mock of the PolicyService interface.
// All methods return zero values for all results, unless overwritten.
func NewMockPolicyService() *MockPolicyService {
	return &MockPolicyService{
		GetConfigurationPoliciesFunc: &PolicyServiceGetConfigurationPoliciesFunc{
			defaultHook: func(context.Context, shared.GetConfigurationPoliciesOptions) (r0 []types.ConfigurationPolicy, r1 int, r2 error) {
				return
			},
		},
	}
}

// NewStrictMockPolicyService creates a new mock of the PolicyService
// interface. All methods panic on invocation, unless overwritten.
func NewStrictMockPolicyService() *MockPolicyService {
	return &MockPolicyService{
		GetConfigurationPoliciesFunc: &PolicyServiceGetConfigurationPoliciesFunc{
			defaultHook: func(context.Context, shared.GetConfigurationPoliciesOptions) ([]types.ConfigurationPolicy, int, error) {
				panic("unexpected invocation of MockPolicyService.GetConfigurationPolicies")
			},
		},
	}
}

// NewMockPolicyServiceFrom creates a new mock of the MockPolicyService
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockPolicyServiceFrom(i PolicyService) *MockPolicyService {
	return &MockPolicyService{
		GetConfigurationPoliciesFunc: &PolicyServiceGetConfigurationPoliciesFunc{
			defaultHook: i.GetConfigurationPolicies,
		},
	}
}

// PolicyServiceGetConfigurationPoliciesFunc describes the behavior when the
// GetConfigurationPolicies method of the parent MockPolicyService instance
// is invoked.
type PolicyServiceGetConfigurationPoliciesFunc struct {
	defaultHook func(context.Context, shared.GetConfigurationPoliciesOptions) ([]types.ConfigurationPolicy, int, error)
	hooks       []func(context.Context, shared.GetConfigurationPoliciesOptions) ([]types.ConfigurationPolicy, int, error)
	history     []PolicyServiceGetConfigurationPoliciesFuncCall
	mutex       sync.Mutex
}

// GetConfigurationPolicies delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockPolicyService) GetConfigurationPolicies(v0 context.Context, v1 shared.GetConfigurationPoliciesOptions) ([]types.ConfigurationPolicy, int, error) {
	r0, r1, r2 := m.GetConfigurationPoliciesFunc.nextHook()(v0, v1)
	m.GetConfigurationPoliciesFunc.appendCall(PolicyServiceGetConfigurationPoliciesFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// GetConfigurationPolicies method of the parent MockPolicyService instance
// is invoked and the hook queue is empty.
func (f *PolicyServiceGetConfigurationPoliciesFunc) SetDefaultHook(hook func(context.Context, shared.GetConfigurationPoliciesOptions) ([]types.ConfigurationPolicy, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetConfigurationPolicies method of the parent MockPolicyService instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *PolicyServiceGetConfigurationPoliciesFunc) PushHook(hook func(context.Context, shared.GetConfigurationPoliciesOptions) ([]types.ConfigurationPolicy, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *PolicyServiceGetConfigurationPoliciesFunc) SetDefaultReturn(r0 []types.ConfigurationPolicy, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, shared.GetConfigurationPoliciesOptions) ([]types.ConfigurationPolicy, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *PolicyServiceGetConfigurationPoliciesFunc) PushReturn(r0 []types.ConfigurationPolicy, r1 int, r2 error) {
	f.PushHook(func(context.Context, shared.GetConfigurationPoliciesOptions) ([]types.ConfigurationPolicy, int, error) {
		return r0, r1, r2
	})
}

func (f *PolicyServiceGetConfigurationPoliciesFunc) nextHook() func(context.Context, shared.GetConfigurationPoliciesOptions) ([]types.ConfigurationPolicy, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *PolicyServiceGetConfigurationPoliciesFunc) appendCall(r0 PolicyServiceGetConfigurationPoliciesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// PolicyServiceGetConfigurationPoliciesFuncCall objects describing the
// invocations of this function.
func (f *PolicyServiceGetConfigurationPoliciesFunc) History() []PolicyServiceGetConfigurationPoliciesFuncCall {
	f.mutex.Lock()
	history := make([]PolicyServiceGetConfigurationPoliciesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// PolicyServiceGetConfigurationPoliciesFuncCall is an object that describes
// an invocation of method GetConfigurationPolicies on an instance of
// MockPolicyService.
type PolicyServiceGetConfigurationPoliciesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 shared.GetConfigurationPoliciesOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types.ConfigurationPolicy
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c PolicyServiceGetConfigurationPoliciesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c PolicyServiceGetConfigurationPoliciesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// MockStore is a mock implementation of the Store interface (from the
// package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/uploads/internal/store)
// used for unit testing.
type MockStore struct {
	// AddUploadPartFunc is an instance of a mock function object
	// controlling the behavior of the method AddUploadPart.
	AddUploadPartFunc *StoreAddUploadPartFunc
	// DeleteOldAuditLogsFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteOldAuditLogs.
	DeleteOldAuditLogsFunc *StoreDeleteOldAuditLogsFunc
	// DeleteOverlappingDumpsFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteOverlappingDumps.
	DeleteOverlappingDumpsFunc *StoreDeleteOverlappingDumpsFunc
	// DeleteSourcedCommitsFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteSourcedCommits.
	DeleteSourcedCommitsFunc *StoreDeleteSourcedCommitsFunc
	// DeleteUploadByIDFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteUploadByID.
	DeleteUploadByIDFunc *StoreDeleteUploadByIDFunc
	// DeleteUploadsFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteUploads.
	DeleteUploadsFunc *StoreDeleteUploadsFunc
	// DeleteUploadsStuckUploadingFunc is an instance of a mock function
	// object controlling the behavior of the method
	// DeleteUploadsStuckUploading.
	DeleteUploadsStuckUploadingFunc *StoreDeleteUploadsStuckUploadingFunc
	// DeleteUploadsWithoutRepositoryFunc is an instance of a mock function
	// object controlling the behavior of the method
	// DeleteUploadsWithoutRepository.
	DeleteUploadsWithoutRepositoryFunc *StoreDeleteUploadsWithoutRepositoryFunc
	// DoneFunc is an instance of a mock function object controlling the
	// behavior of the method Done.
	DoneFunc *StoreDoneFunc
	// FindClosestDumpsFunc is an instance of a mock function object
	// controlling the behavior of the method FindClosestDumps.
	FindClosestDumpsFunc *StoreFindClosestDumpsFunc
	// FindClosestDumpsFromGraphFragmentFunc is an instance of a mock
	// function object controlling the behavior of the method
	// FindClosestDumpsFromGraphFragment.
	FindClosestDumpsFromGraphFragmentFunc *StoreFindClosestDumpsFromGraphFragmentFunc
	// GetAuditLogsForUploadFunc is an instance of a mock function object
	// controlling the behavior of the method GetAuditLogsForUpload.
	GetAuditLogsForUploadFunc *StoreGetAuditLogsForUploadFunc
	// GetCommitGraphMetadataFunc is an instance of a mock function object
	// controlling the behavior of the method GetCommitGraphMetadata.
	GetCommitGraphMetadataFunc *StoreGetCommitGraphMetadataFunc
	// GetCommitsVisibleToUploadFunc is an instance of a mock function
	// object controlling the behavior of the method
	// GetCommitsVisibleToUpload.
	GetCommitsVisibleToUploadFunc *StoreGetCommitsVisibleToUploadFunc
	// GetDirtyRepositoriesFunc is an instance of a mock function object
	// controlling the behavior of the method GetDirtyRepositories.
	GetDirtyRepositoriesFunc *StoreGetDirtyRepositoriesFunc
	// GetDumpsByIDsFunc is an instance of a mock function object
	// controlling the behavior of the method GetDumpsByIDs.
	GetDumpsByIDsFunc *StoreGetDumpsByIDsFunc
	// GetDumpsWithDefinitionsForMonikersFunc is an instance of a mock
	// function object controlling the behavior of the method
	// GetDumpsWithDefinitionsForMonikers.
	GetDumpsWithDefinitionsForMonikersFunc *StoreGetDumpsWithDefinitionsForMonikersFunc
	// GetIndexersFunc is an instance of a mock function object controlling
	// the behavior of the method GetIndexers.
	GetIndexersFunc *StoreGetIndexersFunc
	// GetLastUploadRetentionScanForRepositoryFunc is an instance of a mock
	// function object controlling the behavior of the method
	// GetLastUploadRetentionScanForRepository.
	GetLastUploadRetentionScanForRepositoryFunc *StoreGetLastUploadRetentionScanForRepositoryFunc
	// GetOldestCommitDateFunc is an instance of a mock function object
	// controlling the behavior of the method GetOldestCommitDate.
	GetOldestCommitDateFunc *StoreGetOldestCommitDateFunc
	// GetRecentUploadsSummaryFunc is an instance of a mock function object
	// controlling the behavior of the method GetRecentUploadsSummary.
	GetRecentUploadsSummaryFunc *StoreGetRecentUploadsSummaryFunc
	// GetRepositoriesForIndexScanFunc is an instance of a mock function
	// object controlling the behavior of the method
	// GetRepositoriesForIndexScan.
	GetRepositoriesForIndexScanFunc *StoreGetRepositoriesForIndexScanFunc
	// GetRepositoriesMaxStaleAgeFunc is an instance of a mock function
	// object controlling the behavior of the method
	// GetRepositoriesMaxStaleAge.
	GetRepositoriesMaxStaleAgeFunc *StoreGetRepositoriesMaxStaleAgeFunc
	// GetStaleSourcedCommitsFunc is an instance of a mock function object
	// controlling the behavior of the method GetStaleSourcedCommits.
	GetStaleSourcedCommitsFunc *StoreGetStaleSourcedCommitsFunc
	// GetUploadByIDFunc is an instance of a mock function object
	// controlling the behavior of the method GetUploadByID.
	GetUploadByIDFunc *StoreGetUploadByIDFunc
	// GetUploadIDsWithReferencesFunc is an instance of a mock function
	// object controlling the behavior of the method
	// GetUploadIDsWithReferences.
	GetUploadIDsWithReferencesFunc *StoreGetUploadIDsWithReferencesFunc
	// GetUploadsFunc is an instance of a mock function object controlling
	// the behavior of the method GetUploads.
	GetUploadsFunc *StoreGetUploadsFunc
	// GetUploadsByIDsFunc is an instance of a mock function object
	// controlling the behavior of the method GetUploadsByIDs.
	GetUploadsByIDsFunc *StoreGetUploadsByIDsFunc
	// GetUploadsByIDsAllowDeletedFunc is an instance of a mock function
	// object controlling the behavior of the method
	// GetUploadsByIDsAllowDeleted.
	GetUploadsByIDsAllowDeletedFunc *StoreGetUploadsByIDsAllowDeletedFunc
	// GetUploadsForRankingFunc is an instance of a mock function object
	// controlling the behavior of the method GetUploadsForRanking.
	GetUploadsForRankingFunc *StoreGetUploadsForRankingFunc
	// GetVisibleUploadsMatchingMonikersFunc is an instance of a mock
	// function object controlling the behavior of the method
	// GetVisibleUploadsMatchingMonikers.
	GetVisibleUploadsMatchingMonikersFunc *StoreGetVisibleUploadsMatchingMonikersFunc
	// HardDeleteUploadsByIDsFunc is an instance of a mock function object
	// controlling the behavior of the method HardDeleteUploadsByIDs.
	HardDeleteUploadsByIDsFunc *StoreHardDeleteUploadsByIDsFunc
	// HasCommitFunc is an instance of a mock function object controlling
	// the behavior of the method HasCommit.
	HasCommitFunc *StoreHasCommitFunc
	// HasRepositoryFunc is an instance of a mock function object
	// controlling the behavior of the method HasRepository.
	HasRepositoryFunc *StoreHasRepositoryFunc
	// InsertDefinitionsForRankingFunc is an instance of a mock function
	// object controlling the behavior of the method
	// InsertDefinitionsForRanking.
	InsertDefinitionsForRankingFunc *StoreInsertDefinitionsForRankingFunc
	// InsertDependencySyncingJobFunc is an instance of a mock function
	// object controlling the behavior of the method
	// InsertDependencySyncingJob.
	InsertDependencySyncingJobFunc *StoreInsertDependencySyncingJobFunc
	// InsertPathCountInputsFunc is an instance of a mock function object
	// controlling the behavior of the method InsertPathCountInputs.
	InsertPathCountInputsFunc *StoreInsertPathCountInputsFunc
	// InsertPathRanksFunc is an instance of a mock function object
	// controlling the behavior of the method InsertPathRanks.
	InsertPathRanksFunc *StoreInsertPathRanksFunc
	// InsertReferencesForRankingFunc is an instance of a mock function
	// object controlling the behavior of the method
	// InsertReferencesForRanking.
	InsertReferencesForRankingFunc *StoreInsertReferencesForRankingFunc
	// InsertUploadFunc is an instance of a mock function object controlling
	// the behavior of the method InsertUpload.
	InsertUploadFunc *StoreInsertUploadFunc
	// MarkFailedFunc is an instance of a mock function object controlling
	// the behavior of the method MarkFailed.
	MarkFailedFunc *StoreMarkFailedFunc
	// MarkQueuedFunc is an instance of a mock function object controlling
	// the behavior of the method MarkQueued.
	MarkQueuedFunc *StoreMarkQueuedFunc
	// ProcessStaleExportedUploadsFunc is an instance of a mock function
	// object controlling the behavior of the method
	// ProcessStaleExportedUploads.
	ProcessStaleExportedUploadsFunc *StoreProcessStaleExportedUploadsFunc
	// ReconcileCandidatesFunc is an instance of a mock function object
	// controlling the behavior of the method ReconcileCandidates.
	ReconcileCandidatesFunc *StoreReconcileCandidatesFunc
	// ReferencesForUploadFunc is an instance of a mock function object
	// controlling the behavior of the method ReferencesForUpload.
	ReferencesForUploadFunc *StoreReferencesForUploadFunc
	// ReindexUploadByIDFunc is an instance of a mock function object
	// controlling the behavior of the method ReindexUploadByID.
	ReindexUploadByIDFunc *StoreReindexUploadByIDFunc
	// ReindexUploadsFunc is an instance of a mock function object
	// controlling the behavior of the method ReindexUploads.
	ReindexUploadsFunc *StoreReindexUploadsFunc
	// RepoNameFunc is an instance of a mock function object controlling the
	// behavior of the method RepoName.
	RepoNameFunc *StoreRepoNameFunc
	// RepoNamesFunc is an instance of a mock function object controlling
	// the behavior of the method RepoNames.
	RepoNamesFunc *StoreRepoNamesFunc
	// SetRepositoriesForRetentionScanFunc is an instance of a mock function
	// object controlling the behavior of the method
	// SetRepositoriesForRetentionScan.
	SetRepositoriesForRetentionScanFunc *StoreSetRepositoriesForRetentionScanFunc
	// SetRepositoriesForRetentionScanWithTimeFunc is an instance of a mock
	// function object controlling the behavior of the method
	// SetRepositoriesForRetentionScanWithTime.
	SetRepositoriesForRetentionScanWithTimeFunc *StoreSetRepositoriesForRetentionScanWithTimeFunc
	// SetRepositoryAsDirtyFunc is an instance of a mock function object
	// controlling the behavior of the method SetRepositoryAsDirty.
	SetRepositoryAsDirtyFunc *StoreSetRepositoryAsDirtyFunc
	// SoftDeleteExpiredUploadsFunc is an instance of a mock function object
	// controlling the behavior of the method SoftDeleteExpiredUploads.
	SoftDeleteExpiredUploadsFunc *StoreSoftDeleteExpiredUploadsFunc
	// SoftDeleteExpiredUploadsViaTraversalFunc is an instance of a mock
	// function object controlling the behavior of the method
	// SoftDeleteExpiredUploadsViaTraversal.
	SoftDeleteExpiredUploadsViaTraversalFunc *StoreSoftDeleteExpiredUploadsViaTraversalFunc
	// SourcedCommitsWithoutCommittedAtFunc is an instance of a mock
	// function object controlling the behavior of the method
	// SourcedCommitsWithoutCommittedAt.
	SourcedCommitsWithoutCommittedAtFunc *StoreSourcedCommitsWithoutCommittedAtFunc
	// TransactFunc is an instance of a mock function object controlling the
	// behavior of the method Transact.
	TransactFunc *StoreTransactFunc
	// UpdateCommittedAtFunc is an instance of a mock function object
	// controlling the behavior of the method UpdateCommittedAt.
	UpdateCommittedAtFunc *StoreUpdateCommittedAtFunc
	// UpdatePackageReferencesFunc is an instance of a mock function object
	// controlling the behavior of the method UpdatePackageReferences.
	UpdatePackageReferencesFunc *StoreUpdatePackageReferencesFunc
	// UpdatePackagesFunc is an instance of a mock function object
	// controlling the behavior of the method UpdatePackages.
	UpdatePackagesFunc *StoreUpdatePackagesFunc
	// UpdateSourcedCommitsFunc is an instance of a mock function object
	// controlling the behavior of the method UpdateSourcedCommits.
	UpdateSourcedCommitsFunc *StoreUpdateSourcedCommitsFunc
	// UpdateUploadRetentionFunc is an instance of a mock function object
	// controlling the behavior of the method UpdateUploadRetention.
	UpdateUploadRetentionFunc *StoreUpdateUploadRetentionFunc
	// UpdateUploadsVisibleToCommitsFunc is an instance of a mock function
	// object controlling the behavior of the method
	// UpdateUploadsVisibleToCommits.
	UpdateUploadsVisibleToCommitsFunc *StoreUpdateUploadsVisibleToCommitsFunc
	// VacuumStaleDefinitionsAndReferencesFunc is an instance of a mock
	// function object controlling the behavior of the method
	// VacuumStaleDefinitionsAndReferences.
	VacuumStaleDefinitionsAndReferencesFunc *StoreVacuumStaleDefinitionsAndReferencesFunc
	// VacuumStaleGraphsFunc is an instance of a mock function object
	// controlling the behavior of the method VacuumStaleGraphs.
	VacuumStaleGraphsFunc *StoreVacuumStaleGraphsFunc
	// WorkerutilStoreFunc is an instance of a mock function object
	// controlling the behavior of the method WorkerutilStore.
	WorkerutilStoreFunc *StoreWorkerutilStoreFunc
}

// NewMockStore creates a new mock of the Store interface. All methods
// return zero values for all results, unless overwritten.
func NewMockStore() *MockStore {
	return &MockStore{
		AddUploadPartFunc: &StoreAddUploadPartFunc{
			defaultHook: func(context.Context, int, int) (r0 error) {
				return
			},
		},
		DeleteOldAuditLogsFunc: &StoreDeleteOldAuditLogsFunc{
			defaultHook: func(context.Context, time.Duration, time.Time) (r0 int, r1 error) {
				return
			},
		},
		DeleteOverlappingDumpsFunc: &StoreDeleteOverlappingDumpsFunc{
			defaultHook: func(context.Context, int, string, string, string) (r0 error) {
				return
			},
		},
		DeleteSourcedCommitsFunc: &StoreDeleteSourcedCommitsFunc{
			defaultHook: func(context.Context, int, string, time.Duration, time.Time) (r0 int, r1 int, r2 error) {
				return
			},
		},
		DeleteUploadByIDFunc: &StoreDeleteUploadByIDFunc{
			defaultHook: func(context.Context, int) (r0 bool, r1 error) {
				return
			},
		},
		DeleteUploadsFunc: &StoreDeleteUploadsFunc{
			defaultHook: func(context.Context, shared1.DeleteUploadsOptions) (r0 error) {
				return
			},
		},
		DeleteUploadsStuckUploadingFunc: &StoreDeleteUploadsStuckUploadingFunc{
			defaultHook: func(context.Context, time.Time) (r0 int, r1 error) {
				return
			},
		},
		DeleteUploadsWithoutRepositoryFunc: &StoreDeleteUploadsWithoutRepositoryFunc{
			defaultHook: func(context.Context, time.Time) (r0 map[int]int, r1 error) {
				return
			},
		},
		DoneFunc: &StoreDoneFunc{
			defaultHook: func(error) (r0 error) {
				return
			},
		},
		FindClosestDumpsFunc: &StoreFindClosestDumpsFunc{
			defaultHook: func(context.Context, int, string, string, bool, string) (r0 []types.Dump, r1 error) {
				return
			},
		},
		FindClosestDumpsFromGraphFragmentFunc: &StoreFindClosestDumpsFromGraphFragmentFunc{
			defaultHook: func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) (r0 []types.Dump, r1 error) {
				return
			},
		},
		GetAuditLogsForUploadFunc: &StoreGetAuditLogsForUploadFunc{
			defaultHook: func(context.Context, int) (r0 []types.UploadLog, r1 error) {
				return
			},
		},
		GetCommitGraphMetadataFunc: &StoreGetCommitGraphMetadataFunc{
			defaultHook: func(context.Context, int) (r0 bool, r1 *time.Time, r2 error) {
				return
			},
		},
		GetCommitsVisibleToUploadFunc: &StoreGetCommitsVisibleToUploadFunc{
			defaultHook: func(context.Context, int, int, *string) (r0 []string, r1 *string, r2 error) {
				return
			},
		},
		GetDirtyRepositoriesFunc: &StoreGetDirtyRepositoriesFunc{
			defaultHook: func(context.Context) (r0 map[int]int, r1 error) {
				return
			},
		},
		GetDumpsByIDsFunc: &StoreGetDumpsByIDsFunc{
			defaultHook: func(context.Context, []int) (r0 []types.Dump, r1 error) {
				return
			},
		},
		GetDumpsWithDefinitionsForMonikersFunc: &StoreGetDumpsWithDefinitionsForMonikersFunc{
			defaultHook: func(context.Context, []precise.QualifiedMonikerData) (r0 []types.Dump, r1 error) {
				return
			},
		},
		GetIndexersFunc: &StoreGetIndexersFunc{
			defaultHook: func(context.Context, shared1.GetIndexersOptions) (r0 []string, r1 error) {
				return
			},
		},
		GetLastUploadRetentionScanForRepositoryFunc: &StoreGetLastUploadRetentionScanForRepositoryFunc{
			defaultHook: func(context.Context, int) (r0 *time.Time, r1 error) {
				return
			},
		},
		GetOldestCommitDateFunc: &StoreGetOldestCommitDateFunc{
			defaultHook: func(context.Context, int) (r0 time.Time, r1 bool, r2 error) {
				return
			},
		},
		GetRecentUploadsSummaryFunc: &StoreGetRecentUploadsSummaryFunc{
			defaultHook: func(context.Context, int) (r0 []shared1.UploadsWithRepositoryNamespace, r1 error) {
				return
			},
		},
		GetRepositoriesForIndexScanFunc: &StoreGetRepositoriesForIndexScanFunc{
			defaultHook: func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) (r0 []int, r1 error) {
				return
			},
		},
		GetRepositoriesMaxStaleAgeFunc: &StoreGetRepositoriesMaxStaleAgeFunc{
			defaultHook: func(context.Context) (r0 time.Duration, r1 error) {
				return
			},
		},
		GetStaleSourcedCommitsFunc: &StoreGetStaleSourcedCommitsFunc{
			defaultHook: func(context.Context, time.Duration, int, time.Time) (r0 []shared1.SourcedCommits, r1 error) {
				return
			},
		},
		GetUploadByIDFunc: &StoreGetUploadByIDFunc{
			defaultHook: func(context.Context, int) (r0 types.Upload, r1 bool, r2 error) {
				return
			},
		},
		GetUploadIDsWithReferencesFunc: &StoreGetUploadIDsWithReferencesFunc{
			defaultHook: func(context.Context, []precise.QualifiedMonikerData, []int, int, string, int, int, observation.TraceLogger) (r0 []int, r1 int, r2 int, r3 error) {
				return
			},
		},
		GetUploadsFunc: &StoreGetUploadsFunc{
			defaultHook: func(context.Context, shared1.GetUploadsOptions) (r0 []types.Upload, r1 int, r2 error) {
				return
			},
		},
		GetUploadsByIDsFunc: &StoreGetUploadsByIDsFunc{
			defaultHook: func(context.Context, ...int) (r0 []types.Upload, r1 error) {
				return
			},
		},
		GetUploadsByIDsAllowDeletedFunc: &StoreGetUploadsByIDsAllowDeletedFunc{
			defaultHook: func(context.Context, ...int) (r0 []types.Upload, r1 error) {
				return
			},
		},
		GetUploadsForRankingFunc: &StoreGetUploadsForRankingFunc{
			defaultHook: func(context.Context, string, string, int) (r0 []shared1.ExportedUpload, r1 error) {
				return
			},
		},
		GetVisibleUploadsMatchingMonikersFunc: &StoreGetVisibleUploadsMatchingMonikersFunc{
			defaultHook: func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (r0 shared1.PackageReferenceScanner, r1 int, r2 error) {
				return
			},
		},
		HardDeleteUploadsByIDsFunc: &StoreHardDeleteUploadsByIDsFunc{
			defaultHook: func(context.Context, ...int) (r0 error) {
				return
			},
		},
		HasCommitFunc: &StoreHasCommitFunc{
			defaultHook: func(context.Context, int, string) (r0 bool, r1 error) {
				return
			},
		},
		HasRepositoryFunc: &StoreHasRepositoryFunc{
			defaultHook: func(context.Context, int) (r0 bool, r1 error) {
				return
			},
		},
		InsertDefinitionsForRankingFunc: &StoreInsertDefinitionsForRankingFunc{
			defaultHook: func(context.Context, string, int, []shared1.RankingDefinitions) (r0 error) {
				return
			},
		},
		InsertDependencySyncingJobFunc: &StoreInsertDependencySyncingJobFunc{
			defaultHook: func(context.Context, int) (r0 int, r1 error) {
				return
			},
		},
		InsertPathCountInputsFunc: &StoreInsertPathCountInputsFunc{
			defaultHook: func(context.Context, string, int) (r0 int, r1 int, r2 error) {
				return
			},
		},
		InsertPathRanksFunc: &StoreInsertPathRanksFunc{
			defaultHook: func(context.Context, string, int) (r0 float64, r1 float64, r2 error) {
				return
			},
		},
		InsertReferencesForRankingFunc: &StoreInsertReferencesForRankingFunc{
			defaultHook: func(context.Context, string, int, shared1.RankingReferences) (r0 error) {
				return
			},
		},
		InsertUploadFunc: &StoreInsertUploadFunc{
			defaultHook: func(context.Context, types.Upload) (r0 int, r1 error) {
				return
			},
		},
		MarkFailedFunc: &StoreMarkFailedFunc{
			defaultHook: func(context.Context, int, string) (r0 error) {
				return
			},
		},
		MarkQueuedFunc: &StoreMarkQueuedFunc{
			defaultHook: func(context.Context, int, *int64) (r0 error) {
				return
			},
		},
		ProcessStaleExportedUploadsFunc: &StoreProcessStaleExportedUploadsFunc{
			defaultHook: func(context.Context, string, int, func(ctx context.Context, objectPrefix string) error) (r0 int, r1 error) {
				return
			},
		},
		ReconcileCandidatesFunc: &StoreReconcileCandidatesFunc{
			defaultHook: func(context.Context, int) (r0 []int, r1 error) {
				return
			},
		},
		ReferencesForUploadFunc: &StoreReferencesForUploadFunc{
			defaultHook: func(context.Context, int) (r0 shared1.PackageReferenceScanner, r1 error) {
				return
			},
		},
		ReindexUploadByIDFunc: &StoreReindexUploadByIDFunc{
			defaultHook: func(context.Context, int) (r0 error) {
				return
			},
		},
		ReindexUploadsFunc: &StoreReindexUploadsFunc{
			defaultHook: func(context.Context, shared1.ReindexUploadsOptions) (r0 error) {
				return
			},
		},
		RepoNameFunc: &StoreRepoNameFunc{
			defaultHook: func(context.Context, int) (r0 string, r1 error) {
				return
			},
		},
		RepoNamesFunc: &StoreRepoNamesFunc{
			defaultHook: func(context.Context, ...int) (r0 map[int]string, r1 error) {
				return
			},
		},
		SetRepositoriesForRetentionScanFunc: &StoreSetRepositoriesForRetentionScanFunc{
			defaultHook: func(context.Context, time.Duration, int) (r0 []int, r1 error) {
				return
			},
		},
		SetRepositoriesForRetentionScanWithTimeFunc: &StoreSetRepositoriesForRetentionScanWithTimeFunc{
			defaultHook: func(context.Context, time.Duration, int, time.Time) (r0 []int, r1 error) {
				return
			},
		},
		SetRepositoryAsDirtyFunc: &StoreSetRepositoryAsDirtyFunc{
			defaultHook: func(context.Context, int) (r0 error) {
				return
			},
		},
		SoftDeleteExpiredUploadsFunc: &StoreSoftDeleteExpiredUploadsFunc{
			defaultHook: func(context.Context, int) (r0 int, r1 error) {
				return
			},
		},
		SoftDeleteExpiredUploadsViaTraversalFunc: &StoreSoftDeleteExpiredUploadsViaTraversalFunc{
			defaultHook: func(context.Context, int) (r0 int, r1 error) {
				return
			},
		},
		SourcedCommitsWithoutCommittedAtFunc: &StoreSourcedCommitsWithoutCommittedAtFunc{
			defaultHook: func(context.Context, int) (r0 []shared1.SourcedCommits, r1 error) {
				return
			},
		},
		TransactFunc: &StoreTransactFunc{
			defaultHook: func(context.Context) (r0 store.Store, r1 error) {
				return
			},
		},
		UpdateCommittedAtFunc: &StoreUpdateCommittedAtFunc{
			defaultHook: func(context.Context, int, string, string) (r0 error) {
				return
			},
		},
		UpdatePackageReferencesFunc: &StoreUpdatePackageReferencesFunc{
			defaultHook: func(context.Context, int, []precise.PackageReference) (r0 error) {
				return
			},
		},
		UpdatePackagesFunc: &StoreUpdatePackagesFunc{
			defaultHook: func(context.Context, int, []precise.Package) (r0 error) {
				return
			},
		},
		UpdateSourcedCommitsFunc: &StoreUpdateSourcedCommitsFunc{
			defaultHook: func(context.Context, int, string, time.Time) (r0 int, r1 error) {
				return
			},
		},
		UpdateUploadRetentionFunc: &StoreUpdateUploadRetentionFunc{
			defaultHook: func(context.Context, []int, []int) (r0 error) {
				return
			},
		},
		UpdateUploadsVisibleToCommitsFunc: &StoreUpdateUploadsVisibleToCommitsFunc{
			defaultHook: func(context.Context, int, *gitdomain.CommitGraph, map[string][]gitdomain.RefDescription, time.Duration, time.Duration, int, time.Time) (r0 error) {
				return
			},
		},
		VacuumStaleDefinitionsAndReferencesFunc: &StoreVacuumStaleDefinitionsAndReferencesFunc{
			defaultHook: func(context.Context, string) (r0 int, r1 int, r2 error) {
				return
			},
		},
		VacuumStaleGraphsFunc: &StoreVacuumStaleGraphsFunc{
			defaultHook: func(context.Context, string) (r0 int, r1 int, r2 error) {
				return
			},
		},
		WorkerutilStoreFunc: &StoreWorkerutilStoreFunc{
			defaultHook: func(*observation.Context) (r0 store1.Store[types.Upload]) {
				return
			},
		},
	}
}

// NewStrictMockStore creates a new mock of the Store interface. All methods
// panic on invocation, unless overwritten.
func NewStrictMockStore() *MockStore {
	return &MockStore{
		AddUploadPartFunc: &StoreAddUploadPartFunc{
			defaultHook: func(context.Context, int, int) error {
				panic("unexpected invocation of MockStore.AddUploadPart")
			},
		},
		DeleteOldAuditLogsFunc: &StoreDeleteOldAuditLogsFunc{
			defaultHook: func(context.Context, time.Duration, time.Time) (int, error) {
				panic("unexpected invocation of MockStore.DeleteOldAuditLogs")
			},
		},
		DeleteOverlappingDumpsFunc: &StoreDeleteOverlappingDumpsFunc{
			defaultHook: func(context.Context, int, string, string, string) error {
				panic("unexpected invocation of MockStore.DeleteOverlappingDumps")
			},
		},
		DeleteSourcedCommitsFunc: &StoreDeleteSourcedCommitsFunc{
			defaultHook: func(context.Context, int, string, time.Duration, time.Time) (int, int, error) {
				panic("unexpected invocation of MockStore.DeleteSourcedCommits")
			},
		},
		DeleteUploadByIDFunc: &StoreDeleteUploadByIDFunc{
			defaultHook: func(context.Context, int) (bool, error) {
				panic("unexpected invocation of MockStore.DeleteUploadByID")
			},
		},
		DeleteUploadsFunc: &StoreDeleteUploadsFunc{
			defaultHook: func(context.Context, shared1.DeleteUploadsOptions) error {
				panic("unexpected invocation of MockStore.DeleteUploads")
			},
		},
		DeleteUploadsStuckUploadingFunc: &StoreDeleteUploadsStuckUploadingFunc{
			defaultHook: func(context.Context, time.Time) (int, error) {
				panic("unexpected invocation of MockStore.DeleteUploadsStuckUploading")
			},
		},
		DeleteUploadsWithoutRepositoryFunc: &StoreDeleteUploadsWithoutRepositoryFunc{
			defaultHook: func(context.Context, time.Time) (map[int]int, error) {
				panic("unexpected invocation of MockStore.DeleteUploadsWithoutRepository")
			},
		},
		DoneFunc: &StoreDoneFunc{
			defaultHook: func(error) error {
				panic("unexpected invocation of MockStore.Done")
			},
		},
		FindClosestDumpsFunc: &StoreFindClosestDumpsFunc{
			defaultHook: func(context.Context, int, string, string, bool, string) ([]types.Dump, error) {
				panic("unexpected invocation of MockStore.FindClosestDumps")
			},
		},
		FindClosestDumpsFromGraphFragmentFunc: &StoreFindClosestDumpsFromGraphFragmentFunc{
			defaultHook: func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) ([]types.Dump, error) {
				panic("unexpected invocation of MockStore.FindClosestDumpsFromGraphFragment")
			},
		},
		GetAuditLogsForUploadFunc: &StoreGetAuditLogsForUploadFunc{
			defaultHook: func(context.Context, int) ([]types.UploadLog, error) {
				panic("unexpected invocation of MockStore.GetAuditLogsForUpload")
			},
		},
		GetCommitGraphMetadataFunc: &StoreGetCommitGraphMetadataFunc{
			defaultHook: func(context.Context, int) (bool, *time.Time, error) {
				panic("unexpected invocation of MockStore.GetCommitGraphMetadata")
			},
		},
		GetCommitsVisibleToUploadFunc: &StoreGetCommitsVisibleToUploadFunc{
			defaultHook: func(context.Context, int, int, *string) ([]string, *string, error) {
				panic("unexpected invocation of MockStore.GetCommitsVisibleToUpload")
			},
		},
		GetDirtyRepositoriesFunc: &StoreGetDirtyRepositoriesFunc{
			defaultHook: func(context.Context) (map[int]int, error) {
				panic("unexpected invocation of MockStore.GetDirtyRepositories")
			},
		},
		GetDumpsByIDsFunc: &StoreGetDumpsByIDsFunc{
			defaultHook: func(context.Context, []int) ([]types.Dump, error) {
				panic("unexpected invocation of MockStore.GetDumpsByIDs")
			},
		},
		GetDumpsWithDefinitionsForMonikersFunc: &StoreGetDumpsWithDefinitionsForMonikersFunc{
			defaultHook: func(context.Context, []precise.QualifiedMonikerData) ([]types.Dump, error) {
				panic("unexpected invocation of MockStore.GetDumpsWithDefinitionsForMonikers")
			},
		},
		GetIndexersFunc: &StoreGetIndexersFunc{
			defaultHook: func(context.Context, shared1.GetIndexersOptions) ([]string, error) {
				panic("unexpected invocation of MockStore.GetIndexers")
			},
		},
		GetLastUploadRetentionScanForRepositoryFunc: &StoreGetLastUploadRetentionScanForRepositoryFunc{
			defaultHook: func(context.Context, int) (*time.Time, error) {
				panic("unexpected invocation of MockStore.GetLastUploadRetentionScanForRepository")
			},
		},
		GetOldestCommitDateFunc: &StoreGetOldestCommitDateFunc{
			defaultHook: func(context.Context, int) (time.Time, bool, error) {
				panic("unexpected invocation of MockStore.GetOldestCommitDate")
			},
		},
		GetRecentUploadsSummaryFunc: &StoreGetRecentUploadsSummaryFunc{
			defaultHook: func(context.Context, int) ([]shared1.UploadsWithRepositoryNamespace, error) {
				panic("unexpected invocation of MockStore.GetRecentUploadsSummary")
			},
		},
		GetRepositoriesForIndexScanFunc: &StoreGetRepositoriesForIndexScanFunc{
			defaultHook: func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) ([]int, error) {
				panic("unexpected invocation of MockStore.GetRepositoriesForIndexScan")
			},
		},
		GetRepositoriesMaxStaleAgeFunc: &StoreGetRepositoriesMaxStaleAgeFunc{
			defaultHook: func(context.Context) (time.Duration, error) {
				panic("unexpected invocation of MockStore.GetRepositoriesMaxStaleAge")
			},
		},
		GetStaleSourcedCommitsFunc: &StoreGetStaleSourcedCommitsFunc{
			defaultHook: func(context.Context, time.Duration, int, time.Time) ([]shared1.SourcedCommits, error) {
				panic("unexpected invocation of MockStore.GetStaleSourcedCommits")
			},
		},
		GetUploadByIDFunc: &StoreGetUploadByIDFunc{
			defaultHook: func(context.Context, int) (types.Upload, bool, error) {
				panic("unexpected invocation of MockStore.GetUploadByID")
			},
		},
		GetUploadIDsWithReferencesFunc: &StoreGetUploadIDsWithReferencesFunc{
			defaultHook: func(context.Context, []precise.QualifiedMonikerData, []int, int, string, int, int, observation.TraceLogger) ([]int, int, int, error) {
				panic("unexpected invocation of MockStore.GetUploadIDsWithReferences")
			},
		},
		GetUploadsFunc: &StoreGetUploadsFunc{
			defaultHook: func(context.Context, shared1.GetUploadsOptions) ([]types.Upload, int, error) {
				panic("unexpected invocation of MockStore.GetUploads")
			},
		},
		GetUploadsByIDsFunc: &StoreGetUploadsByIDsFunc{
			defaultHook: func(context.Context, ...int) ([]types.Upload, error) {
				panic("unexpected invocation of MockStore.GetUploadsByIDs")
			},
		},
		GetUploadsByIDsAllowDeletedFunc: &StoreGetUploadsByIDsAllowDeletedFunc{
			defaultHook: func(context.Context, ...int) ([]types.Upload, error) {
				panic("unexpected invocation of MockStore.GetUploadsByIDsAllowDeleted")
			},
		},
		GetUploadsForRankingFunc: &StoreGetUploadsForRankingFunc{
			defaultHook: func(context.Context, string, string, int) ([]shared1.ExportedUpload, error) {
				panic("unexpected invocation of MockStore.GetUploadsForRanking")
			},
		},
		GetVisibleUploadsMatchingMonikersFunc: &StoreGetVisibleUploadsMatchingMonikersFunc{
			defaultHook: func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (shared1.PackageReferenceScanner, int, error) {
				panic("unexpected invocation of MockStore.GetVisibleUploadsMatchingMonikers")
			},
		},
		HardDeleteUploadsByIDsFunc: &StoreHardDeleteUploadsByIDsFunc{
			defaultHook: func(context.Context, ...int) error {
				panic("unexpected invocation of MockStore.HardDeleteUploadsByIDs")
			},
		},
		HasCommitFunc: &StoreHasCommitFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				panic("unexpected invocation of MockStore.HasCommit")
			},
		},
		HasRepositoryFunc: &StoreHasRepositoryFunc{
			defaultHook: func(context.Context, int) (bool, error) {
				panic("unexpected invocation of MockStore.HasRepository")
			},
		},
		InsertDefinitionsForRankingFunc: &StoreInsertDefinitionsForRankingFunc{
			defaultHook: func(context.Context, string, int, []shared1.RankingDefinitions) error {
				panic("unexpected invocation of MockStore.InsertDefinitionsForRanking")
			},
		},
		InsertDependencySyncingJobFunc: &StoreInsertDependencySyncingJobFunc{
			defaultHook: func(context.Context, int) (int, error) {
				panic("unexpected invocation of MockStore.InsertDependencySyncingJob")
			},
		},
		InsertPathCountInputsFunc: &StoreInsertPathCountInputsFunc{
			defaultHook: func(context.Context, string, int) (int, int, error) {
				panic("unexpected invocation of MockStore.InsertPathCountInputs")
			},
		},
		InsertPathRanksFunc: &StoreInsertPathRanksFunc{
			defaultHook: func(context.Context, string, int) (float64, float64, error) {
				panic("unexpected invocation of MockStore.InsertPathRanks")
			},
		},
		InsertReferencesForRankingFunc: &StoreInsertReferencesForRankingFunc{
			defaultHook: func(context.Context, string, int, shared1.RankingReferences) error {
				panic("unexpected invocation of MockStore.InsertReferencesForRanking")
			},
		},
		InsertUploadFunc: &StoreInsertUploadFunc{
			defaultHook: func(context.Context, types.Upload) (int, error) {
				panic("unexpected invocation of MockStore.InsertUpload")
			},
		},
		MarkFailedFunc: &StoreMarkFailedFunc{
			defaultHook: func(context.Context, int, string) error {
				panic("unexpected invocation of MockStore.MarkFailed")
			},
		},
		MarkQueuedFunc: &StoreMarkQueuedFunc{
			defaultHook: func(context.Context, int, *int64) error {
				panic("unexpected invocation of MockStore.MarkQueued")
			},
		},
		ProcessStaleExportedUploadsFunc: &StoreProcessStaleExportedUploadsFunc{
			defaultHook: func(context.Context, string, int, func(ctx context.Context, objectPrefix string) error) (int, error) {
				panic("unexpected invocation of MockStore.ProcessStaleExportedUploads")
			},
		},
		ReconcileCandidatesFunc: &StoreReconcileCandidatesFunc{
			defaultHook: func(context.Context, int) ([]int, error) {
				panic("unexpected invocation of MockStore.ReconcileCandidates")
			},
		},
		ReferencesForUploadFunc: &StoreReferencesForUploadFunc{
			defaultHook: func(context.Context, int) (shared1.PackageReferenceScanner, error) {
				panic("unexpected invocation of MockStore.ReferencesForUpload")
			},
		},
		ReindexUploadByIDFunc: &StoreReindexUploadByIDFunc{
			defaultHook: func(context.Context, int) error {
				panic("unexpected invocation of MockStore.ReindexUploadByID")
			},
		},
		ReindexUploadsFunc: &StoreReindexUploadsFunc{
			defaultHook: func(context.Context, shared1.ReindexUploadsOptions) error {
				panic("unexpected invocation of MockStore.ReindexUploads")
			},
		},
		RepoNameFunc: &StoreRepoNameFunc{
			defaultHook: func(context.Context, int) (string, error) {
				panic("unexpected invocation of MockStore.RepoName")
			},
		},
		RepoNamesFunc: &StoreRepoNamesFunc{
			defaultHook: func(context.Context, ...int) (map[int]string, error) {
				panic("unexpected invocation of MockStore.RepoNames")
			},
		},
		SetRepositoriesForRetentionScanFunc: &StoreSetRepositoriesForRetentionScanFunc{
			defaultHook: func(context.Context, time.Duration, int) ([]int, error) {
				panic("unexpected invocation of MockStore.SetRepositoriesForRetentionScan")
			},
		},
		SetRepositoriesForRetentionScanWithTimeFunc: &StoreSetRepositoriesForRetentionScanWithTimeFunc{
			defaultHook: func(context.Context, time.Duration, int, time.Time) ([]int, error) {
				panic("unexpected invocation of MockStore.SetRepositoriesForRetentionScanWithTime")
			},
		},
		SetRepositoryAsDirtyFunc: &StoreSetRepositoryAsDirtyFunc{
			defaultHook: func(context.Context, int) error {
				panic("unexpected invocation of MockStore.SetRepositoryAsDirty")
			},
		},
		SoftDeleteExpiredUploadsFunc: &StoreSoftDeleteExpiredUploadsFunc{
			defaultHook: func(context.Context, int) (int, error) {
				panic("unexpected invocation of MockStore.SoftDeleteExpiredUploads")
			},
		},
		SoftDeleteExpiredUploadsViaTraversalFunc: &StoreSoftDeleteExpiredUploadsViaTraversalFunc{
			defaultHook: func(context.Context, int) (int, error) {
				panic("unexpected invocation of MockStore.SoftDeleteExpiredUploadsViaTraversal")
			},
		},
		SourcedCommitsWithoutCommittedAtFunc: &StoreSourcedCommitsWithoutCommittedAtFunc{
			defaultHook: func(context.Context, int) ([]shared1.SourcedCommits, error) {
				panic("unexpected invocation of MockStore.SourcedCommitsWithoutCommittedAt")
			},
		},
		TransactFunc: &StoreTransactFunc{
			defaultHook: func(context.Context) (store.Store, error) {
				panic("unexpected invocation of MockStore.Transact")
			},
		},
		UpdateCommittedAtFunc: &StoreUpdateCommittedAtFunc{
			defaultHook: func(context.Context, int, string, string) error {
				panic("unexpected invocation of MockStore.UpdateCommittedAt")
			},
		},
		UpdatePackageReferencesFunc: &StoreUpdatePackageReferencesFunc{
			defaultHook: func(context.Context, int, []precise.PackageReference) error {
				panic("unexpected invocation of MockStore.UpdatePackageReferences")
			},
		},
		UpdatePackagesFunc: &StoreUpdatePackagesFunc{
			defaultHook: func(context.Context, int, []precise.Package) error {
				panic("unexpected invocation of MockStore.UpdatePackages")
			},
		},
		UpdateSourcedCommitsFunc: &StoreUpdateSourcedCommitsFunc{
			defaultHook: func(context.Context, int, string, time.Time) (int, error) {
				panic("unexpected invocation of MockStore.UpdateSourcedCommits")
			},
		},
		UpdateUploadRetentionFunc: &StoreUpdateUploadRetentionFunc{
			defaultHook: func(context.Context, []int, []int) error {
				panic("unexpected invocation of MockStore.UpdateUploadRetention")
			},
		},
		UpdateUploadsVisibleToCommitsFunc: &StoreUpdateUploadsVisibleToCommitsFunc{
			defaultHook: func(context.Context, int, *gitdomain.CommitGraph, map[string][]gitdomain.RefDescription, time.Duration, time.Duration, int, time.Time) error {
				panic("unexpected invocation of MockStore.UpdateUploadsVisibleToCommits")
			},
		},
		VacuumStaleDefinitionsAndReferencesFunc: &StoreVacuumStaleDefinitionsAndReferencesFunc{
			defaultHook: func(context.Context, string) (int, int, error) {
				panic("unexpected invocation of MockStore.VacuumStaleDefinitionsAndReferences")
			},
		},
		VacuumStaleGraphsFunc: &StoreVacuumStaleGraphsFunc{
			defaultHook: func(context.Context, string) (int, int, error) {
				panic("unexpected invocation of MockStore.VacuumStaleGraphs")
			},
		},
		WorkerutilStoreFunc: &StoreWorkerutilStoreFunc{
			defaultHook: func(*observation.Context) store1.Store[types.Upload] {
				panic("unexpected invocation of MockStore.WorkerutilStore")
			},
		},
	}
}

// NewMockStoreFrom creates a new mock of the MockStore interface. All
// methods delegate to the given implementation, unless overwritten.
func NewMockStoreFrom(i store.Store) *MockStore {
	return &MockStore{
		AddUploadPartFunc: &StoreAddUploadPartFunc{
			defaultHook: i.AddUploadPart,
		},
		DeleteOldAuditLogsFunc: &StoreDeleteOldAuditLogsFunc{
			defaultHook: i.DeleteOldAuditLogs,
		},
		DeleteOverlappingDumpsFunc: &StoreDeleteOverlappingDumpsFunc{
			defaultHook: i.DeleteOverlappingDumps,
		},
		DeleteSourcedCommitsFunc: &StoreDeleteSourcedCommitsFunc{
			defaultHook: i.DeleteSourcedCommits,
		},
		DeleteUploadByIDFunc: &StoreDeleteUploadByIDFunc{
			defaultHook: i.DeleteUploadByID,
		},
		DeleteUploadsFunc: &StoreDeleteUploadsFunc{
			defaultHook: i.DeleteUploads,
		},
		DeleteUploadsStuckUploadingFunc: &StoreDeleteUploadsStuckUploadingFunc{
			defaultHook: i.DeleteUploadsStuckUploading,
		},
		DeleteUploadsWithoutRepositoryFunc: &StoreDeleteUploadsWithoutRepositoryFunc{
			defaultHook: i.DeleteUploadsWithoutRepository,
		},
		DoneFunc: &StoreDoneFunc{
			defaultHook: i.Done,
		},
		FindClosestDumpsFunc: &StoreFindClosestDumpsFunc{
			defaultHook: i.FindClosestDumps,
		},
		FindClosestDumpsFromGraphFragmentFunc: &StoreFindClosestDumpsFromGraphFragmentFunc{
			defaultHook: i.FindClosestDumpsFromGraphFragment,
		},
		GetAuditLogsForUploadFunc: &StoreGetAuditLogsForUploadFunc{
			defaultHook: i.GetAuditLogsForUpload,
		},
		GetCommitGraphMetadataFunc: &StoreGetCommitGraphMetadataFunc{
			defaultHook: i.GetCommitGraphMetadata,
		},
		GetCommitsVisibleToUploadFunc: &StoreGetCommitsVisibleToUploadFunc{
			defaultHook: i.GetCommitsVisibleToUpload,
		},
		GetDirtyRepositoriesFunc: &StoreGetDirtyRepositoriesFunc{
			defaultHook: i.GetDirtyRepositories,
		},
		GetDumpsByIDsFunc: &StoreGetDumpsByIDsFunc{
			defaultHook: i.GetDumpsByIDs,
		},
		GetDumpsWithDefinitionsForMonikersFunc: &StoreGetDumpsWithDefinitionsForMonikersFunc{
			defaultHook: i.GetDumpsWithDefinitionsForMonikers,
		},
		GetIndexersFunc: &StoreGetIndexersFunc{
			defaultHook: i.GetIndexers,
		},
		GetLastUploadRetentionScanForRepositoryFunc: &StoreGetLastUploadRetentionScanForRepositoryFunc{
			defaultHook: i.GetLastUploadRetentionScanForRepository,
		},
		GetOldestCommitDateFunc: &StoreGetOldestCommitDateFunc{
			defaultHook: i.GetOldestCommitDate,
		},
		GetRecentUploadsSummaryFunc: &StoreGetRecentUploadsSummaryFunc{
			defaultHook: i.GetRecentUploadsSummary,
		},
		GetRepositoriesForIndexScanFunc: &StoreGetRepositoriesForIndexScanFunc{
			defaultHook: i.GetRepositoriesForIndexScan,
		},
		GetRepositoriesMaxStaleAgeFunc: &StoreGetRepositoriesMaxStaleAgeFunc{
			defaultHook: i.GetRepositoriesMaxStaleAge,
		},
		GetStaleSourcedCommitsFunc: &StoreGetStaleSourcedCommitsFunc{
			defaultHook: i.GetStaleSourcedCommits,
		},
		GetUploadByIDFunc: &StoreGetUploadByIDFunc{
			defaultHook: i.GetUploadByID,
		},
		GetUploadIDsWithReferencesFunc: &StoreGetUploadIDsWithReferencesFunc{
			defaultHook: i.GetUploadIDsWithReferences,
		},
		GetUploadsFunc: &StoreGetUploadsFunc{
			defaultHook: i.GetUploads,
		},
		GetUploadsByIDsFunc: &StoreGetUploadsByIDsFunc{
			defaultHook: i.GetUploadsByIDs,
		},
		GetUploadsByIDsAllowDeletedFunc: &StoreGetUploadsByIDsAllowDeletedFunc{
			defaultHook: i.GetUploadsByIDsAllowDeleted,
		},
		GetUploadsForRankingFunc: &StoreGetUploadsForRankingFunc{
			defaultHook: i.GetUploadsForRanking,
		},
		GetVisibleUploadsMatchingMonikersFunc: &StoreGetVisibleUploadsMatchingMonikersFunc{
			defaultHook: i.GetVisibleUploadsMatchingMonikers,
		},
		HardDeleteUploadsByIDsFunc: &StoreHardDeleteUploadsByIDsFunc{
			defaultHook: i.HardDeleteUploadsByIDs,
		},
		HasCommitFunc: &StoreHasCommitFunc{
			defaultHook: i.HasCommit,
		},
		HasRepositoryFunc: &StoreHasRepositoryFunc{
			defaultHook: i.HasRepository,
		},
		InsertDefinitionsForRankingFunc: &StoreInsertDefinitionsForRankingFunc{
			defaultHook: i.InsertDefinitionsForRanking,
		},
		InsertDependencySyncingJobFunc: &StoreInsertDependencySyncingJobFunc{
			defaultHook: i.InsertDependencySyncingJob,
		},
		InsertPathCountInputsFunc: &StoreInsertPathCountInputsFunc{
			defaultHook: i.InsertPathCountInputs,
		},
		InsertPathRanksFunc: &StoreInsertPathRanksFunc{
			defaultHook: i.InsertPathRanks,
		},
		InsertReferencesForRankingFunc: &StoreInsertReferencesForRankingFunc{
			defaultHook: i.InsertReferencesForRanking,
		},
		InsertUploadFunc: &StoreInsertUploadFunc{
			defaultHook: i.InsertUpload,
		},
		MarkFailedFunc: &StoreMarkFailedFunc{
			defaultHook: i.MarkFailed,
		},
		MarkQueuedFunc: &StoreMarkQueuedFunc{
			defaultHook: i.MarkQueued,
		},
		ProcessStaleExportedUploadsFunc: &StoreProcessStaleExportedUploadsFunc{
			defaultHook: i.ProcessStaleExportedUploads,
		},
		ReconcileCandidatesFunc: &StoreReconcileCandidatesFunc{
			defaultHook: i.ReconcileCandidates,
		},
		ReferencesForUploadFunc: &StoreReferencesForUploadFunc{
			defaultHook: i.ReferencesForUpload,
		},
		ReindexUploadByIDFunc: &StoreReindexUploadByIDFunc{
			defaultHook: i.ReindexUploadByID,
		},
		ReindexUploadsFunc: &StoreReindexUploadsFunc{
			defaultHook: i.ReindexUploads,
		},
		RepoNameFunc: &StoreRepoNameFunc{
			defaultHook: i.RepoName,
		},
		RepoNamesFunc: &StoreRepoNamesFunc{
			defaultHook: i.RepoNames,
		},
		SetRepositoriesForRetentionScanFunc: &StoreSetRepositoriesForRetentionScanFunc{
			defaultHook: i.SetRepositoriesForRetentionScan,
		},
		SetRepositoriesForRetentionScanWithTimeFunc: &StoreSetRepositoriesForRetentionScanWithTimeFunc{
			defaultHook: i.SetRepositoriesForRetentionScanWithTime,
		},
		SetRepositoryAsDirtyFunc: &StoreSetRepositoryAsDirtyFunc{
			defaultHook: i.SetRepositoryAsDirty,
		},
		SoftDeleteExpiredUploadsFunc: &StoreSoftDeleteExpiredUploadsFunc{
			defaultHook: i.SoftDeleteExpiredUploads,
		},
		SoftDeleteExpiredUploadsViaTraversalFunc: &StoreSoftDeleteExpiredUploadsViaTraversalFunc{
			defaultHook: i.SoftDeleteExpiredUploadsViaTraversal,
		},
		SourcedCommitsWithoutCommittedAtFunc: &StoreSourcedCommitsWithoutCommittedAtFunc{
			defaultHook: i.SourcedCommitsWithoutCommittedAt,
		},
		TransactFunc: &StoreTransactFunc{
			defaultHook: i.Transact,
		},
		UpdateCommittedAtFunc: &StoreUpdateCommittedAtFunc{
			defaultHook: i.UpdateCommittedAt,
		},
		UpdatePackageReferencesFunc: &StoreUpdatePackageReferencesFunc{
			defaultHook: i.UpdatePackageReferences,
		},
		UpdatePackagesFunc: &StoreUpdatePackagesFunc{
			defaultHook: i.UpdatePackages,
		},
		UpdateSourcedCommitsFunc: &StoreUpdateSourcedCommitsFunc{
			defaultHook: i.UpdateSourcedCommits,
		},
		UpdateUploadRetentionFunc: &StoreUpdateUploadRetentionFunc{
			defaultHook: i.UpdateUploadRetention,
		},
		UpdateUploadsVisibleToCommitsFunc: &StoreUpdateUploadsVisibleToCommitsFunc{
			defaultHook: i.UpdateUploadsVisibleToCommits,
		},
		VacuumStaleDefinitionsAndReferencesFunc: &StoreVacuumStaleDefinitionsAndReferencesFunc{
			defaultHook: i.VacuumStaleDefinitionsAndReferences,
		},
		VacuumStaleGraphsFunc: &StoreVacuumStaleGraphsFunc{
			defaultHook: i.VacuumStaleGraphs,
		},
		WorkerutilStoreFunc: &StoreWorkerutilStoreFunc{
			defaultHook: i.WorkerutilStore,
		},
	}
}

// StoreAddUploadPartFunc describes the behavior when the AddUploadPart
// method of the parent MockStore instance is invoked.
type StoreAddUploadPartFunc struct {
	defaultHook func(context.Context, int, int) error
	hooks       []func(context.Context, int, int) error
	history     []StoreAddUploadPartFuncCall
	mutex       sync.Mutex
}

// AddUploadPart delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) AddUploadPart(v0 context.Context, v1 int, v2 int) error {
	r0 := m.AddUploadPartFunc.nextHook()(v0, v1, v2)
	m.AddUploadPartFunc.appendCall(StoreAddUploadPartFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the AddUploadPart method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreAddUploadPartFunc) SetDefaultHook(hook func(context.Context, int, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// AddUploadPart method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreAddUploadPartFunc) PushHook(hook func(context.Context, int, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreAddUploadPartFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, int) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreAddUploadPartFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, int) error {
		return r0
	})
}

func (f *StoreAddUploadPartFunc) nextHook() func(context.Context, int, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreAddUploadPartFunc) appendCall(r0 StoreAddUploadPartFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreAddUploadPartFuncCall objects
// describing the invocations of this function.
func (f *StoreAddUploadPartFunc) History() []StoreAddUploadPartFuncCall {
	f.mutex.Lock()
	history := make([]StoreAddUploadPartFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreAddUploadPartFuncCall is an object that describes an invocation of
// method AddUploadPart on an instance of MockStore.
type StoreAddUploadPartFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreAddUploadPartFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreAddUploadPartFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreDeleteOldAuditLogsFunc describes the behavior when the
// DeleteOldAuditLogs method of the parent MockStore instance is invoked.
type StoreDeleteOldAuditLogsFunc struct {
	defaultHook func(context.Context, time.Duration, time.Time) (int, error)
	hooks       []func(context.Context, time.Duration, time.Time) (int, error)
	history     []StoreDeleteOldAuditLogsFuncCall
	mutex       sync.Mutex
}

// DeleteOldAuditLogs delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) DeleteOldAuditLogs(v0 context.Context, v1 time.Duration, v2 time.Time) (int, error) {
	r0, r1 := m.DeleteOldAuditLogsFunc.nextHook()(v0, v1, v2)
	m.DeleteOldAuditLogsFunc.appendCall(StoreDeleteOldAuditLogsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DeleteOldAuditLogs
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreDeleteOldAuditLogsFunc) SetDefaultHook(hook func(context.Context, time.Duration, time.Time) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteOldAuditLogs method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreDeleteOldAuditLogsFunc) PushHook(hook func(context.Context, time.Duration, time.Time) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreDeleteOldAuditLogsFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Duration, time.Time) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreDeleteOldAuditLogsFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, time.Duration, time.Time) (int, error) {
		return r0, r1
	})
}

func (f *StoreDeleteOldAuditLogsFunc) nextHook() func(context.Context, time.Duration, time.Time) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteOldAuditLogsFunc) appendCall(r0 StoreDeleteOldAuditLogsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteOldAuditLogsFuncCall objects
// describing the invocations of this function.
func (f *StoreDeleteOldAuditLogsFunc) History() []StoreDeleteOldAuditLogsFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteOldAuditLogsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteOldAuditLogsFuncCall is an object that describes an invocation
// of method DeleteOldAuditLogs on an instance of MockStore.
type StoreDeleteOldAuditLogsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Duration
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteOldAuditLogsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteOldAuditLogsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreDeleteOverlappingDumpsFunc describes the behavior when the
// DeleteOverlappingDumps method of the parent MockStore instance is
// invoked.
type StoreDeleteOverlappingDumpsFunc struct {
	defaultHook func(context.Context, int, string, string, string) error
	hooks       []func(context.Context, int, string, string, string) error
	history     []StoreDeleteOverlappingDumpsFuncCall
	mutex       sync.Mutex
}

// DeleteOverlappingDumps delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) DeleteOverlappingDumps(v0 context.Context, v1 int, v2 string, v3 string, v4 string) error {
	r0 := m.DeleteOverlappingDumpsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.DeleteOverlappingDumpsFunc.appendCall(StoreDeleteOverlappingDumpsFuncCall{v0, v1, v2, v3, v4, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// DeleteOverlappingDumps method of the parent MockStore instance is invoked
// and the hook queue is empty.
func (f *StoreDeleteOverlappingDumpsFunc) SetDefaultHook(hook func(context.Context, int, string, string, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteOverlappingDumps method of the parent MockStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreDeleteOverlappingDumpsFunc) PushHook(hook func(context.Context, int, string, string, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreDeleteOverlappingDumpsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, string) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreDeleteOverlappingDumpsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string, string, string) error {
		return r0
	})
}

func (f *StoreDeleteOverlappingDumpsFunc) nextHook() func(context.Context, int, string, string, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteOverlappingDumpsFunc) appendCall(r0 StoreDeleteOverlappingDumpsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteOverlappingDumpsFuncCall objects
// describing the invocations of this function.
func (f *StoreDeleteOverlappingDumpsFunc) History() []StoreDeleteOverlappingDumpsFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteOverlappingDumpsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteOverlappingDumpsFuncCall is an object that describes an
// invocation of method DeleteOverlappingDumps on an instance of MockStore.
type StoreDeleteOverlappingDumpsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteOverlappingDumpsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteOverlappingDumpsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreDeleteSourcedCommitsFunc describes the behavior when the
// DeleteSourcedCommits method of the parent MockStore instance is invoked.
type StoreDeleteSourcedCommitsFunc struct {
	defaultHook func(context.Context, int, string, time.Duration, time.Time) (int, int, error)
	hooks       []func(context.Context, int, string, time.Duration, time.Time) (int, int, error)
	history     []StoreDeleteSourcedCommitsFuncCall
	mutex       sync.Mutex
}

// DeleteSourcedCommits delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) DeleteSourcedCommits(v0 context.Context, v1 int, v2 string, v3 time.Duration, v4 time.Time) (int, int, error) {
	r0, r1, r2 := m.DeleteSourcedCommitsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.DeleteSourcedCommitsFunc.appendCall(StoreDeleteSourcedCommitsFuncCall{v0, v1, v2, v3, v4, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the DeleteSourcedCommits
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreDeleteSourcedCommitsFunc) SetDefaultHook(hook func(context.Context, int, string, time.Duration, time.Time) (int, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteSourcedCommits method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreDeleteSourcedCommitsFunc) PushHook(hook func(context.Context, int, string, time.Duration, time.Time) (int, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreDeleteSourcedCommitsFunc) SetDefaultReturn(r0 int, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, time.Duration, time.Time) (int, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreDeleteSourcedCommitsFunc) PushReturn(r0 int, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string, time.Duration, time.Time) (int, int, error) {
		return r0, r1, r2
	})
}

func (f *StoreDeleteSourcedCommitsFunc) nextHook() func(context.Context, int, string, time.Duration, time.Time) (int, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteSourcedCommitsFunc) appendCall(r0 StoreDeleteSourcedCommitsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteSourcedCommitsFuncCall objects
// describing the invocations of this function.
func (f *StoreDeleteSourcedCommitsFunc) History() []StoreDeleteSourcedCommitsFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteSourcedCommitsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteSourcedCommitsFuncCall is an object that describes an
// invocation of method DeleteSourcedCommits on an instance of MockStore.
type StoreDeleteSourcedCommitsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 time.Duration
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteSourcedCommitsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteSourcedCommitsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreDeleteUploadByIDFunc describes the behavior when the
// DeleteUploadByID method of the parent MockStore instance is invoked.
type StoreDeleteUploadByIDFunc struct {
	defaultHook func(context.Context, int) (bool, error)
	hooks       []func(context.Context, int) (bool, error)
	history     []StoreDeleteUploadByIDFuncCall
	mutex       sync.Mutex
}

// DeleteUploadByID delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) DeleteUploadByID(v0 context.Context, v1 int) (bool, error) {
	r0, r1 := m.DeleteUploadByIDFunc.nextHook()(v0, v1)
	m.DeleteUploadByIDFunc.appendCall(StoreDeleteUploadByIDFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DeleteUploadByID
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreDeleteUploadByIDFunc) SetDefaultHook(hook func(context.Context, int) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteUploadByID method of the parent MockStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreDeleteUploadByIDFunc) PushHook(hook func(context.Context, int) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreDeleteUploadByIDFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreDeleteUploadByIDFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

func (f *StoreDeleteUploadByIDFunc) nextHook() func(context.Context, int) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteUploadByIDFunc) appendCall(r0 StoreDeleteUploadByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteUploadByIDFuncCall objects
// describing the invocations of this function.
func (f *StoreDeleteUploadByIDFunc) History() []StoreDeleteUploadByIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteUploadByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteUploadByIDFuncCall is an object that describes an invocation
// of method DeleteUploadByID on an instance of MockStore.
type StoreDeleteUploadByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteUploadByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteUploadByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreDeleteUploadsFunc describes the behavior when the DeleteUploads
// method of the parent MockStore instance is invoked.
type StoreDeleteUploadsFunc struct {
	defaultHook func(context.Context, shared1.DeleteUploadsOptions) error
	hooks       []func(context.Context, shared1.DeleteUploadsOptions) error
	history     []StoreDeleteUploadsFuncCall
	mutex       sync.Mutex
}

// DeleteUploads delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) DeleteUploads(v0 context.Context, v1 shared1.DeleteUploadsOptions) error {
	r0 := m.DeleteUploadsFunc.nextHook()(v0, v1)
	m.DeleteUploadsFunc.appendCall(StoreDeleteUploadsFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the DeleteUploads method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreDeleteUploadsFunc) SetDefaultHook(hook func(context.Context, shared1.DeleteUploadsOptions) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteUploads method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreDeleteUploadsFunc) PushHook(hook func(context.Context, shared1.DeleteUploadsOptions) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreDeleteUploadsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, shared1.DeleteUploadsOptions) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreDeleteUploadsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, shared1.DeleteUploadsOptions) error {
		return r0
	})
}

func (f *StoreDeleteUploadsFunc) nextHook() func(context.Context, shared1.DeleteUploadsOptions) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteUploadsFunc) appendCall(r0 StoreDeleteUploadsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteUploadsFuncCall objects
// describing the invocations of this function.
func (f *StoreDeleteUploadsFunc) History() []StoreDeleteUploadsFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteUploadsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteUploadsFuncCall is an object that describes an invocation of
// method DeleteUploads on an instance of MockStore.
type StoreDeleteUploadsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 shared1.DeleteUploadsOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteUploadsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteUploadsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreDeleteUploadsStuckUploadingFunc describes the behavior when the
// DeleteUploadsStuckUploading method of the parent MockStore instance is
// invoked.
type StoreDeleteUploadsStuckUploadingFunc struct {
	defaultHook func(context.Context, time.Time) (int, error)
	hooks       []func(context.Context, time.Time) (int, error)
	history     []StoreDeleteUploadsStuckUploadingFuncCall
	mutex       sync.Mutex
}

// DeleteUploadsStuckUploading delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) DeleteUploadsStuckUploading(v0 context.Context, v1 time.Time) (int, error) {
	r0, r1 := m.DeleteUploadsStuckUploadingFunc.nextHook()(v0, v1)
	m.DeleteUploadsStuckUploadingFunc.appendCall(StoreDeleteUploadsStuckUploadingFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// DeleteUploadsStuckUploading method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreDeleteUploadsStuckUploadingFunc) SetDefaultHook(hook func(context.Context, time.Time) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteUploadsStuckUploading method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreDeleteUploadsStuckUploadingFunc) PushHook(hook func(context.Context, time.Time) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreDeleteUploadsStuckUploadingFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Time) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreDeleteUploadsStuckUploadingFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, time.Time) (int, error) {
		return r0, r1
	})
}

func (f *StoreDeleteUploadsStuckUploadingFunc) nextHook() func(context.Context, time.Time) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteUploadsStuckUploadingFunc) appendCall(r0 StoreDeleteUploadsStuckUploadingFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteUploadsStuckUploadingFuncCall
// objects describing the invocations of this function.
func (f *StoreDeleteUploadsStuckUploadingFunc) History() []StoreDeleteUploadsStuckUploadingFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteUploadsStuckUploadingFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteUploadsStuckUploadingFuncCall is an object that describes an
// invocation of method DeleteUploadsStuckUploading on an instance of
// MockStore.
type StoreDeleteUploadsStuckUploadingFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteUploadsStuckUploadingFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteUploadsStuckUploadingFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreDeleteUploadsWithoutRepositoryFunc describes the behavior when the
// DeleteUploadsWithoutRepository method of the parent MockStore instance is
// invoked.
type StoreDeleteUploadsWithoutRepositoryFunc struct {
	defaultHook func(context.Context, time.Time) (map[int]int, error)
	hooks       []func(context.Context, time.Time) (map[int]int, error)
	history     []StoreDeleteUploadsWithoutRepositoryFuncCall
	mutex       sync.Mutex
}

// DeleteUploadsWithoutRepository delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) DeleteUploadsWithoutRepository(v0 context.Context, v1 time.Time) (map[int]int, error) {
	r0, r1 := m.DeleteUploadsWithoutRepositoryFunc.nextHook()(v0, v1)
	m.DeleteUploadsWithoutRepositoryFunc.appendCall(StoreDeleteUploadsWithoutRepositoryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// DeleteUploadsWithoutRepository method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreDeleteUploadsWithoutRepositoryFunc) SetDefaultHook(hook func(context.Context, time.Time) (map[int]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteUploadsWithoutRepository method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreDeleteUploadsWithoutRepositoryFunc) PushHook(hook func(context.Context, time.Time) (map[int]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreDeleteUploadsWithoutRepositoryFunc) SetDefaultReturn(r0 map[int]int, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Time) (map[int]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreDeleteUploadsWithoutRepositoryFunc) PushReturn(r0 map[int]int, r1 error) {
	f.PushHook(func(context.Context, time.Time) (map[int]int, error) {
		return r0, r1
	})
}

func (f *StoreDeleteUploadsWithoutRepositoryFunc) nextHook() func(context.Context, time.Time) (map[int]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteUploadsWithoutRepositoryFunc) appendCall(r0 StoreDeleteUploadsWithoutRepositoryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteUploadsWithoutRepositoryFuncCall
// objects describing the invocations of this function.
func (f *StoreDeleteUploadsWithoutRepositoryFunc) History() []StoreDeleteUploadsWithoutRepositoryFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteUploadsWithoutRepositoryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteUploadsWithoutRepositoryFuncCall is an object that describes
// an invocation of method DeleteUploadsWithoutRepository on an instance of
// MockStore.
type StoreDeleteUploadsWithoutRepositoryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[int]int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteUploadsWithoutRepositoryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteUploadsWithoutRepositoryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreDoneFunc describes the behavior when the Done method of the parent
// MockStore instance is invoked.
type StoreDoneFunc struct {
	defaultHook func(error) error
	hooks       []func(error) error
	history     []StoreDoneFuncCall
	mutex       sync.Mutex
}

// Done delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Done(v0 error) error {
	r0 := m.DoneFunc.nextHook()(v0)
	m.DoneFunc.appendCall(StoreDoneFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Done method of the
// parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreDoneFunc) SetDefaultHook(hook func(error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Done method of the parent MockStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreDoneFunc) PushHook(hook func(error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreDoneFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(error) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreDoneFunc) PushReturn(r0 error) {
	f.PushHook(func(error) error {
		return r0
	})
}

func (f *StoreDoneFunc) nextHook() func(error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDoneFunc) appendCall(r0 StoreDoneFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDoneFuncCall objects describing the
// invocations of this function.
func (f *StoreDoneFunc) History() []StoreDoneFuncCall {
	f.mutex.Lock()
	history := make([]StoreDoneFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDoneFuncCall is an object that describes an invocation of method
// Done on an instance of MockStore.
type StoreDoneFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDoneFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDoneFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreFindClosestDumpsFunc describes the behavior when the
// FindClosestDumps method of the parent MockStore instance is invoked.
type StoreFindClosestDumpsFunc struct {
	defaultHook func(context.Context, int, string, string, bool, string) ([]types.Dump, error)
	hooks       []func(context.Context, int, string, string, bool, string) ([]types.Dump, error)
	history     []StoreFindClosestDumpsFuncCall
	mutex       sync.Mutex
}

// FindClosestDumps delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) FindClosestDumps(v0 context.Context, v1 int, v2 string, v3 string, v4 bool, v5 string) ([]types.Dump, error) {
	r0, r1 := m.FindClosestDumpsFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.FindClosestDumpsFunc.appendCall(StoreFindClosestDumpsFuncCall{v0, v1, v2, v3, v4, v5, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the FindClosestDumps
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreFindClosestDumpsFunc) SetDefaultHook(hook func(context.Context, int, string, string, bool, string) ([]types.Dump, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// FindClosestDumps method of the parent MockStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreFindClosestDumpsFunc) PushHook(hook func(context.Context, int, string, string, bool, string) ([]types.Dump, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreFindClosestDumpsFunc) SetDefaultReturn(r0 []types.Dump, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, bool, string) ([]types.Dump, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreFindClosestDumpsFunc) PushReturn(r0 []types.Dump, r1 error) {
	f.PushHook(func(context.Context, int, string, string, bool, string) ([]types.Dump, error) {
		return r0, r1
	})
}

func (f *StoreFindClosestDumpsFunc) nextHook() func(context.Context, int, string, string, bool, string) ([]types.Dump, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreFindClosestDumpsFunc) appendCall(r0 StoreFindClosestDumpsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreFindClosestDumpsFuncCall objects
// describing the invocations of this function.
func (f *StoreFindClosestDumpsFunc) History() []StoreFindClosestDumpsFuncCall {
	f.mutex.Lock()
	history := make([]StoreFindClosestDumpsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreFindClosestDumpsFuncCall is an object that describes an invocation
// of method FindClosestDumps on an instance of MockStore.
type StoreFindClosestDumpsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 bool
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreFindClosestDumpsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreFindClosestDumpsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreFindClosestDumpsFromGraphFragmentFunc describes the behavior when
// the FindClosestDumpsFromGraphFragment method of the parent MockStore
// instance is invoked.
type StoreFindClosestDumpsFromGraphFragmentFunc struct {
	defaultHook func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) ([]types.Dump, error)
	hooks       []func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) ([]types.Dump, error)
	history     []StoreFindClosestDumpsFromGraphFragmentFuncCall
	mutex       sync.Mutex
}

// FindClosestDumpsFromGraphFragment delegates to the next hook function in
// the queue and stores the parameter and result values of this invocation.
func (m *MockStore) FindClosestDumpsFromGraphFragment(v0 context.Context, v1 int, v2 string, v3 string, v4 bool, v5 string, v6 *gitdomain.CommitGraph) ([]types.Dump, error) {
	r0, r1 := m.FindClosestDumpsFromGraphFragmentFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6)
	m.FindClosestDumpsFromGraphFragmentFunc.appendCall(StoreFindClosestDumpsFromGraphFragmentFuncCall{v0, v1, v2, v3, v4, v5, v6, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// FindClosestDumpsFromGraphFragment method of the parent MockStore instance
// is invoked and the hook queue is empty.
func (f *StoreFindClosestDumpsFromGraphFragmentFunc) SetDefaultHook(hook func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) ([]types.Dump, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// FindClosestDumpsFromGraphFragment method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreFindClosestDumpsFromGraphFragmentFunc) PushHook(hook func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) ([]types.Dump, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreFindClosestDumpsFromGraphFragmentFunc) SetDefaultReturn(r0 []types.Dump, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) ([]types.Dump, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreFindClosestDumpsFromGraphFragmentFunc) PushReturn(r0 []types.Dump, r1 error) {
	f.PushHook(func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) ([]types.Dump, error) {
		return r0, r1
	})
}

func (f *StoreFindClosestDumpsFromGraphFragmentFunc) nextHook() func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) ([]types.Dump, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreFindClosestDumpsFromGraphFragmentFunc) appendCall(r0 StoreFindClosestDumpsFromGraphFragmentFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// StoreFindClosestDumpsFromGraphFragmentFuncCall objects describing the
// invocations of this function.
func (f *StoreFindClosestDumpsFromGraphFragmentFunc) History() []StoreFindClosestDumpsFromGraphFragmentFuncCall {
	f.mutex.Lock()
	history := make([]StoreFindClosestDumpsFromGraphFragmentFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreFindClosestDumpsFromGraphFragmentFuncCall is an object that
// describes an invocation of method FindClosestDumpsFromGraphFragment on an
// instance of MockStore.
type StoreFindClosestDumpsFromGraphFragmentFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 bool
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 string
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 *gitdomain.CommitGraph
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreFindClosestDumpsFromGraphFragmentFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreFindClosestDumpsFromGraphFragmentFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetAuditLogsForUploadFunc describes the behavior when the
// GetAuditLogsForUpload method of the parent MockStore instance is invoked.
type StoreGetAuditLogsForUploadFunc struct {
	defaultHook func(context.Context, int) ([]types.UploadLog, error)
	hooks       []func(context.Context, int) ([]types.UploadLog, error)
	history     []StoreGetAuditLogsForUploadFuncCall
	mutex       sync.Mutex
}

// GetAuditLogsForUpload delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) GetAuditLogsForUpload(v0 context.Context, v1 int) ([]types.UploadLog, error) {
	r0, r1 := m.GetAuditLogsForUploadFunc.nextHook()(v0, v1)
	m.GetAuditLogsForUploadFunc.appendCall(StoreGetAuditLogsForUploadFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// GetAuditLogsForUpload method of the parent MockStore instance is invoked
// and the hook queue is empty.
func (f *StoreGetAuditLogsForUploadFunc) SetDefaultHook(hook func(context.Context, int) ([]types.UploadLog, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetAuditLogsForUpload method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreGetAuditLogsForUploadFunc) PushHook(hook func(context.Context, int) ([]types.UploadLog, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetAuditLogsForUploadFunc) SetDefaultReturn(r0 []types.UploadLog, r1 error) {
	f.SetDefaultHook(func(context.Context, int) ([]types.UploadLog, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetAuditLogsForUploadFunc) PushReturn(r0 []types.UploadLog, r1 error) {
	f.PushHook(func(context.Context, int) ([]types.UploadLog, error) {
		return r0, r1
	})
}

func (f *StoreGetAuditLogsForUploadFunc) nextHook() func(context.Context, int) ([]types.UploadLog, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetAuditLogsForUploadFunc) appendCall(r0 StoreGetAuditLogsForUploadFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetAuditLogsForUploadFuncCall objects
// describing the invocations of this function.
func (f *StoreGetAuditLogsForUploadFunc) History() []StoreGetAuditLogsForUploadFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetAuditLogsForUploadFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetAuditLogsForUploadFuncCall is an object that describes an
// invocation of method GetAuditLogsForUpload on an instance of MockStore.
type StoreGetAuditLogsForUploadFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types.UploadLog
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetAuditLogsForUploadFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetAuditLogsForUploadFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetCommitGraphMetadataFunc describes the behavior when the
// GetCommitGraphMetadata method of the parent MockStore instance is
// invoked.
type StoreGetCommitGraphMetadataFunc struct {
	defaultHook func(context.Context, int) (bool, *time.Time, error)
	hooks       []func(context.Context, int) (bool, *time.Time, error)
	history     []StoreGetCommitGraphMetadataFuncCall
	mutex       sync.Mutex
}

// GetCommitGraphMetadata delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) GetCommitGraphMetadata(v0 context.Context, v1 int) (bool, *time.Time, error) {
	r0, r1, r2 := m.GetCommitGraphMetadataFunc.nextHook()(v0, v1)
	m.GetCommitGraphMetadataFunc.appendCall(StoreGetCommitGraphMetadataFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// GetCommitGraphMetadata method of the parent MockStore instance is invoked
// and the hook queue is empty.
func (f *StoreGetCommitGraphMetadataFunc) SetDefaultHook(hook func(context.Context, int) (bool, *time.Time, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetCommitGraphMetadata method of the parent MockStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreGetCommitGraphMetadataFunc) PushHook(hook func(context.Context, int) (bool, *time.Time, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetCommitGraphMetadataFunc) SetDefaultReturn(r0 bool, r1 *time.Time, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (bool, *time.Time, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetCommitGraphMetadataFunc) PushReturn(r0 bool, r1 *time.Time, r2 error) {
	f.PushHook(func(context.Context, int) (bool, *time.Time, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetCommitGraphMetadataFunc) nextHook() func(context.Context, int) (bool, *time.Time, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetCommitGraphMetadataFunc) appendCall(r0 StoreGetCommitGraphMetadataFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetCommitGraphMetadataFuncCall objects
// describing the invocations of this function.
func (f *StoreGetCommitGraphMetadataFunc) History() []StoreGetCommitGraphMetadataFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetCommitGraphMetadataFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetCommitGraphMetadataFuncCall is an object that describes an
// invocation of method GetCommitGraphMetadata on an instance of MockStore.
type StoreGetCommitGraphMetadataFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 *time.Time
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetCommitGraphMetadataFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetCommitGraphMetadataFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetCommitsVisibleToUploadFunc describes the behavior when the
// GetCommitsVisibleToUpload method of the parent MockStore instance is
// invoked.
type StoreGetCommitsVisibleToUploadFunc struct {
	defaultHook func(context.Context, int, int, *string) ([]string, *string, error)
	hooks       []func(context.Context, int, int, *string) ([]string, *string, error)
	history     []StoreGetCommitsVisibleToUploadFuncCall
	mutex       sync.Mutex
}

// GetCommitsVisibleToUpload delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) GetCommitsVisibleToUpload(v0 context.Context, v1 int, v2 int, v3 *string) ([]string, *string, error) {
	r0, r1, r2 := m.GetCommitsVisibleToUploadFunc.nextHook()(v0, v1, v2, v3)
	m.GetCommitsVisibleToUploadFunc.appendCall(StoreGetCommitsVisibleToUploadFuncCall{v0, v1, v2, v3, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// GetCommitsVisibleToUpload method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreGetCommitsVisibleToUploadFunc) SetDefaultHook(hook func(context.Context, int, int, *string) ([]string, *string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetCommitsVisibleToUpload method of the parent MockStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreGetCommitsVisibleToUploadFunc) PushHook(hook func(context.Context, int, int, *string) ([]string, *string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetCommitsVisibleToUploadFunc) SetDefaultReturn(r0 []string, r1 *string, r2 error) {
	f.SetDefaultHook(func(context.Context, int, int, *string) ([]string, *string, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetCommitsVisibleToUploadFunc) PushReturn(r0 []string, r1 *string, r2 error) {
	f.PushHook(func(context.Context, int, int, *string) ([]string, *string, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetCommitsVisibleToUploadFunc) nextHook() func(context.Context, int, int, *string) ([]string, *string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetCommitsVisibleToUploadFunc) appendCall(r0 StoreGetCommitsVisibleToUploadFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetCommitsVisibleToUploadFuncCall
// objects describing the invocations of this function.
func (f *StoreGetCommitsVisibleToUploadFunc) History() []StoreGetCommitsVisibleToUploadFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetCommitsVisibleToUploadFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetCommitsVisibleToUploadFuncCall is an object that describes an
// invocation of method GetCommitsVisibleToUpload on an instance of
// MockStore.
type StoreGetCommitsVisibleToUploadFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 *string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 *string
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetCommitsVisibleToUploadFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetCommitsVisibleToUploadFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetDirtyRepositoriesFunc describes the behavior when the
// GetDirtyRepositories method of the parent MockStore instance is invoked.
type StoreGetDirtyRepositoriesFunc struct {
	defaultHook func(context.Context) (map[int]int, error)
	hooks       []func(context.Context) (map[int]int, error)
	history     []StoreGetDirtyRepositoriesFuncCall
	mutex       sync.Mutex
}

// GetDirtyRepositories delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) GetDirtyRepositories(v0 context.Context) (map[int]int, error) {
	r0, r1 := m.GetDirtyRepositoriesFunc.nextHook()(v0)
	m.GetDirtyRepositoriesFunc.appendCall(StoreGetDirtyRepositoriesFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetDirtyRepositories
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreGetDirtyRepositoriesFunc) SetDefaultHook(hook func(context.Context) (map[int]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetDirtyRepositories method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreGetDirtyRepositoriesFunc) PushHook(hook func(context.Context) (map[int]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetDirtyRepositoriesFunc) SetDefaultReturn(r0 map[int]int, r1 error) {
	f.SetDefaultHook(func(context.Context) (map[int]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetDirtyRepositoriesFunc) PushReturn(r0 map[int]int, r1 error) {
	f.PushHook(func(context.Context) (map[int]int, error) {
		return r0, r1
	})
}

func (f *StoreGetDirtyRepositoriesFunc) nextHook() func(context.Context) (map[int]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetDirtyRepositoriesFunc) appendCall(r0 StoreGetDirtyRepositoriesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetDirtyRepositoriesFuncCall objects
// describing the invocations of this function.
func (f *StoreGetDirtyRepositoriesFunc) History() []StoreGetDirtyRepositoriesFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetDirtyRepositoriesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetDirtyRepositoriesFuncCall is an object that describes an
// invocation of method GetDirtyRepositories on an instance of MockStore.
type StoreGetDirtyRepositoriesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[int]int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetDirtyRepositoriesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetDirtyRepositoriesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetDumpsByIDsFunc describes the behavior when the GetDumpsByIDs
// method of the parent MockStore instance is invoked.
type StoreGetDumpsByIDsFunc struct {
	defaultHook func(context.Context, []int) ([]types.Dump, error)
	hooks       []func(context.Context, []int) ([]types.Dump, error)
	history     []StoreGetDumpsByIDsFuncCall
	mutex       sync.Mutex
}

// GetDumpsByIDs delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetDumpsByIDs(v0 context.Context, v1 []int) ([]types.Dump, error) {
	r0, r1 := m.GetDumpsByIDsFunc.nextHook()(v0, v1)
	m.GetDumpsByIDsFunc.appendCall(StoreGetDumpsByIDsFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetDumpsByIDs method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetDumpsByIDsFunc) SetDefaultHook(hook func(context.Context, []int) ([]types.Dump, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetDumpsByIDs method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetDumpsByIDsFunc) PushHook(hook func(context.Context, []int) ([]types.Dump, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetDumpsByIDsFunc) SetDefaultReturn(r0 []types.Dump, r1 error) {
	f.SetDefaultHook(func(context.Context, []int) ([]types.Dump, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetDumpsByIDsFunc) PushReturn(r0 []types.Dump, r1 error) {
	f.PushHook(func(context.Context, []int) ([]types.Dump, error) {
		return r0, r1
	})
}

func (f *StoreGetDumpsByIDsFunc) nextHook() func(context.Context, []int) ([]types.Dump, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetDumpsByIDsFunc) appendCall(r0 StoreGetDumpsByIDsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetDumpsByIDsFuncCall objects
// describing the invocations of this function.
func (f *StoreGetDumpsByIDsFunc) History() []StoreGetDumpsByIDsFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetDumpsByIDsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetDumpsByIDsFuncCall is an object that describes an invocation of
// method GetDumpsByIDs on an instance of MockStore.
type StoreGetDumpsByIDsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetDumpsByIDsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetDumpsByIDsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetDumpsWithDefinitionsForMonikersFunc describes the behavior when
// the GetDumpsWithDefinitionsForMonikers method of the parent MockStore
// instance is invoked.
type StoreGetDumpsWithDefinitionsForMonikersFunc struct {
	defaultHook func(context.Context, []precise.QualifiedMonikerData) ([]types.Dump, error)
	hooks       []func(context.Context, []precise.QualifiedMonikerData) ([]types.Dump, error)
	history     []StoreGetDumpsWithDefinitionsForMonikersFuncCall
	mutex       sync.Mutex
}

// GetDumpsWithDefinitionsForMonikers delegates to the next hook function in
// the queue and stores the parameter and result values of this invocation.
func (m *MockStore) GetDumpsWithDefinitionsForMonikers(v0 context.Context, v1 []precise.QualifiedMonikerData) ([]types.Dump, error) {
	r0, r1 := m.GetDumpsWithDefinitionsForMonikersFunc.nextHook()(v0, v1)
	m.GetDumpsWithDefinitionsForMonikersFunc.appendCall(StoreGetDumpsWithDefinitionsForMonikersFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// GetDumpsWithDefinitionsForMonikers method of the parent MockStore
// instance is invoked and the hook queue is empty.
func (f *StoreGetDumpsWithDefinitionsForMonikersFunc) SetDefaultHook(hook func(context.Context, []precise.QualifiedMonikerData) ([]types.Dump, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetDumpsWithDefinitionsForMonikers method of the parent MockStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *StoreGetDumpsWithDefinitionsForMonikersFunc) PushHook(hook func(context.Context, []precise.QualifiedMonikerData) ([]types.Dump, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetDumpsWithDefinitionsForMonikersFunc) SetDefaultReturn(r0 []types.Dump, r1 error) {
	f.SetDefaultHook(func(context.Context, []precise.QualifiedMonikerData) ([]types.Dump, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetDumpsWithDefinitionsForMonikersFunc) PushReturn(r0 []types.Dump, r1 error) {
	f.PushHook(func(context.Context, []precise.QualifiedMonikerData) ([]types.Dump, error) {
		return r0, r1
	})
}

func (f *StoreGetDumpsWithDefinitionsForMonikersFunc) nextHook() func(context.Context, []precise.QualifiedMonikerData) ([]types.Dump, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetDumpsWithDefinitionsForMonikersFunc) appendCall(r0 StoreGetDumpsWithDefinitionsForMonikersFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// StoreGetDumpsWithDefinitionsForMonikersFuncCall objects describing the
// invocations of this function.
func (f *StoreGetDumpsWithDefinitionsForMonikersFunc) History() []StoreGetDumpsWithDefinitionsForMonikersFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetDumpsWithDefinitionsForMonikersFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetDumpsWithDefinitionsForMonikersFuncCall is an object that
// describes an invocation of method GetDumpsWithDefinitionsForMonikers on
// an instance of MockStore.
type StoreGetDumpsWithDefinitionsForMonikersFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []precise.QualifiedMonikerData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetDumpsWithDefinitionsForMonikersFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetDumpsWithDefinitionsForMonikersFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetIndexersFunc describes the behavior when the GetIndexers method
// of the parent MockStore instance is invoked.
type StoreGetIndexersFunc struct {
	defaultHook func(context.Context, shared1.GetIndexersOptions) ([]string, error)
	hooks       []func(context.Context, shared1.GetIndexersOptions) ([]string, error)
	history     []StoreGetIndexersFuncCall
	mutex       sync.Mutex
}

// GetIndexers delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetIndexers(v0 context.Context, v1 shared1.GetIndexersOptions) ([]string, error) {
	r0, r1 := m.GetIndexersFunc.nextHook()(v0, v1)
	m.GetIndexersFunc.appendCall(StoreGetIndexersFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetIndexers method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetIndexersFunc) SetDefaultHook(hook func(context.Context, shared1.GetIndexersOptions) ([]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexers method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetIndexersFunc) PushHook(hook func(context.Context, shared1.GetIndexersOptions) ([]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetIndexersFunc) SetDefaultReturn(r0 []string, r1 error) {
	f.SetDefaultHook(func(context.Context, shared1.GetIndexersOptions) ([]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetIndexersFunc) PushReturn(r0 []string, r1 error) {
	f.PushHook(func(context.Context, shared1.GetIndexersOptions) ([]string, error) {
		return r0, r1
	})
}

func (f *StoreGetIndexersFunc) nextHook() func(context.Context, shared1.GetIndexersOptions) ([]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetIndexersFunc) appendCall(r0 StoreGetIndexersFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetIndexersFuncCall objects describing
// the invocations of this function.
func (f *StoreGetIndexersFunc) History() []StoreGetIndexersFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetIndexersFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetIndexersFuncCall is an object that describes an invocation of
// method GetIndexers on an instance of MockStore.
type StoreGetIndexersFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 shared1.GetIndexersOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetIndexersFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetIndexersFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetLastUploadRetentionScanForRepositoryFunc describes the behavior
// when the GetLastUploadRetentionScanForRepository method of the parent
// MockStore instance is invoked.
type StoreGetLastUploadRetentionScanForRepositoryFunc struct {
	defaultHook func(context.Context, int) (*time.Time, error)
	hooks       []func(context.Context, int) (*time.Time, error)
	history     []StoreGetLastUploadRetentionScanForRepositoryFuncCall
	mutex       sync.Mutex
}

// GetLastUploadRetentionScanForRepository delegates to the next hook
// function in the queue and stores the parameter and result values of this
// invocation.
func (m *MockStore) GetLastUploadRetentionScanForRepository(v0 context.Context, v1 int) (*time.Time, error) {
	r0, r1 := m.GetLastUploadRetentionScanForRepositoryFunc.nextHook()(v0, v1)
	m.GetLastUploadRetentionScanForRepositoryFunc.appendCall(StoreGetLastUploadRetentionScanForRepositoryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// GetLastUploadRetentionScanForRepository method of the parent MockStore
// instance is invoked and the hook queue is empty.
func (f *StoreGetLastUploadRetentionScanForRepositoryFunc) SetDefaultHook(hook func(context.Context, int) (*time.Time, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetLastUploadRetentionScanForRepository method of the parent MockStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *StoreGetLastUploadRetentionScanForRepositoryFunc) PushHook(hook func(context.Context, int) (*time.Time, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetLastUploadRetentionScanForRepositoryFunc) SetDefaultReturn(r0 *time.Time, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (*time.Time, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetLastUploadRetentionScanForRepositoryFunc) PushReturn(r0 *time.Time, r1 error) {
	f.PushHook(func(context.Context, int) (*time.Time, error) {
		return r0, r1
	})
}

func (f *StoreGetLastUploadRetentionScanForRepositoryFunc) nextHook() func(context.Context, int) (*time.Time, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetLastUploadRetentionScanForRepositoryFunc) appendCall(r0 StoreGetLastUploadRetentionScanForRepositoryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// StoreGetLastUploadRetentionScanForRepositoryFuncCall objects describing
// the invocations of this function.
func (f *StoreGetLastUploadRetentionScanForRepositoryFunc) History() []StoreGetLastUploadRetentionScanForRepositoryFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetLastUploadRetentionScanForRepositoryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetLastUploadRetentionScanForRepositoryFuncCall is an object that
// describes an invocation of method GetLastUploadRetentionScanForRepository
// on an instance of MockStore.
type StoreGetLastUploadRetentionScanForRepositoryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *time.Time
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetLastUploadRetentionScanForRepositoryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetLastUploadRetentionScanForRepositoryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetOldestCommitDateFunc describes the behavior when the
// GetOldestCommitDate method of the parent MockStore instance is invoked.
type StoreGetOldestCommitDateFunc struct {
	defaultHook func(context.Context, int) (time.Time, bool, error)
	hooks       []func(context.Context, int) (time.Time, bool, error)
	history     []StoreGetOldestCommitDateFuncCall
	mutex       sync.Mutex
}

// GetOldestCommitDate delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) GetOldestCommitDate(v0 context.Context, v1 int) (time.Time, bool, error) {
	r0, r1, r2 := m.GetOldestCommitDateFunc.nextHook()(v0, v1)
	m.GetOldestCommitDateFunc.appendCall(StoreGetOldestCommitDateFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetOldestCommitDate
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreGetOldestCommitDateFunc) SetDefaultHook(hook func(context.Context, int) (time.Time, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetOldestCommitDate method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreGetOldestCommitDateFunc) PushHook(hook func(context.Context, int) (time.Time, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetOldestCommitDateFunc) SetDefaultReturn(r0 time.Time, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (time.Time, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetOldestCommitDateFunc) PushReturn(r0 time.Time, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (time.Time, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetOldestCommitDateFunc) nextHook() func(context.Context, int) (time.Time, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetOldestCommitDateFunc) appendCall(r0 StoreGetOldestCommitDateFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetOldestCommitDateFuncCall objects
// describing the invocations of this function.
func (f *StoreGetOldestCommitDateFunc) History() []StoreGetOldestCommitDateFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetOldestCommitDateFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetOldestCommitDateFuncCall is an object that describes an
// invocation of method GetOldestCommitDate on an instance of MockStore.
type StoreGetOldestCommitDateFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 time.Time
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetOldestCommitDateFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetOldestCommitDateFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetRecentUploadsSummaryFunc describes the behavior when the
// GetRecentUploadsSummary method of the parent MockStore instance is
// invoked.
type StoreGetRecentUploadsSummaryFunc struct {
	defaultHook func(context.Context, int) ([]shared1.UploadsWithRepositoryNamespace, error)
	hooks       []func(context.Context, int) ([]shared1.UploadsWithRepositoryNamespace, error)
	history     []StoreGetRecentUploadsSummaryFuncCall
	mutex       sync.Mutex
}

// GetRecentUploadsSummary delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) GetRecentUploadsSummary(v0 context.Context, v1 int) ([]shared1.UploadsWithRepositoryNamespace, error) {
	r0, r1 := m.GetRecentUploadsSummaryFunc.nextHook()(v0, v1)
	m.GetRecentUploadsSummaryFunc.appendCall(StoreGetRecentUploadsSummaryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// GetRecentUploadsSummary method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreGetRecentUploadsSummaryFunc) SetDefaultHook(hook func(context.Context, int) ([]shared1.UploadsWithRepositoryNamespace, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetRecentUploadsSummary method of the parent MockStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreGetRecentUploadsSummaryFunc) PushHook(hook func(context.Context, int) ([]shared1.UploadsWithRepositoryNamespace, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetRecentUploadsSummaryFunc) SetDefaultReturn(r0 []shared1.UploadsWithRepositoryNamespace, r1 error) {
	f.SetDefaultHook(func(context.Context, int) ([]shared1.UploadsWithRepositoryNamespace, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetRecentUploadsSummaryFunc) PushReturn(r0 []shared1.UploadsWithRepositoryNamespace, r1 error) {
	f.PushHook(func(context.Context, int) ([]shared1.UploadsWithRepositoryNamespace, error) {
		return r0, r1
	})
}

func (f *StoreGetRecentUploadsSummaryFunc) nextHook() func(context.Context, int) ([]shared1.UploadsWithRepositoryNamespace, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetRecentUploadsSummaryFunc) appendCall(r0 StoreGetRecentUploadsSummaryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetRecentUploadsSummaryFuncCall
// objects describing the invocations of this function.
func (f *StoreGetRecentUploadsSummaryFunc) History() []StoreGetRecentUploadsSummaryFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetRecentUploadsSummaryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetRecentUploadsSummaryFuncCall is an object that describes an
// invocation of method GetRecentUploadsSummary on an instance of MockStore.
type StoreGetRecentUploadsSummaryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared1.UploadsWithRepositoryNamespace
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetRecentUploadsSummaryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetRecentUploadsSummaryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetRepositoriesForIndexScanFunc describes the behavior when the
// GetRepositoriesForIndexScan method of the parent MockStore instance is
// invoked.
type StoreGetRepositoriesForIndexScanFunc struct {
	defaultHook func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) ([]int, error)
	hooks       []func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) ([]int, error)
	history     []StoreGetRepositoriesForIndexScanFuncCall
	mutex       sync.Mutex
}

// GetRepositoriesForIndexScan delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) GetRepositoriesForIndexScan(v0 context.Context, v1 string, v2 string, v3 time.Duration, v4 bool, v5 *int, v6 int, v7 time.Time) ([]int, error) {
	r0, r1 := m.GetRepositoriesForIndexScanFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6, v7)
	m.GetRepositoriesForIndexScanFunc.appendCall(StoreGetRepositoriesForIndexScanFuncCall{v0, v1, v2, v3, v4, v5, v6, v7, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// GetRepositoriesForIndexScan method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreGetRepositoriesForIndexScanFunc) SetDefaultHook(hook func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) ([]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetRepositoriesForIndexScan method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreGetRepositoriesForIndexScanFunc) PushHook(hook func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) ([]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetRepositoriesForIndexScanFunc) SetDefaultReturn(r0 []int, r1 error) {
	f.SetDefaultHook(func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) ([]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetRepositoriesForIndexScanFunc) PushReturn(r0 []int, r1 error) {
	f.PushHook(func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) ([]int, error) {
		return r0, r1
	})
}

func (f *StoreGetRepositoriesForIndexScanFunc) nextHook() func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) ([]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetRepositoriesForIndexScanFunc) appendCall(r0 StoreGetRepositoriesForIndexScanFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetRepositoriesForIndexScanFuncCall
// objects describing the invocations of this function.
func (f *StoreGetRepositoriesForIndexScanFunc) History() []StoreGetRepositoriesForIndexScanFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetRepositoriesForIndexScanFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetRepositoriesForIndexScanFuncCall is an object that describes an
// invocation of method GetRepositoriesForIndexScan on an instance of
// MockStore.
type StoreGetRepositoriesForIndexScanFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 time.Duration
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 bool
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 *int
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 int
	// Arg7 is the value of the 8th argument passed to this method
	// invocation.
	Arg7 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetRepositoriesForIndexScanFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6, c.Arg7}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetRepositoriesForIndexScanFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetRepositoriesMaxStaleAgeFunc describes the behavior when the
// GetRepositoriesMaxStaleAge method of the parent MockStore instance is
// invoked.
type StoreGetRepositoriesMaxStaleAgeFunc struct {
	defaultHook func(context.Context) (time.Duration, error)
	hooks       []func(context.Context) (time.Duration, error)
	history     []StoreGetRepositoriesMaxStaleAgeFuncCall
	mutex       sync.Mutex
}

// GetRepositoriesMaxStaleAge delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) GetRepositoriesMaxStaleAge(v0 context.Context) (time.Duration, error) {
	r0, r1 := m.GetRepositoriesMaxStaleAgeFunc.nextHook()(v0)
	m.GetRepositoriesMaxStaleAgeFunc.appendCall(StoreGetRepositoriesMaxStaleAgeFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// GetRepositoriesMaxStaleAge method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreGetRepositoriesMaxStaleAgeFunc) SetDefaultHook(hook func(context.Context) (time.Duration, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetRepositoriesMaxStaleAge method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreGetRepositoriesMaxStaleAgeFunc) PushHook(hook func(context.Context) (time.Duration, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetRepositoriesMaxStaleAgeFunc) SetDefaultReturn(r0 time.Duration, r1 error) {
	f.SetDefaultHook(func(context.Context) (time.Duration, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetRepositoriesMaxStaleAgeFunc) PushReturn(r0 time.Duration, r1 error) {
	f.PushHook(func(context.Context) (time.Duration, error) {
		return r0, r1
	})
}

func (f *StoreGetRepositoriesMaxStaleAgeFunc) nextHook() func(context.Context) (time.Duration, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetRepositoriesMaxStaleAgeFunc) appendCall(r0 StoreGetRepositoriesMaxStaleAgeFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetRepositoriesMaxStaleAgeFuncCall
// objects describing the invocations of this function.
func (f *StoreGetRepositoriesMaxStaleAgeFunc) History() []StoreGetRepositoriesMaxStaleAgeFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetRepositoriesMaxStaleAgeFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetRepositoriesMaxStaleAgeFuncCall is an object that describes an
// invocation of method GetRepositoriesMaxStaleAge on an instance of
// MockStore.
type StoreGetRepositoriesMaxStaleAgeFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 time.Duration
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetRepositoriesMaxStaleAgeFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetRepositoriesMaxStaleAgeFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetStaleSourcedCommitsFunc describes the behavior when the
// GetStaleSourcedCommits method of the parent MockStore instance is
// invoked.
type StoreGetStaleSourcedCommitsFunc struct {
	defaultHook func(context.Context, time.Duration, int, time.Time) ([]shared1.SourcedCommits, error)
	hooks       []func(context.Context, time.Duration, int, time.Time) ([]shared1.SourcedCommits, error)
	history     []StoreGetStaleSourcedCommitsFuncCall
	mutex       sync.Mutex
}

// GetStaleSourcedCommits delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) GetStaleSourcedCommits(v0 context.Context, v1 time.Duration, v2 int, v3 time.Time) ([]shared1.SourcedCommits, error) {
	r0, r1 := m.GetStaleSourcedCommitsFunc.nextHook()(v0, v1, v2, v3)
	m.GetStaleSourcedCommitsFunc.appendCall(StoreGetStaleSourcedCommitsFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// GetStaleSourcedCommits method of the parent MockStore instance is invoked
// and the hook queue is empty.
func (f *StoreGetStaleSourcedCommitsFunc) SetDefaultHook(hook func(context.Context, time.Duration, int, time.Time) ([]shared1.SourcedCommits, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetStaleSourcedCommits method of the parent MockStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreGetStaleSourcedCommitsFunc) PushHook(hook func(context.Context, time.Duration, int, time.Time) ([]shared1.SourcedCommits, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetStaleSourcedCommitsFunc) SetDefaultReturn(r0 []shared1.SourcedCommits, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Duration, int, time.Time) ([]shared1.SourcedCommits, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetStaleSourcedCommitsFunc) PushReturn(r0 []shared1.SourcedCommits, r1 error) {
	f.PushHook(func(context.Context, time.Duration, int, time.Time) ([]shared1.SourcedCommits, error) {
		return r0, r1
	})
}

func (f *StoreGetStaleSourcedCommitsFunc) nextHook() func(context.Context, time.Duration, int, time.Time) ([]shared1.SourcedCommits, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetStaleSourcedCommitsFunc) appendCall(r0 StoreGetStaleSourcedCommitsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetStaleSourcedCommitsFuncCall objects
// describing the invocations of this function.
func (f *StoreGetStaleSourcedCommitsFunc) History() []StoreGetStaleSourcedCommitsFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetStaleSourcedCommitsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetStaleSourcedCommitsFuncCall is an object that describes an
// invocation of method GetStaleSourcedCommits on an instance of MockStore.
type StoreGetStaleSourcedCommitsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Duration
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared1.SourcedCommits
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetStaleSourcedCommitsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetStaleSourcedCommitsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetUploadByIDFunc describes the behavior when the GetUploadByID
// method of the parent MockStore instance is invoked.
type StoreGetUploadByIDFunc struct {
	defaultHook func(context.Context, int) (types.Upload, bool, error)
	hooks       []func(context.Context, int) (types.Upload, bool, error)
	history     []StoreGetUploadByIDFuncCall
	mutex       sync.Mutex
}

// GetUploadByID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetUploadByID(v0 context.Context, v1 int) (types.Upload, bool, error) {
	r0, r1, r2 := m.GetUploadByIDFunc.nextHook()(v0, v1)
	m.GetUploadByIDFunc.appendCall(StoreGetUploadByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetUploadByID method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetUploadByIDFunc) SetDefaultHook(hook func(context.Context, int) (types.Upload, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadByID method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetUploadByIDFunc) PushHook(hook func(context.Context, int) (types.Upload, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetUploadByIDFunc) SetDefaultReturn(r0 types.Upload, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (types.Upload, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetUploadByIDFunc) PushReturn(r0 types.Upload, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (types.Upload, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetUploadByIDFunc) nextHook() func(context.Context, int) (types.Upload, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetUploadByIDFunc) appendCall(r0 StoreGetUploadByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetUploadByIDFuncCall objects
// describing the invocations of this function.
func (f *StoreGetUploadByIDFunc) History() []StoreGetUploadByIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetUploadByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetUploadByIDFuncCall is an object that describes an invocation of
// method GetUploadByID on an instance of MockStore.
type StoreGetUploadByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 types.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetUploadByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetUploadByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetUploadIDsWithReferencesFunc describes the behavior when the
// GetUploadIDsWithReferences method of the parent MockStore instance is
// invoked.
type StoreGetUploadIDsWithReferencesFunc struct {
	defaultHook func(context.Context, []precise.QualifiedMonikerData, []int, int, string, int, int, observation.TraceLogger) ([]int, int, int, error)
	hooks       []func(context.Context, []precise.QualifiedMonikerData, []int, int, string, int, int, observation.TraceLogger) ([]int, int, int, error)
	history     []StoreGetUploadIDsWithReferencesFuncCall
	mutex       sync.Mutex
}

// GetUploadIDsWithReferences delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) GetUploadIDsWithReferences(v0 context.Context, v1 []precise.QualifiedMonikerData, v2 []int, v3 int, v4 string, v5 int, v6 int, v7 observation.TraceLogger) ([]int, int, int, error) {
	r0, r1, r2, r3 := m.GetUploadIDsWithReferencesFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6, v7)
	m.GetUploadIDsWithReferencesFunc.appendCall(StoreGetUploadIDsWithReferencesFuncCall{v0, v1, v2, v3, v4, v5, v6, v7, r0, r1, r2, r3})
	return r0, r1, r2, r3
}

// SetDefaultHook sets function that is called when the
// GetUploadIDsWithReferences method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreGetUploadIDsWithReferencesFunc) SetDefaultHook(hook func(context.Context, []precise.QualifiedMonikerData, []int, int, string, int, int, observation.TraceLogger) ([]int, int, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadIDsWithReferences method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreGetUploadIDsWithReferencesFunc) PushHook(hook func(context.Context, []precise.QualifiedMonikerData, []int, int, string, int, int, observation.TraceLogger) ([]int, int, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetUploadIDsWithReferencesFunc) SetDefaultReturn(r0 []int, r1 int, r2 int, r3 error) {
	f.SetDefaultHook(func(context.Context, []precise.QualifiedMonikerData, []int, int, string, int, int, observation.TraceLogger) ([]int, int, int, error) {
		return r0, r1, r2, r3
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetUploadIDsWithReferencesFunc) PushReturn(r0 []int, r1 int, r2 int, r3 error) {
	f.PushHook(func(context.Context, []precise.QualifiedMonikerData, []int, int, string, int, int, observation.TraceLogger) ([]int, int, int, error) {
		return r0, r1, r2, r3
	})
}

func (f *StoreGetUploadIDsWithReferencesFunc) nextHook() func(context.Context, []precise.QualifiedMonikerData, []int, int, string, int, int, observation.TraceLogger) ([]int, int, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetUploadIDsWithReferencesFunc) appendCall(r0 StoreGetUploadIDsWithReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetUploadIDsWithReferencesFuncCall
// objects describing the invocations of this function.
func (f *StoreGetUploadIDsWithReferencesFunc) History() []StoreGetUploadIDsWithReferencesFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetUploadIDsWithReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetUploadIDsWithReferencesFuncCall is an object that describes an
// invocation of method GetUploadIDsWithReferences on an instance of
// MockStore.
type StoreGetUploadIDsWithReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []precise.QualifiedMonikerData
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 int
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 int
	// Arg7 is the value of the 8th argument passed to this method
	// invocation.
	Arg7 observation.TraceLogger
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 int
	// Result3 is the value of the 4th result returned from this method
	// invocation.
	Result3 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetUploadIDsWithReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6, c.Arg7}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetUploadIDsWithReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2, c.Result3}
}

// StoreGetUploadsFunc describes the behavior when the GetUploads method of
// the parent MockStore instance is invoked.
type StoreGetUploadsFunc struct {
	defaultHook func(context.Context, shared1.GetUploadsOptions) ([]types.Upload, int, error)
	hooks       []func(context.Context, shared1.GetUploadsOptions) ([]types.Upload, int, error)
	history     []StoreGetUploadsFuncCall
	mutex       sync.Mutex
}

// GetUploads delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetUploads(v0 context.Context, v1 shared1.GetUploadsOptions) ([]types.Upload, int, error) {
	r0, r1, r2 := m.GetUploadsFunc.nextHook()(v0, v1)
	m.GetUploadsFunc.appendCall(StoreGetUploadsFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetUploads method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetUploadsFunc) SetDefaultHook(hook func(context.Context, shared1.GetUploadsOptions) ([]types.Upload, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploads method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetUploadsFunc) PushHook(hook func(context.Context, shared1.GetUploadsOptions) ([]types.Upload, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetUploadsFunc) SetDefaultReturn(r0 []types.Upload, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, shared1.GetUploadsOptions) ([]types.Upload, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetUploadsFunc) PushReturn(r0 []types.Upload, r1 int, r2 error) {
	f.PushHook(func(context.Context, shared1.GetUploadsOptions) ([]types.Upload, int, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetUploadsFunc) nextHook() func(context.Context, shared1.GetUploadsOptions) ([]types.Upload, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetUploadsFunc) appendCall(r0 StoreGetUploadsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetUploadsFuncCall objects describing
// the invocations of this function.
func (f *StoreGetUploadsFunc) History() []StoreGetUploadsFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetUploadsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetUploadsFuncCall is an object that describes an invocation of
// method GetUploads on an instance of MockStore.
type StoreGetUploadsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 shared1.GetUploadsOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetUploadsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetUploadsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetUploadsByIDsFunc describes the behavior when the GetUploadsByIDs
// method of the parent MockStore instance is invoked.
type StoreGetUploadsByIDsFunc struct {
	defaultHook func(context.Context, ...int) ([]types.Upload, error)
	hooks       []func(context.Context, ...int) ([]types.Upload, error)
	history     []StoreGetUploadsByIDsFuncCall
	mutex       sync.Mutex
}

// GetUploadsByIDs delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) GetUploadsByIDs(v0 context.Context, v1 ...int) ([]types.Upload, error) {
	r0, r1 := m.GetUploadsByIDsFunc.nextHook()(v0, v1...)
	m.GetUploadsByIDsFunc.appendCall(StoreGetUploadsByIDsFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetUploadsByIDs
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreGetUploadsByIDsFunc) SetDefaultHook(hook func(context.Context, ...int) ([]types.Upload, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadsByIDs method of the parent MockStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetUploadsByIDsFunc) PushHook(hook func(context.Context, ...int) ([]types.Upload, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetUploadsByIDsFunc) SetDefaultReturn(r0 []types.Upload, r1 error) {
	f.SetDefaultHook(func(context.Context, ...int) ([]types.Upload, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetUploadsByIDsFunc) PushReturn(r0 []types.Upload, r1 error) {
	f.PushHook(func(context.Context, ...int) ([]types.Upload, error) {
		return r0, r1
	})
}

func (f *StoreGetUploadsByIDsFunc) nextHook() func(context.Context, ...int) ([]types.Upload, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetUploadsByIDsFunc) appendCall(r0 StoreGetUploadsByIDsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetUploadsByIDsFuncCall objects
// describing the invocations of this function.
func (f *StoreGetUploadsByIDsFunc) History() []StoreGetUploadsByIDsFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetUploadsByIDsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetUploadsByIDsFuncCall is an object that describes an invocation of
// method GetUploadsByIDs on an instance of MockStore.
type StoreGetUploadsByIDsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c StoreGetUploadsByIDsFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetUploadsByIDsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetUploadsByIDsAllowDeletedFunc describes the behavior when the
// GetUploadsByIDsAllowDeleted method of the parent MockStore instance is
// invoked.
type StoreGetUploadsByIDsAllowDeletedFunc struct {
	defaultHook func(context.Context, ...int) ([]types.Upload, error)
	hooks       []func(context.Context, ...int) ([]types.Upload, error)
	history     []StoreGetUploadsByIDsAllowDeletedFuncCall
	mutex       sync.Mutex
}

// GetUploadsByIDsAllowDeleted delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) GetUploadsByIDsAllowDeleted(v0 context.Context, v1 ...int) ([]types.Upload, error) {
	r0, r1 := m.GetUploadsByIDsAllowDeletedFunc.nextHook()(v0, v1...)
	m.GetUploadsByIDsAllowDeletedFunc.appendCall(StoreGetUploadsByIDsAllowDeletedFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// GetUploadsByIDsAllowDeleted method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreGetUploadsByIDsAllowDeletedFunc) SetDefaultHook(hook func(context.Context, ...int) ([]types.Upload, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadsByIDsAllowDeleted method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreGetUploadsByIDsAllowDeletedFunc) PushHook(hook func(context.Context, ...int) ([]types.Upload, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetUploadsByIDsAllowDeletedFunc) SetDefaultReturn(r0 []types.Upload, r1 error) {
	f.SetDefaultHook(func(context.Context, ...int) ([]types.Upload, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetUploadsByIDsAllowDeletedFunc) PushReturn(r0 []types.Upload, r1 error) {
	f.PushHook(func(context.Context, ...int) ([]types.Upload, error) {
		return r0, r1
	})
}

func (f *StoreGetUploadsByIDsAllowDeletedFunc) nextHook() func(context.Context, ...int) ([]types.Upload, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetUploadsByIDsAllowDeletedFunc) appendCall(r0 StoreGetUploadsByIDsAllowDeletedFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetUploadsByIDsAllowDeletedFuncCall
// objects describing the invocations of this function.
func (f *StoreGetUploadsByIDsAllowDeletedFunc) History() []StoreGetUploadsByIDsAllowDeletedFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetUploadsByIDsAllowDeletedFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetUploadsByIDsAllowDeletedFuncCall is an object that describes an
// invocation of method GetUploadsByIDsAllowDeleted on an instance of
// MockStore.
type StoreGetUploadsByIDsAllowDeletedFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c StoreGetUploadsByIDsAllowDeletedFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetUploadsByIDsAllowDeletedFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetUploadsForRankingFunc describes the behavior when the
// GetUploadsForRanking method of the parent MockStore instance is invoked.
type StoreGetUploadsForRankingFunc struct {
	defaultHook func(context.Context, string, string, int) ([]shared1.ExportedUpload, error)
	hooks       []func(context.Context, string, string, int) ([]shared1.ExportedUpload, error)
	history     []StoreGetUploadsForRankingFuncCall
	mutex       sync.Mutex
}

// GetUploadsForRanking delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) GetUploadsForRanking(v0 context.Context, v1 string, v2 string, v3 int) ([]shared1.ExportedUpload, error) {
	r0, r1 := m.GetUploadsForRankingFunc.nextHook()(v0, v1, v2, v3)
	m.GetUploadsForRankingFunc.appendCall(StoreGetUploadsForRankingFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetUploadsForRanking
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreGetUploadsForRankingFunc) SetDefaultHook(hook func(context.Context, string, string, int) ([]shared1.ExportedUpload, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadsForRanking method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreGetUploadsForRankingFunc) PushHook(hook func(context.Context, string, string, int) ([]shared1.ExportedUpload, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetUploadsForRankingFunc) SetDefaultReturn(r0 []shared1.ExportedUpload, r1 error) {
	f.SetDefaultHook(func(context.Context, string, string, int) ([]shared1.ExportedUpload, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetUploadsForRankingFunc) PushReturn(r0 []shared1.ExportedUpload, r1 error) {
	f.PushHook(func(context.Context, string, string, int) ([]shared1.ExportedUpload, error) {
		return r0, r1
	})
}

func (f *StoreGetUploadsForRankingFunc) nextHook() func(context.Context, string, string, int) ([]shared1.ExportedUpload, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetUploadsForRankingFunc) appendCall(r0 StoreGetUploadsForRankingFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetUploadsForRankingFuncCall objects
// describing the invocations of this function.
func (f *StoreGetUploadsForRankingFunc) History() []StoreGetUploadsForRankingFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetUploadsForRankingFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetUploadsForRankingFuncCall is an object that describes an
// invocation of method GetUploadsForRanking on an instance of MockStore.
type StoreGetUploadsForRankingFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared1.ExportedUpload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetUploadsForRankingFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetUploadsForRankingFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetVisibleUploadsMatchingMonikersFunc describes the behavior when
// the GetVisibleUploadsMatchingMonikers method of the parent MockStore
// instance is invoked.
type StoreGetVisibleUploadsMatchingMonikersFunc struct {
	defaultHook func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (shared1.PackageReferenceScanner, int, error)
	hooks       []func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (shared1.PackageReferenceScanner, int, error)
	history     []StoreGetVisibleUploadsMatchingMonikersFuncCall
	mutex       sync.Mutex
}

// GetVisibleUploadsMatchingMonikers delegates to the next hook function in
// the queue and stores the parameter and result values of this invocation.
func (m *MockStore) GetVisibleUploadsMatchingMonikers(v0 context.Context, v1 int, v2 string, v3 []precise.QualifiedMonikerData, v4 int, v5 int) (shared1.PackageReferenceScanner, int, error) {
	r0, r1, r2 := m.GetVisibleUploadsMatchingMonikersFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.GetVisibleUploadsMatchingMonikersFunc.appendCall(StoreGetVisibleUploadsMatchingMonikersFuncCall{v0, v1, v2, v3, v4, v5, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// GetVisibleUploadsMatchingMonikers method of the parent MockStore instance
// is invoked and the hook queue is empty.
func (f *StoreGetVisibleUploadsMatchingMonikersFunc) SetDefaultHook(hook func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (shared1.PackageReferenceScanner, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetVisibleUploadsMatchingMonikers method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreGetVisibleUploadsMatchingMonikersFunc) PushHook(hook func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (shared1.PackageReferenceScanner, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetVisibleUploadsMatchingMonikersFunc) SetDefaultReturn(r0 shared1.PackageReferenceScanner, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (shared1.PackageReferenceScanner, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetVisibleUploadsMatchingMonikersFunc) PushReturn(r0 shared1.PackageReferenceScanner, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (shared1.PackageReferenceScanner, int, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetVisibleUploadsMatchingMonikersFunc) nextHook() func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (shared1.PackageReferenceScanner, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetVisibleUploadsMatchingMonikersFunc) appendCall(r0 StoreGetVisibleUploadsMatchingMonikersFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// StoreGetVisibleUploadsMatchingMonikersFuncCall objects describing the
// invocations of this function.
func (f *StoreGetVisibleUploadsMatchingMonikersFunc) History() []StoreGetVisibleUploadsMatchingMonikersFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetVisibleUploadsMatchingMonikersFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetVisibleUploadsMatchingMonikersFuncCall is an object that
// describes an invocation of method GetVisibleUploadsMatchingMonikers on an
// instance of MockStore.
type StoreGetVisibleUploadsMatchingMonikersFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 []precise.QualifiedMonikerData
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 shared1.PackageReferenceScanner
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetVisibleUploadsMatchingMonikersFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetVisibleUploadsMatchingMonikersFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreHardDeleteUploadsByIDsFunc describes the behavior when the
// HardDeleteUploadsByIDs method of the parent MockStore instance is
// invoked.
type StoreHardDeleteUploadsByIDsFunc struct {
	defaultHook func(context.Context, ...int) error
	hooks       []func(context.Context, ...int) error
	history     []StoreHardDeleteUploadsByIDsFuncCall
	mutex       sync.Mutex
}

// HardDeleteUploadsByIDs delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) HardDeleteUploadsByIDs(v0 context.Context, v1 ...int) error {
	r0 := m.HardDeleteUploadsByIDsFunc.nextHook()(v0, v1...)
	m.HardDeleteUploadsByIDsFunc.appendCall(StoreHardDeleteUploadsByIDsFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// HardDeleteUploadsByIDs method of the parent MockStore instance is invoked
// and the hook queue is empty.
func (f *StoreHardDeleteUploadsByIDsFunc) SetDefaultHook(hook func(context.Context, ...int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// HardDeleteUploadsByIDs method of the parent MockStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreHardDeleteUploadsByIDsFunc) PushHook(hook func(context.Context, ...int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreHardDeleteUploadsByIDsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, ...int) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreHardDeleteUploadsByIDsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, ...int) error {
		return r0
	})
}

func (f *StoreHardDeleteUploadsByIDsFunc) nextHook() func(context.Context, ...int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreHardDeleteUploadsByIDsFunc) appendCall(r0 StoreHardDeleteUploadsByIDsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreHardDeleteUploadsByIDsFuncCall objects
// describing the invocations of this function.
func (f *StoreHardDeleteUploadsByIDsFunc) History() []StoreHardDeleteUploadsByIDsFuncCall {
	f.mutex.Lock()
	history := make([]StoreHardDeleteUploadsByIDsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreHardDeleteUploadsByIDsFuncCall is an object that describes an
// invocation of method HardDeleteUploadsByIDs on an instance of MockStore.
type StoreHardDeleteUploadsByIDsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c StoreHardDeleteUploadsByIDsFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreHardDeleteUploadsByIDsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreHasCommitFunc describes the behavior when the HasCommit method of
// the parent MockStore instance is invoked.
type StoreHasCommitFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []StoreHasCommitFuncCall
	mutex       sync.Mutex
}

// HasCommit delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) HasCommit(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.HasCommitFunc.nextHook()(v0, v1, v2)
	m.HasCommitFunc.appendCall(StoreHasCommitFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the HasCommit method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreHasCommitFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// HasCommit method of the parent MockStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreHasCommitFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreHasCommitFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreHasCommitFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *StoreHasCommitFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreHasCommitFunc) appendCall(r0 StoreHasCommitFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreHasCommitFuncCall objects describing
// the invocations of this function.
func (f *StoreHasCommitFunc) History() []StoreHasCommitFuncCall {
	f.mutex.Lock()
	history := make([]StoreHasCommitFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreHasCommitFuncCall is an object that describes an invocation of
// method HasCommit on an instance of MockStore.
type StoreHasCommitFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreHasCommitFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreHasCommitFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreHasRepositoryFunc describes the behavior when the HasRepository
// method of the parent MockStore instance is invoked.
type StoreHasRepositoryFunc struct {
	defaultHook func(context.Context, int) (bool, error)
	hooks       []func(context.Context, int) (bool, error)
	history     []StoreHasRepositoryFuncCall
	mutex       sync.Mutex
}

// HasRepository delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) HasRepository(v0 context.Context, v1 int) (bool, error) {
	r0, r1 := m.HasRepositoryFunc.nextHook()(v0, v1)
	m.HasRepositoryFunc.appendCall(StoreHasRepositoryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the HasRepository method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreHasRepositoryFunc) SetDefaultHook(hook func(context.Context, int) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// HasRepository method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreHasRepositoryFunc) PushHook(hook func(context.Context, int) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreHasRepositoryFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreHasRepositoryFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

func (f *StoreHasRepositoryFunc) nextHook() func(context.Context, int) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreHasRepositoryFunc) appendCall(r0 StoreHasRepositoryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreHasRepositoryFuncCall objects
// describing the invocations of this function.
func (f *StoreHasRepositoryFunc) History() []StoreHasRepositoryFuncCall {
	f.mutex.Lock()
	history := make([]StoreHasRepositoryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreHasRepositoryFuncCall is an object that describes an invocation of
// method HasRepository on an instance of MockStore.
type StoreHasRepositoryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreHasRepositoryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreHasRepositoryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreInsertDefinitionsForRankingFunc describes the behavior when the
// InsertDefinitionsForRanking method of the parent MockStore instance is
// invoked.
type StoreInsertDefinitionsForRankingFunc struct {
	defaultHook func(context.Context, string, int, []shared1.RankingDefinitions) error
	hooks       []func(context.Context, string, int, []shared1.RankingDefinitions) error
	history     []StoreInsertDefinitionsForRankingFuncCall
	mutex       sync.Mutex
}

// InsertDefinitionsForRanking delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) InsertDefinitionsForRanking(v0 context.Context, v1 string, v2 int, v3 []shared1.RankingDefinitions) error {
	r0 := m.InsertDefinitionsForRankingFunc.nextHook()(v0, v1, v2, v3)
	m.InsertDefinitionsForRankingFunc.appendCall(StoreInsertDefinitionsForRankingFuncCall{v0, v1, v2, v3, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// InsertDefinitionsForRanking method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreInsertDefinitionsForRankingFunc) SetDefaultHook(hook func(context.Context, string, int, []shared1.RankingDefinitions) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertDefinitionsForRanking method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreInsertDefinitionsForRankingFunc) PushHook(hook func(context.Context, string, int, []shared1.RankingDefinitions) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreInsertDefinitionsForRankingFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, string, int, []shared1.RankingDefinitions) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreInsertDefinitionsForRankingFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, string, int, []shared1.RankingDefinitions) error {
		return r0
	})
}

func (f *StoreInsertDefinitionsForRankingFunc) nextHook() func(context.Context, string, int, []shared1.RankingDefinitions) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreInsertDefinitionsForRankingFunc) appendCall(r0 StoreInsertDefinitionsForRankingFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreInsertDefinitionsForRankingFuncCall
// objects describing the invocations of this function.
func (f *StoreInsertDefinitionsForRankingFunc) History() []StoreInsertDefinitionsForRankingFuncCall {
	f.mutex.Lock()
	history := make([]StoreInsertDefinitionsForRankingFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreInsertDefinitionsForRankingFuncCall is an object that describes an
// invocation of method InsertDefinitionsForRanking on an instance of
// MockStore.
type StoreInsertDefinitionsForRankingFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 []shared1.RankingDefinitions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreInsertDefinitionsForRankingFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreInsertDefinitionsForRankingFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreInsertDependencySyncingJobFunc describes the behavior when the
// InsertDependencySyncingJob method of the parent MockStore instance is
// invoked.
type StoreInsertDependencySyncingJobFunc struct {
	defaultHook func(context.Context, int) (int, error)
	hooks       []func(context.Context, int) (int, error)
	history     []StoreInsertDependencySyncingJobFuncCall
	mutex       sync.Mutex
}

// InsertDependencySyncingJob delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) InsertDependencySyncingJob(v0 context.Context, v1 int) (int, error) {
	r0, r1 := m.InsertDependencySyncingJobFunc.nextHook()(v0, v1)
	m.InsertDependencySyncingJobFunc.appendCall(StoreInsertDependencySyncingJobFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// InsertDependencySyncingJob method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreInsertDependencySyncingJobFunc) SetDefaultHook(hook func(context.Context, int) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertDependencySyncingJob method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreInsertDependencySyncingJobFunc) PushHook(hook func(context.Context, int) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreInsertDependencySyncingJobFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreInsertDependencySyncingJobFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int) (int, error) {
		return r0, r1
	})
}

func (f *StoreInsertDependencySyncingJobFunc) nextHook() func(context.Context, int) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreInsertDependencySyncingJobFunc) appendCall(r0 StoreInsertDependencySyncingJobFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreInsertDependencySyncingJobFuncCall
// objects describing the invocations of this function.
func (f *StoreInsertDependencySyncingJobFunc) History() []StoreInsertDependencySyncingJobFuncCall {
	f.mutex.Lock()
	history := make([]StoreInsertDependencySyncingJobFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreInsertDependencySyncingJobFuncCall is an object that describes an
// invocation of method InsertDependencySyncingJob on an instance of
// MockStore.
type StoreInsertDependencySyncingJobFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreInsertDependencySyncingJobFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreInsertDependencySyncingJobFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreInsertPathCountInputsFunc describes the behavior when the
// InsertPathCountInputs method of the parent MockStore instance is invoked.
type StoreInsertPathCountInputsFunc struct {
	defaultHook func(context.Context, string, int) (int, int, error)
	hooks       []func(context.Context, string, int) (int, int, error)
	history     []StoreInsertPathCountInputsFuncCall
	mutex       sync.Mutex
}

// InsertPathCountInputs delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) InsertPathCountInputs(v0 context.Context, v1 string, v2 int) (int, int, error) {
	r0, r1, r2 := m.InsertPathCountInputsFunc.nextHook()(v0, v1, v2)
	m.InsertPathCountInputsFunc.appendCall(StoreInsertPathCountInputsFuncCall{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// InsertPathCountInputs method of the parent MockStore instance is invoked
// and the hook queue is empty.
func (f *StoreInsertPathCountInputsFunc) SetDefaultHook(hook func(context.Context, string, int) (int, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertPathCountInputs method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreInsertPathCountInputsFunc) PushHook(hook func(context.Context, string, int) (int, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreInsertPathCountInputsFunc) SetDefaultReturn(r0 int, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, string, int) (int, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreInsertPathCountInputsFunc) PushReturn(r0 int, r1 int, r2 error) {
	f.PushHook(func(context.Context, string, int) (int, int, error) {
		return r0, r1, r2
	})
}

func (f *StoreInsertPathCountInputsFunc) nextHook() func(context.Context, string, int) (int, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreInsertPathCountInputsFunc) appendCall(r0 StoreInsertPathCountInputsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreInsertPathCountInputsFuncCall objects
// describing the invocations of this function.
func (f *StoreInsertPathCountInputsFunc) History() []StoreInsertPathCountInputsFuncCall {
	f.mutex.Lock()
	history := make([]StoreInsertPathCountInputsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreInsertPathCountInputsFuncCall is an object that describes an
// invocation of method InsertPathCountInputs on an instance of MockStore.
type StoreInsertPathCountInputsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreInsertPathCountInputsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreInsertPathCountInputsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreInsertPathRanksFunc describes the behavior when the InsertPathRanks
// method of the parent MockStore instance is invoked.
type StoreInsertPathRanksFunc struct {
	defaultHook func(context.Context, string, int) (float64, float64, error)
	hooks       []func(context.Context, string, int) (float64, float64, error)
	history     []StoreInsertPathRanksFuncCall
	mutex       sync.Mutex
}

// InsertPathRanks delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) InsertPathRanks(v0 context.Context, v1 string, v2 int) (float64, float64, error) {
	r0, r1, r2 := m.InsertPathRanksFunc.nextHook()(v0, v1, v2)
	m.InsertPathRanksFunc.appendCall(StoreInsertPathRanksFuncCall{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the InsertPathRanks
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreInsertPathRanksFunc) SetDefaultHook(hook func(context.Context, string, int) (float64, float64, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertPathRanks method of the parent MockStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreInsertPathRanksFunc) PushHook(hook func(context.Context, string, int) (float64, float64, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreInsertPathRanksFunc) SetDefaultReturn(r0 float64, r1 float64, r2 error) {
	f.SetDefaultHook(func(context.Context, string, int) (float64, float64, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreInsertPathRanksFunc) PushReturn(r0 float64, r1 float64, r2 error) {
	f.PushHook(func(context.Context, string, int) (float64, float64, error) {
		return r0, r1, r2
	})
}

func (f *StoreInsertPathRanksFunc) nextHook() func(context.Context, string, int) (float64, float64, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreInsertPathRanksFunc) appendCall(r0 StoreInsertPathRanksFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreInsertPathRanksFuncCall objects
// describing the invocations of this function.
func (f *StoreInsertPathRanksFunc) History() []StoreInsertPathRanksFuncCall {
	f.mutex.Lock()
	history := make([]StoreInsertPathRanksFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreInsertPathRanksFuncCall is an object that describes an invocation of
// method InsertPathRanks on an instance of MockStore.
type StoreInsertPathRanksFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 float64
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 float64
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreInsertPathRanksFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreInsertPathRanksFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreInsertReferencesForRankingFunc describes the behavior when the
// InsertReferencesForRanking method of the parent MockStore instance is
// invoked.
type StoreInsertReferencesForRankingFunc struct {
	defaultHook func(context.Context, string, int, shared1.RankingReferences) error
	hooks       []func(context.Context, string, int, shared1.RankingReferences) error
	history     []StoreInsertReferencesForRankingFuncCall
	mutex       sync.Mutex
}

// InsertReferencesForRanking delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) InsertReferencesForRanking(v0 context.Context, v1 string, v2 int, v3 shared1.RankingReferences) error {
	r0 := m.InsertReferencesForRankingFunc.nextHook()(v0, v1, v2, v3)
	m.InsertReferencesForRankingFunc.appendCall(StoreInsertReferencesForRankingFuncCall{v0, v1, v2, v3, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// InsertReferencesForRanking method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreInsertReferencesForRankingFunc) SetDefaultHook(hook func(context.Context, string, int, shared1.RankingReferences) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertReferencesForRanking method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreInsertReferencesForRankingFunc) PushHook(hook func(context.Context, string, int, shared1.RankingReferences) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreInsertReferencesForRankingFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, string, int, shared1.RankingReferences) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreInsertReferencesForRankingFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, string, int, shared1.RankingReferences) error {
		return r0
	})
}

func (f *StoreInsertReferencesForRankingFunc) nextHook() func(context.Context, string, int, shared1.RankingReferences) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreInsertReferencesForRankingFunc) appendCall(r0 StoreInsertReferencesForRankingFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreInsertReferencesForRankingFuncCall
// objects describing the invocations of this function.
func (f *StoreInsertReferencesForRankingFunc) History() []StoreInsertReferencesForRankingFuncCall {
	f.mutex.Lock()
	history := make([]StoreInsertReferencesForRankingFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreInsertReferencesForRankingFuncCall is an object that describes an
// invocation of method InsertReferencesForRanking on an instance of
// MockStore.
type StoreInsertReferencesForRankingFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 shared1.RankingReferences
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreInsertReferencesForRankingFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreInsertReferencesForRankingFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreInsertUploadFunc describes the behavior when the InsertUpload method
// of the parent MockStore instance is invoked.
type StoreInsertUploadFunc struct {
	defaultHook func(context.Context, types.Upload) (int, error)
	hooks       []func(context.Context, types.Upload) (int, error)
	history     []StoreInsertUploadFuncCall
	mutex       sync.Mutex
}

// InsertUpload delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) InsertUpload(v0 context.Context, v1 types.Upload) (int, error) {
	r0, r1 := m.InsertUploadFunc.nextHook()(v0, v1)
	m.InsertUploadFunc.appendCall(StoreInsertUploadFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the InsertUpload method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreInsertUploadFunc) SetDefaultHook(hook func(context.Context, types.Upload) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertUpload method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreInsertUploadFunc) PushHook(hook func(context.Context, types.Upload) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreInsertUploadFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, types.Upload) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreInsertUploadFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, types.Upload) (int, error) {
		return r0, r1
	})
}

func (f *StoreInsertUploadFunc) nextHook() func(context.Context, types.Upload) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreInsertUploadFunc) appendCall(r0 StoreInsertUploadFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreInsertUploadFuncCall objects
// describing the invocations of this function.
func (f *StoreInsertUploadFunc) History() []StoreInsertUploadFuncCall {
	f.mutex.Lock()
	history := make([]StoreInsertUploadFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreInsertUploadFuncCall is an object that describes an invocation of
// method InsertUpload on an instance of MockStore.
type StoreInsertUploadFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 types.Upload
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreInsertUploadFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreInsertUploadFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreMarkFailedFunc describes the behavior when the MarkFailed method of
// the parent MockStore instance is invoked.
type StoreMarkFailedFunc struct {
	defaultHook func(context.Context, int, string) error
	hooks       []func(context.Context, int, string) error
	history     []StoreMarkFailedFuncCall
	mutex       sync.Mutex
}

// MarkFailed delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) MarkFailed(v0 context.Context, v1 int, v2 string) error {
	r0 := m.MarkFailedFunc.nextHook()(v0, v1, v2)
	m.MarkFailedFunc.appendCall(StoreMarkFailedFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the MarkFailed method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreMarkFailedFunc) SetDefaultHook(hook func(context.Context, int, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkFailed method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreMarkFailedFunc) PushHook(hook func(context.Context, int, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreMarkFailedFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreMarkFailedFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string) error {
		return r0
	})
}

func (f *StoreMarkFailedFunc) nextHook() func(context.Context, int, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreMarkFailedFunc) appendCall(r0 StoreMarkFailedFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreMarkFailedFuncCall objects describing
// the invocations of this function.
func (f *StoreMarkFailedFunc) History() []StoreMarkFailedFuncCall {
	f.mutex.Lock()
	history := make([]StoreMarkFailedFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreMarkFailedFuncCall is an object that describes an invocation of
// method MarkFailed on an instance of MockStore.
type StoreMarkFailedFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreMarkFailedFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreMarkFailedFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreMarkQueuedFunc describes the behavior when the MarkQueued method of
// the parent MockStore instance is invoked.
type StoreMarkQueuedFunc struct {
	defaultHook func(context.Context, int, *int64) error
	hooks       []func(context.Context, int, *int64) error
	history     []StoreMarkQueuedFuncCall
	mutex       sync.Mutex
}

// MarkQueued delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) MarkQueued(v0 context.Context, v1 int, v2 *int64) error {
	r0 := m.MarkQueuedFunc.nextHook()(v0, v1, v2)
	m.MarkQueuedFunc.appendCall(StoreMarkQueuedFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the MarkQueued method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreMarkQueuedFunc) SetDefaultHook(hook func(context.Context, int, *int64) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkQueued method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreMarkQueuedFunc) PushHook(hook func(context.Context, int, *int64) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreMarkQueuedFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, *int64) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreMarkQueuedFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, *int64) error {
		return r0
	})
}

func (f *StoreMarkQueuedFunc) nextHook() func(context.Context, int, *int64) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreMarkQueuedFunc) appendCall(r0 StoreMarkQueuedFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreMarkQueuedFuncCall objects describing
// the invocations of this function.
func (f *StoreMarkQueuedFunc) History() []StoreMarkQueuedFuncCall {
	f.mutex.Lock()
	history := make([]StoreMarkQueuedFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreMarkQueuedFuncCall is an object that describes an invocation of
// method MarkQueued on an instance of MockStore.
type StoreMarkQueuedFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 *int64
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreMarkQueuedFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreMarkQueuedFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreProcessStaleExportedUploadsFunc describes the behavior when the
// ProcessStaleExportedUploads method of the parent MockStore instance is
// invoked.
type StoreProcessStaleExportedUploadsFunc struct {
	defaultHook func(context.Context, string, int, func(ctx context.Context, objectPrefix string) error) (int, error)
	hooks       []func(context.Context, string, int, func(ctx context.Context, objectPrefix string) error) (int, error)
	history     []StoreProcessStaleExportedUploadsFuncCall
	mutex       sync.Mutex
}

// ProcessStaleExportedUploads delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) ProcessStaleExportedUploads(v0 context.Context, v1 string, v2 int, v3 func(ctx context.Context, objectPrefix string) error) (int, error) {
	r0, r1 := m.ProcessStaleExportedUploadsFunc.nextHook()(v0, v1, v2, v3)
	m.ProcessStaleExportedUploadsFunc.appendCall(StoreProcessStaleExportedUploadsFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// ProcessStaleExportedUploads method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreProcessStaleExportedUploadsFunc) SetDefaultHook(hook func(context.Context, string, int, func(ctx context.Context, objectPrefix string) error) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ProcessStaleExportedUploads method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreProcessStaleExportedUploadsFunc) PushHook(hook func(context.Context, string, int, func(ctx context.Context, objectPrefix string) error) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreProcessStaleExportedUploadsFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, string, int, func(ctx context.Context, objectPrefix string) error) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreProcessStaleExportedUploadsFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, string, int, func(ctx context.Context, objectPrefix string) error) (int, error) {
		return r0, r1
	})
}

func (f *StoreProcessStaleExportedUploadsFunc) nextHook() func(context.Context, string, int, func(ctx context.Context, objectPrefix string) error) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreProcessStaleExportedUploadsFunc) appendCall(r0 StoreProcessStaleExportedUploadsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreProcessStaleExportedUploadsFuncCall
// objects describing the invocations of this function.
func (f *StoreProcessStaleExportedUploadsFunc) History() []StoreProcessStaleExportedUploadsFuncCall {
	f.mutex.Lock()
	history := make([]StoreProcessStaleExportedUploadsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreProcessStaleExportedUploadsFuncCall is an object that describes an
// invocation of method ProcessStaleExportedUploads on an instance of
// MockStore.
type StoreProcessStaleExportedUploadsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 func(ctx context.Context, objectPrefix string) error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreProcessStaleExportedUploadsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreProcessStaleExportedUploadsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreReconcileCandidatesFunc describes the behavior when the
// ReconcileCandidates method of the parent MockStore instance is invoked.
type StoreReconcileCandidatesFunc struct {
	defaultHook func(context.Context, int) ([]int, error)
	hooks       []func(context.Context, int) ([]int, error)
	history     []StoreReconcileCandidatesFuncCall
	mutex       sync.Mutex
}

// ReconcileCandidates delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) ReconcileCandidates(v0 context.Context, v1 int) ([]int, error) {
	r0, r1 := m.ReconcileCandidatesFunc.nextHook()(v0, v1)
	m.ReconcileCandidatesFunc.appendCall(StoreReconcileCandidatesFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ReconcileCandidates
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreReconcileCandidatesFunc) SetDefaultHook(hook func(context.Context, int) ([]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReconcileCandidates method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreReconcileCandidatesFunc) PushHook(hook func(context.Context, int) ([]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreReconcileCandidatesFunc) SetDefaultReturn(r0 []int, r1 error) {
	f.SetDefaultHook(func(context.Context, int) ([]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreReconcileCandidatesFunc) PushReturn(r0 []int, r1 error) {
	f.PushHook(func(context.Context, int) ([]int, error) {
		return r0, r1
	})
}

func (f *StoreReconcileCandidatesFunc) nextHook() func(context.Context, int) ([]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreReconcileCandidatesFunc) appendCall(r0 StoreReconcileCandidatesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreReconcileCandidatesFuncCall objects
// describing the invocations of this function.
func (f *StoreReconcileCandidatesFunc) History() []StoreReconcileCandidatesFuncCall {
	f.mutex.Lock()
	history := make([]StoreReconcileCandidatesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreReconcileCandidatesFuncCall is an object that describes an
// invocation of method ReconcileCandidates on an instance of MockStore.
type StoreReconcileCandidatesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreReconcileCandidatesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreReconcileCandidatesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreReferencesForUploadFunc describes the behavior when the
// ReferencesForUpload method of the parent MockStore instance is invoked.
type StoreReferencesForUploadFunc struct {
	defaultHook func(context.Context, int) (shared1.PackageReferenceScanner, error)
	hooks       []func(context.Context, int) (shared1.PackageReferenceScanner, error)
	history     []StoreReferencesForUploadFuncCall
	mutex       sync.Mutex
}

// ReferencesForUpload delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) ReferencesForUpload(v0 context.Context, v1 int) (shared1.PackageReferenceScanner, error) {
	r0, r1 := m.ReferencesForUploadFunc.nextHook()(v0, v1)
	m.ReferencesForUploadFunc.appendCall(StoreReferencesForUploadFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ReferencesForUpload
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreReferencesForUploadFunc) SetDefaultHook(hook func(context.Context, int) (shared1.PackageReferenceScanner, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReferencesForUpload method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreReferencesForUploadFunc) PushHook(hook func(context.Context, int) (shared1.PackageReferenceScanner, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreReferencesForUploadFunc) SetDefaultReturn(r0 shared1.PackageReferenceScanner, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (shared1.PackageReferenceScanner, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreReferencesForUploadFunc) PushReturn(r0 shared1.PackageReferenceScanner, r1 error) {
	f.PushHook(func(context.Context, int) (shared1.PackageReferenceScanner, error) {
		return r0, r1
	})
}

func (f *StoreReferencesForUploadFunc) nextHook() func(context.Context, int) (shared1.PackageReferenceScanner, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreReferencesForUploadFunc) appendCall(r0 StoreReferencesForUploadFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreReferencesForUploadFuncCall objects
// describing the invocations of this function.
func (f *StoreReferencesForUploadFunc) History() []StoreReferencesForUploadFuncCall {
	f.mutex.Lock()
	history := make([]StoreReferencesForUploadFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreReferencesForUploadFuncCall is an object that describes an
// invocation of method ReferencesForUpload on an instance of MockStore.
type StoreReferencesForUploadFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 shared1.PackageReferenceScanner
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreReferencesForUploadFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreReferencesForUploadFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreReindexUploadByIDFunc describes the behavior when the
// ReindexUploadByID method of the parent MockStore instance is invoked.
type StoreReindexUploadByIDFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []StoreReindexUploadByIDFuncCall
	mutex       sync.Mutex
}

// ReindexUploadByID delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) ReindexUploadByID(v0 context.Context, v1 int) error {
	r0 := m.ReindexUploadByIDFunc.nextHook()(v0, v1)
	m.ReindexUploadByIDFunc.appendCall(StoreReindexUploadByIDFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the ReindexUploadByID
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreReindexUploadByIDFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReindexUploadByID method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreReindexUploadByIDFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreReindexUploadByIDFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreReindexUploadByIDFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *StoreReindexUploadByIDFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreReindexUploadByIDFunc) appendCall(r0 StoreReindexUploadByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreReindexUploadByIDFuncCall objects
// describing the invocations of this function.
func (f *StoreReindexUploadByIDFunc) History() []StoreReindexUploadByIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreReindexUploadByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreReindexUploadByIDFuncCall is an object that describes an invocation
// of method ReindexUploadByID on an instance of MockStore.
type StoreReindexUploadByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreReindexUploadByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreReindexUploadByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreReindexUploadsFunc describes the behavior when the ReindexUploads
// method of the parent MockStore instance is invoked.
type StoreReindexUploadsFunc struct {
	defaultHook func(context.Context, shared1.ReindexUploadsOptions) error
	hooks       []func(context.Context, shared1.ReindexUploadsOptions) error
	history     []StoreReindexUploadsFuncCall
	mutex       sync.Mutex
}

// ReindexUploads delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) ReindexUploads(v0 context.Context, v1 shared1.ReindexUploadsOptions) error {
	r0 := m.ReindexUploadsFunc.nextHook()(v0, v1)
	m.ReindexUploadsFunc.appendCall(StoreReindexUploadsFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the ReindexUploads
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreReindexUploadsFunc) SetDefaultHook(hook func(context.Context, shared1.ReindexUploadsOptions) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReindexUploads method of the parent MockStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreReindexUploadsFunc) PushHook(hook func(context.Context, shared1.ReindexUploadsOptions) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreReindexUploadsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, shared1.ReindexUploadsOptions) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreReindexUploadsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, shared1.ReindexUploadsOptions) error {
		return r0
	})
}

func (f *StoreReindexUploadsFunc) nextHook() func(context.Context, shared1.ReindexUploadsOptions) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreReindexUploadsFunc) appendCall(r0 StoreReindexUploadsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreReindexUploadsFuncCall objects
// describing the invocations of this function.
func (f *StoreReindexUploadsFunc) History() []StoreReindexUploadsFuncCall {
	f.mutex.Lock()
	history := make([]StoreReindexUploadsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreReindexUploadsFuncCall is an object that describes an invocation of
// method ReindexUploads on an instance of MockStore.
type StoreReindexUploadsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 shared1.ReindexUploadsOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreReindexUploadsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreReindexUploadsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreRepoNameFunc describes the behavior when the RepoName method of the
// parent MockStore instance is invoked.
type StoreRepoNameFunc struct {
	defaultHook func(context.Context, int) (string, error)
	hooks       []func(context.Context, int) (string, error)
	history     []StoreRepoNameFuncCall
	mutex       sync.Mutex
}

// RepoName delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) RepoName(v0 context.Context, v1 int) (string, error) {
	r0, r1 := m.RepoNameFunc.nextHook()(v0, v1)
	m.RepoNameFunc.appendCall(StoreRepoNameFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepoName method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreRepoNameFunc) SetDefaultHook(hook func(context.Context, int) (string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoName method of the parent MockStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreRepoNameFunc) PushHook(hook func(context.Context, int) (string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreRepoNameFunc) SetDefaultReturn(r0 string, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreRepoNameFunc) PushReturn(r0 string, r1 error) {
	f.PushHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

func (f *StoreRepoNameFunc) nextHook() func(context.Context, int) (string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreRepoNameFunc) appendCall(r0 StoreRepoNameFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreRepoNameFuncCall objects describing
// the invocations of this function.
func (f *StoreRepoNameFunc) History() []StoreRepoNameFuncCall {
	f.mutex.Lock()
	history := make([]StoreRepoNameFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreRepoNameFuncCall is an object that describes an invocation of method
// RepoName on an instance of MockStore.
type StoreRepoNameFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreRepoNameFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreRepoNameFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreRepoNamesFunc describes the behavior when the RepoNames method of
// the parent MockStore instance is invoked.
type StoreRepoNamesFunc struct {
	defaultHook func(context.Context, ...int) (map[int]string, error)
	hooks       []func(context.Context, ...int) (map[int]string, error)
	history     []StoreRepoNamesFuncCall
	mutex       sync.Mutex
}

// RepoNames delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) RepoNames(v0 context.Context, v1 ...int) (map[int]string, error) {
	r0, r1 := m.RepoNamesFunc.nextHook()(v0, v1...)
	m.RepoNamesFunc.appendCall(StoreRepoNamesFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepoNames method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreRepoNamesFunc) SetDefaultHook(hook func(context.Context, ...int) (map[int]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoNames method of the parent MockStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreRepoNamesFunc) PushHook(hook func(context.Context, ...int) (map[int]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreRepoNamesFunc) SetDefaultReturn(r0 map[int]string, r1 error) {
	f.SetDefaultHook(func(context.Context, ...int) (map[int]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreRepoNamesFunc) PushReturn(r0 map[int]string, r1 error) {
	f.PushHook(func(context.Context, ...int) (map[int]string, error) {
		return r0, r1
	})
}

func (f *StoreRepoNamesFunc) nextHook() func(context.Context, ...int) (map[int]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreRepoNamesFunc) appendCall(r0 StoreRepoNamesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreRepoNamesFuncCall objects describing
// the invocations of this function.
func (f *StoreRepoNamesFunc) History() []StoreRepoNamesFuncCall {
	f.mutex.Lock()
	history := make([]StoreRepoNamesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreRepoNamesFuncCall is an object that describes an invocation of
// method RepoNames on an instance of MockStore.
type StoreRepoNamesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[int]string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c StoreRepoNamesFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreRepoNamesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreSetRepositoriesForRetentionScanFunc describes the behavior when the
// SetRepositoriesForRetentionScan method of the parent MockStore instance
// is invoked.
type StoreSetRepositoriesForRetentionScanFunc struct {
	defaultHook func(context.Context, time.Duration, int) ([]int, error)
	hooks       []func(context.Context, time.Duration, int) ([]int, error)
	history     []StoreSetRepositoriesForRetentionScanFuncCall
	mutex       sync.Mutex
}

// SetRepositoriesForRetentionScan delegates to the next hook function in
// the queue and stores the parameter and result values of this invocation.
func (m *MockStore) SetRepositoriesForRetentionScan(v0 context.Context, v1 time.Duration, v2 int) ([]int, error) {
	r0, r1 := m.SetRepositoriesForRetentionScanFunc.nextHook()(v0, v1, v2)
	m.SetRepositoriesForRetentionScanFunc.appendCall(StoreSetRepositoriesForRetentionScanFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// SetRepositoriesForRetentionScan method of the parent MockStore instance
// is invoked and the hook queue is empty.
func (f *StoreSetRepositoriesForRetentionScanFunc) SetDefaultHook(hook func(context.Context, time.Duration, int) ([]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SetRepositoriesForRetentionScan method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreSetRepositoriesForRetentionScanFunc) PushHook(hook func(context.Context, time.Duration, int) ([]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreSetRepositoriesForRetentionScanFunc) SetDefaultReturn(r0 []int, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Duration, int) ([]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreSetRepositoriesForRetentionScanFunc) PushReturn(r0 []int, r1 error) {
	f.PushHook(func(context.Context, time.Duration, int) ([]int, error) {
		return r0, r1
	})
}

func (f *StoreSetRepositoriesForRetentionScanFunc) nextHook() func(context.Context, time.Duration, int) ([]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreSetRepositoriesForRetentionScanFunc) appendCall(r0 StoreSetRepositoriesForRetentionScanFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// StoreSetRepositoriesForRetentionScanFuncCall objects describing the
// invocations of this function.
func (f *StoreSetRepositoriesForRetentionScanFunc) History() []StoreSetRepositoriesForRetentionScanFuncCall {
	f.mutex.Lock()
	history := make([]StoreSetRepositoriesForRetentionScanFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreSetRepositoriesForRetentionScanFuncCall is an object that describes
// an invocation of method SetRepositoriesForRetentionScan on an instance of
// MockStore.
type StoreSetRepositoriesForRetentionScanFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Duration
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreSetRepositoriesForRetentionScanFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreSetRepositoriesForRetentionScanFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreSetRepositoriesForRetentionScanWithTimeFunc describes the behavior
// when the SetRepositoriesForRetentionScanWithTime method of the parent
// MockStore instance is invoked.
type StoreSetRepositoriesForRetentionScanWithTimeFunc struct {
	defaultHook func(context.Context, time.Duration, int, time.Time) ([]int, error)
	hooks       []func(context.Context, time.Duration, int, time.Time) ([]int, error)
	history     []StoreSetRepositoriesForRetentionScanWithTimeFuncCall
	mutex       sync.Mutex
}

// SetRepositoriesForRetentionScanWithTime delegates to the next hook
// function in the queue and stores the parameter and result values of this
// invocation.
func (m *MockStore) SetRepositoriesForRetentionScanWithTime(v0 context.Context, v1 time.Duration, v2 int, v3 time.Time) ([]int, error) {
	r0, r1 := m.SetRepositoriesForRetentionScanWithTimeFunc.nextHook()(v0, v1, v2, v3)
	m.SetRepositoriesForRetentionScanWithTimeFunc.appendCall(StoreSetRepositoriesForRetentionScanWithTimeFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// SetRepositoriesForRetentionScanWithTime method of the parent MockStore
// instance is invoked and the hook queue is empty.
func (f *StoreSetRepositoriesForRetentionScanWithTimeFunc) SetDefaultHook(hook func(context.Context, time.Duration, int, time.Time) ([]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SetRepositoriesForRetentionScanWithTime method of the parent MockStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *StoreSetRepositoriesForRetentionScanWithTimeFunc) PushHook(hook func(context.Context, time.Duration, int, time.Time) ([]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreSetRepositoriesForRetentionScanWithTimeFunc) SetDefaultReturn(r0 []int, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Duration, int, time.Time) ([]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreSetRepositoriesForRetentionScanWithTimeFunc) PushReturn(r0 []int, r1 error) {
	f.PushHook(func(context.Context, time.Duration, int, time.Time) ([]int, error) {
		return r0, r1
	})
}

func (f *StoreSetRepositoriesForRetentionScanWithTimeFunc) nextHook() func(context.Context, time.Duration, int, time.Time) ([]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreSetRepositoriesForRetentionScanWithTimeFunc) appendCall(r0 StoreSetRepositoriesForRetentionScanWithTimeFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// StoreSetRepositoriesForRetentionScanWithTimeFuncCall objects describing
// the invocations of this function.
func (f *StoreSetRepositoriesForRetentionScanWithTimeFunc) History() []StoreSetRepositoriesForRetentionScanWithTimeFuncCall {
	f.mutex.Lock()
	history := make([]StoreSetRepositoriesForRetentionScanWithTimeFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreSetRepositoriesForRetentionScanWithTimeFuncCall is an object that
// describes an invocation of method SetRepositoriesForRetentionScanWithTime
// on an instance of MockStore.
type StoreSetRepositoriesForRetentionScanWithTimeFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Duration
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreSetRepositoriesForRetentionScanWithTimeFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreSetRepositoriesForRetentionScanWithTimeFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreSetRepositoryAsDirtyFunc describes the behavior when the
// SetRepositoryAsDirty method of the parent MockStore instance is invoked.
type StoreSetRepositoryAsDirtyFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []StoreSetRepositoryAsDirtyFuncCall
	mutex       sync.Mutex
}

// SetRepositoryAsDirty delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) SetRepositoryAsDirty(v0 context.Context, v1 int) error {
	r0 := m.SetRepositoryAsDirtyFunc.nextHook()(v0, v1)
	m.SetRepositoryAsDirtyFunc.appendCall(StoreSetRepositoryAsDirtyFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the SetRepositoryAsDirty
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreSetRepositoryAsDirtyFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SetRepositoryAsDirty method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreSetRepositoryAsDirtyFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreSetRepositoryAsDirtyFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreSetRepositoryAsDirtyFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *StoreSetRepositoryAsDirtyFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreSetRepositoryAsDirtyFunc) appendCall(r0 StoreSetRepositoryAsDirtyFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreSetRepositoryAsDirtyFuncCall objects
// describing the invocations of this function.
func (f *StoreSetRepositoryAsDirtyFunc) History() []StoreSetRepositoryAsDirtyFuncCall {
	f.mutex.Lock()
	history := make([]StoreSetRepositoryAsDirtyFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreSetRepositoryAsDirtyFuncCall is an object that describes an
// invocation of method SetRepositoryAsDirty on an instance of MockStore.
type StoreSetRepositoryAsDirtyFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreSetRepositoryAsDirtyFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreSetRepositoryAsDirtyFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreSoftDeleteExpiredUploadsFunc describes the behavior when the
// SoftDeleteExpiredUploads method of the parent MockStore instance is
// invoked.
type StoreSoftDeleteExpiredUploadsFunc struct {
	defaultHook func(context.Context, int) (int, error)
	hooks       []func(context.Context, int) (int, error)
	history     []StoreSoftDeleteExpiredUploadsFuncCall
	mutex       sync.Mutex
}

// SoftDeleteExpiredUploads delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) SoftDeleteExpiredUploads(v0 context.Context, v1 int) (int, error) {
	r0, r1 := m.SoftDeleteExpiredUploadsFunc.nextHook()(v0, v1)
	m.SoftDeleteExpiredUploadsFunc.appendCall(StoreSoftDeleteExpiredUploadsFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// SoftDeleteExpiredUploads method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreSoftDeleteExpiredUploadsFunc) SetDefaultHook(hook func(context.Context, int) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SoftDeleteExpiredUploads method of the parent MockStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreSoftDeleteExpiredUploadsFunc) PushHook(hook func(context.Context, int) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreSoftDeleteExpiredUploadsFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreSoftDeleteExpiredUploadsFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int) (int, error) {
		return r0, r1
	})
}

func (f *StoreSoftDeleteExpiredUploadsFunc) nextHook() func(context.Context, int) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreSoftDeleteExpiredUploadsFunc) appendCall(r0 StoreSoftDeleteExpiredUploadsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreSoftDeleteExpiredUploadsFuncCall
// objects describing the invocations of this function.
func (f *StoreSoftDeleteExpiredUploadsFunc) History() []StoreSoftDeleteExpiredUploadsFuncCall {
	f.mutex.Lock()
	history := make([]StoreSoftDeleteExpiredUploadsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreSoftDeleteExpiredUploadsFuncCall is an object that describes an
// invocation of method SoftDeleteExpiredUploads on an instance of
// MockStore.
type StoreSoftDeleteExpiredUploadsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreSoftDeleteExpiredUploadsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreSoftDeleteExpiredUploadsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreSoftDeleteExpiredUploadsViaTraversalFunc describes the behavior when
// the SoftDeleteExpiredUploadsViaTraversal method of the parent MockStore
// instance is invoked.
type StoreSoftDeleteExpiredUploadsViaTraversalFunc struct {
	defaultHook func(context.Context, int) (int, error)
	hooks       []func(context.Context, int) (int, error)
	history     []StoreSoftDeleteExpiredUploadsViaTraversalFuncCall
	mutex       sync.Mutex
}

// SoftDeleteExpiredUploadsViaTraversal delegates to the next hook function
// in the queue and stores the parameter and result values of this
// invocation.
func (m *MockStore) SoftDeleteExpiredUploadsViaTraversal(v0 context.Context, v1 int) (int, error) {
	r0, r1 := m.SoftDeleteExpiredUploadsViaTraversalFunc.nextHook()(v0, v1)
	m.SoftDeleteExpiredUploadsViaTraversalFunc.appendCall(StoreSoftDeleteExpiredUploadsViaTraversalFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// SoftDeleteExpiredUploadsViaTraversal method of the parent MockStore
// instance is invoked and the hook queue is empty.
func (f *StoreSoftDeleteExpiredUploadsViaTraversalFunc) SetDefaultHook(hook func(context.Context, int) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SoftDeleteExpiredUploadsViaTraversal method of the parent MockStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *StoreSoftDeleteExpiredUploadsViaTraversalFunc) PushHook(hook func(context.Context, int) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreSoftDeleteExpiredUploadsViaTraversalFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreSoftDeleteExpiredUploadsViaTraversalFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int) (int, error) {
		return r0, r1
	})
}

func (f *StoreSoftDeleteExpiredUploadsViaTraversalFunc) nextHook() func(context.Context, int) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreSoftDeleteExpiredUploadsViaTraversalFunc) appendCall(r0 StoreSoftDeleteExpiredUploadsViaTraversalFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// StoreSoftDeleteExpiredUploadsViaTraversalFuncCall objects describing the
// invocations of this function.
func (f *StoreSoftDeleteExpiredUploadsViaTraversalFunc) History() []StoreSoftDeleteExpiredUploadsViaTraversalFuncCall {
	f.mutex.Lock()
	history := make([]StoreSoftDeleteExpiredUploadsViaTraversalFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreSoftDeleteExpiredUploadsViaTraversalFuncCall is an object that
// describes an invocation of method SoftDeleteExpiredUploadsViaTraversal on
// an instance of MockStore.
type StoreSoftDeleteExpiredUploadsViaTraversalFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreSoftDeleteExpiredUploadsViaTraversalFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreSoftDeleteExpiredUploadsViaTraversalFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreSourcedCommitsWithoutCommittedAtFunc describes the behavior when the
// SourcedCommitsWithoutCommittedAt method of the parent MockStore instance
// is invoked.
type StoreSourcedCommitsWithoutCommittedAtFunc struct {
	defaultHook func(context.Context, int) ([]shared1.SourcedCommits, error)
	hooks       []func(context.Context, int) ([]shared1.SourcedCommits, error)
	history     []StoreSourcedCommitsWithoutCommittedAtFuncCall
	mutex       sync.Mutex
}

// SourcedCommitsWithoutCommittedAt delegates to the next hook function in
// the queue and stores the parameter and result values of this invocation.
func (m *MockStore) SourcedCommitsWithoutCommittedAt(v0 context.Context, v1 int) ([]shared1.SourcedCommits, error) {
	r0, r1 := m.SourcedCommitsWithoutCommittedAtFunc.nextHook()(v0, v1)
	m.SourcedCommitsWithoutCommittedAtFunc.appendCall(StoreSourcedCommitsWithoutCommittedAtFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// SourcedCommitsWithoutCommittedAt method of the parent MockStore instance
// is invoked and the hook queue is empty.
func (f *StoreSourcedCommitsWithoutCommittedAtFunc) SetDefaultHook(hook func(context.Context, int) ([]shared1.SourcedCommits, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SourcedCommitsWithoutCommittedAt method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreSourcedCommitsWithoutCommittedAtFunc) PushHook(hook func(context.Context, int) ([]shared1.SourcedCommits, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreSourcedCommitsWithoutCommittedAtFunc) SetDefaultReturn(r0 []shared1.SourcedCommits, r1 error) {
	f.SetDefaultHook(func(context.Context, int) ([]shared1.SourcedCommits, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreSourcedCommitsWithoutCommittedAtFunc) PushReturn(r0 []shared1.SourcedCommits, r1 error) {
	f.PushHook(func(context.Context, int) ([]shared1.SourcedCommits, error) {
		return r0, r1
	})
}

func (f *StoreSourcedCommitsWithoutCommittedAtFunc) nextHook() func(context.Context, int) ([]shared1.SourcedCommits, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreSourcedCommitsWithoutCommittedAtFunc) appendCall(r0 StoreSourcedCommitsWithoutCommittedAtFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// StoreSourcedCommitsWithoutCommittedAtFuncCall objects describing the
// invocations of this function.
func (f *StoreSourcedCommitsWithoutCommittedAtFunc) History() []StoreSourcedCommitsWithoutCommittedAtFuncCall {
	f.mutex.Lock()
	history := make([]StoreSourcedCommitsWithoutCommittedAtFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreSourcedCommitsWithoutCommittedAtFuncCall is an object that describes
// an invocation of method SourcedCommitsWithoutCommittedAt on an instance
// of MockStore.
type StoreSourcedCommitsWithoutCommittedAtFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared1.SourcedCommits
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreSourcedCommitsWithoutCommittedAtFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreSourcedCommitsWithoutCommittedAtFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreTransactFunc describes the behavior when the Transact method of the
// parent MockStore instance is invoked.
type StoreTransactFunc struct {
	defaultHook func(context.Context) (store.Store, error)
	hooks       []func(context.Context) (store.Store, error)
	history     []StoreTransactFuncCall
	mutex       sync.Mutex
}

// Transact delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Transact(v0 context.Context) (store.Store, error) {
	r0, r1 := m.TransactFunc.nextHook()(v0)
	m.TransactFunc.appendCall(StoreTransactFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Transact method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreTransactFunc) SetDefaultHook(hook func(context.Context) (store.Store, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Transact method of the parent MockStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreTransactFunc) PushHook(hook func(context.Context) (store.Store, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreTransactFunc) SetDefaultReturn(r0 store.Store, r1 error) {
	f.SetDefaultHook(func(context.Context) (store.Store, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreTransactFunc) PushReturn(r0 store.Store, r1 error) {
	f.PushHook(func(context.Context) (store.Store, error) {
		return r0, r1
	})
}

func (f *StoreTransactFunc) nextHook() func(context.Context) (store.Store, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreTransactFunc) appendCall(r0 StoreTransactFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreTransactFuncCall objects describing
// the invocations of this function.
func (f *StoreTransactFunc) History() []StoreTransactFuncCall {
	f.mutex.Lock()
	history := make([]StoreTransactFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreTransactFuncCall is an object that describes an invocation of method
// Transact on an instance of MockStore.
type StoreTransactFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Store
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreTransactFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreTransactFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreUpdateCommittedAtFunc describes the behavior when the
// UpdateCommittedAt method of the parent MockStore instance is invoked.
type StoreUpdateCommittedAtFunc struct {
	defaultHook func(context.Context, int, string, string) error
	hooks       []func(context.Context, int, string, string) error
	history     []StoreUpdateCommittedAtFuncCall
	mutex       sync.Mutex
}

// UpdateCommittedAt delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) UpdateCommittedAt(v0 context.Context, v1 int, v2 string, v3 string) error {
	r0 := m.UpdateCommittedAtFunc.nextHook()(v0, v1, v2, v3)
	m.UpdateCommittedAtFunc.appendCall(StoreUpdateCommittedAtFuncCall{v0, v1, v2, v3, r0})
	return r0
}

// SetDefaultHook sets function that is called when the UpdateCommittedAt
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreUpdateCommittedAtFunc) SetDefaultHook(hook func(context.Context, int, string, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateCommittedAt method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreUpdateCommittedAtFunc) PushHook(hook func(context.Context, int, string, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreUpdateCommittedAtFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string, string) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreUpdateCommittedAtFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string, string) error {
		return r0
	})
}

func (f *StoreUpdateCommittedAtFunc) nextHook() func(context.Context, int, string, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreUpdateCommittedAtFunc) appendCall(r0 StoreUpdateCommittedAtFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreUpdateCommittedAtFuncCall objects
// describing the invocations of this function.
func (f *StoreUpdateCommittedAtFunc) History() []StoreUpdateCommittedAtFuncCall {
	f.mutex.Lock()
	history := make([]StoreUpdateCommittedAtFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreUpdateCommittedAtFuncCall is an object that describes an invocation
// of method UpdateCommittedAt on an instance of MockStore.
type StoreUpdateCommittedAtFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreUpdateCommittedAtFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreUpdateCommittedAtFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreUpdatePackageReferencesFunc describes the behavior when the
// UpdatePackageReferences method of the parent MockStore instance is
// invoked.
type StoreUpdatePackageReferencesFunc struct {
	defaultHook func(context.Context, int, []precise.PackageReference) error
	hooks       []func(context.Context, int, []precise.PackageReference) error
	history     []StoreUpdatePackageReferencesFuncCall
	mutex       sync.Mutex
}

// UpdatePackageReferences delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) UpdatePackageReferences(v0 context.Context, v1 int, v2 []precise.PackageReference) error {
	r0 := m.UpdatePackageReferencesFunc.nextHook()(v0, v1, v2)
	m.UpdatePackageReferencesFunc.appendCall(StoreUpdatePackageReferencesFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdatePackageReferences method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreUpdatePackageReferencesFunc) SetDefaultHook(hook func(context.Context, int, []precise.PackageReference) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdatePackageReferences method of the parent MockStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreUpdatePackageReferencesFunc) PushHook(hook func(context.Context, int, []precise.PackageReference) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreUpdatePackageReferencesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, []precise.PackageReference) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreUpdatePackageReferencesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, []precise.PackageReference) error {
		return r0
	})
}

func (f *StoreUpdatePackageReferencesFunc) nextHook() func(context.Context, int, []precise.PackageReference) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreUpdatePackageReferencesFunc) appendCall(r0 StoreUpdatePackageReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreUpdatePackageReferencesFuncCall
// objects describing the invocations of this function.
func (f *StoreUpdatePackageReferencesFunc) History() []StoreUpdatePackageReferencesFuncCall {
	f.mutex.Lock()
	history := make([]StoreUpdatePackageReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreUpdatePackageReferencesFuncCall is an object that describes an
// invocation of method UpdatePackageReferences on an instance of MockStore.
type StoreUpdatePackageReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []precise.PackageReference
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreUpdatePackageReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreUpdatePackageReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreUpdatePackagesFunc describes the behavior when the UpdatePackages
// method of the parent MockStore instance is invoked.
type StoreUpdatePackagesFunc struct {
	defaultHook func(context.Context, int, []precise.Package) error
	hooks       []func(context.Context, int, []precise.Package) error
	history     []StoreUpdatePackagesFuncCall
	mutex       sync.Mutex
}

// UpdatePackages delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) UpdatePackages(v0 context.Context, v1 int, v2 []precise.Package) error {
	r0 := m.UpdatePackagesFunc.nextHook()(v0, v1, v2)
	m.UpdatePackagesFunc.appendCall(StoreUpdatePackagesFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the UpdatePackages
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreUpdatePackagesFunc) SetDefaultHook(hook func(context.Context, int, []precise.Package) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdatePackages method of the parent MockStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreUpdatePackagesFunc) PushHook(hook func(context.Context, int, []precise.Package) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreUpdatePackagesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, []precise.Package) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreUpdatePackagesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, []precise.Package) error {
		return r0
	})
}

func (f *StoreUpdatePackagesFunc) nextHook() func(context.Context, int, []precise.Package) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreUpdatePackagesFunc) appendCall(r0 StoreUpdatePackagesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreUpdatePackagesFuncCall objects
// describing the invocations of this function.
func (f *StoreUpdatePackagesFunc) History() []StoreUpdatePackagesFuncCall {
	f.mutex.Lock()
	history := make([]StoreUpdatePackagesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreUpdatePackagesFuncCall is an object that describes an invocation of
// method UpdatePackages on an instance of MockStore.
type StoreUpdatePackagesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []precise.Package
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreUpdatePackagesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreUpdatePackagesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreUpdateSourcedCommitsFunc describes the behavior when the
// UpdateSourcedCommits method of the parent MockStore instance is invoked.
type StoreUpdateSourcedCommitsFunc struct {
	defaultHook func(context.Context, int, string, time.Time) (int, error)
	hooks       []func(context.Context, int, string, time.Time) (int, error)
	history     []StoreUpdateSourcedCommitsFuncCall
	mutex       sync.Mutex
}

// UpdateSourcedCommits delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) UpdateSourcedCommits(v0 context.Context, v1 int, v2 string, v3 time.Time) (int, error) {
	r0, r1 := m.UpdateSourcedCommitsFunc.nextHook()(v0, v1, v2, v3)
	m.UpdateSourcedCommitsFunc.appendCall(StoreUpdateSourcedCommitsFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the UpdateSourcedCommits
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreUpdateSourcedCommitsFunc) SetDefaultHook(hook func(context.Context, int, string, time.Time) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateSourcedCommits method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreUpdateSourcedCommitsFunc) PushHook(hook func(context.Context, int, string, time.Time) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreUpdateSourcedCommitsFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, time.Time) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreUpdateSourcedCommitsFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int, string, time.Time) (int, error) {
		return r0, r1
	})
}

func (f *StoreUpdateSourcedCommitsFunc) nextHook() func(context.Context, int, string, time.Time) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreUpdateSourcedCommitsFunc) appendCall(r0 StoreUpdateSourcedCommitsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreUpdateSourcedCommitsFuncCall objects
// describing the invocations of this function.
func (f *StoreUpdateSourcedCommitsFunc) History() []StoreUpdateSourcedCommitsFuncCall {
	f.mutex.Lock()
	history := make([]StoreUpdateSourcedCommitsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreUpdateSourcedCommitsFuncCall is an object that describes an
// invocation of method UpdateSourcedCommits on an instance of MockStore.
type StoreUpdateSourcedCommitsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreUpdateSourcedCommitsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreUpdateSourcedCommitsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreUpdateUploadRetentionFunc describes the behavior when the
// UpdateUploadRetention method of the parent MockStore instance is invoked.
type StoreUpdateUploadRetentionFunc struct {
	defaultHook func(context.Context, []int, []int) error
	hooks       []func(context.Context, []int, []int) error
	history     []StoreUpdateUploadRetentionFuncCall
	mutex       sync.Mutex
}

// UpdateUploadRetention delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) UpdateUploadRetention(v0 context.Context, v1 []int, v2 []int) error {
	r0 := m.UpdateUploadRetentionFunc.nextHook()(v0, v1, v2)
	m.UpdateUploadRetentionFunc.appendCall(StoreUpdateUploadRetentionFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdateUploadRetention method of the parent MockStore instance is invoked
// and the hook queue is empty.
func (f *StoreUpdateUploadRetentionFunc) SetDefaultHook(hook func(context.Context, []int, []int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateUploadRetention method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreUpdateUploadRetentionFunc) PushHook(hook func(context.Context, []int, []int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreUpdateUploadRetentionFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, []int, []int) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreUpdateUploadRetentionFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, []int, []int) error {
		return r0
	})
}

func (f *StoreUpdateUploadRetentionFunc) nextHook() func(context.Context, []int, []int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreUpdateUploadRetentionFunc) appendCall(r0 StoreUpdateUploadRetentionFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreUpdateUploadRetentionFuncCall objects
// describing the invocations of this function.
func (f *StoreUpdateUploadRetentionFunc) History() []StoreUpdateUploadRetentionFuncCall {
	f.mutex.Lock()
	history := make([]StoreUpdateUploadRetentionFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreUpdateUploadRetentionFuncCall is an object that describes an
// invocation of method UpdateUploadRetention on an instance of MockStore.
type StoreUpdateUploadRetentionFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreUpdateUploadRetentionFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreUpdateUploadRetentionFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreUpdateUploadsVisibleToCommitsFunc describes the behavior when the
// UpdateUploadsVisibleToCommits method of the parent MockStore instance is
// invoked.
type StoreUpdateUploadsVisibleToCommitsFunc struct {
	defaultHook func(context.Context, int, *gitdomain.CommitGraph, map[string][]gitdomain.RefDescription, time.Duration, time.Duration, int, time.Time) error
	hooks       []func(context.Context, int, *gitdomain.CommitGraph, map[string][]gitdomain.RefDescription, time.Duration, time.Duration, int, time.Time) error
	history     []StoreUpdateUploadsVisibleToCommitsFuncCall
	mutex       sync.Mutex
}

// UpdateUploadsVisibleToCommits delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) UpdateUploadsVisibleToCommits(v0 context.Context, v1 int, v2 *gitdomain.CommitGraph, v3 map[string][]gitdomain.RefDescription, v4 time.Duration, v5 time.Duration, v6 int, v7 time.Time) error {
	r0 := m.UpdateUploadsVisibleToCommitsFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6, v7)
	m.UpdateUploadsVisibleToCommitsFunc.appendCall(StoreUpdateUploadsVisibleToCommitsFuncCall{v0, v1, v2, v3, v4, v5, v6, v7, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdateUploadsVisibleToCommits method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreUpdateUploadsVisibleToCommitsFunc) SetDefaultHook(hook func(context.Context, int, *gitdomain.CommitGraph, map[string][]gitdomain.RefDescription, time.Duration, time.Duration, int, time.Time) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateUploadsVisibleToCommits method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreUpdateUploadsVisibleToCommitsFunc) PushHook(hook func(context.Context, int, *gitdomain.CommitGraph, map[string][]gitdomain.RefDescription, time.Duration, time.Duration, int, time.Time) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreUpdateUploadsVisibleToCommitsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, *gitdomain.CommitGraph, map[string][]gitdomain.RefDescription, time.Duration, time.Duration, int, time.Time) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreUpdateUploadsVisibleToCommitsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, *gitdomain.CommitGraph, map[string][]gitdomain.RefDescription, time.Duration, time.Duration, int, time.Time) error {
		return r0
	})
}

func (f *StoreUpdateUploadsVisibleToCommitsFunc) nextHook() func(context.Context, int, *gitdomain.CommitGraph, map[string][]gitdomain.RefDescription, time.Duration, time.Duration, int, time.Time) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreUpdateUploadsVisibleToCommitsFunc) appendCall(r0 StoreUpdateUploadsVisibleToCommitsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreUpdateUploadsVisibleToCommitsFuncCall
// objects describing the invocations of this function.
func (f *StoreUpdateUploadsVisibleToCommitsFunc) History() []StoreUpdateUploadsVisibleToCommitsFuncCall {
	f.mutex.Lock()
	history := make([]StoreUpdateUploadsVisibleToCommitsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreUpdateUploadsVisibleToCommitsFuncCall is an object that describes an
// invocation of method UpdateUploadsVisibleToCommits on an instance of
// MockStore.
type StoreUpdateUploadsVisibleToCommitsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 *gitdomain.CommitGraph
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 map[string][]gitdomain.RefDescription
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 time.Duration
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 time.Duration
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 int
	// Arg7 is the value of the 8th argument passed to this method
	// invocation.
	Arg7 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreUpdateUploadsVisibleToCommitsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6, c.Arg7}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreUpdateUploadsVisibleToCommitsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreVacuumStaleDefinitionsAndReferencesFunc describes the behavior when
// the VacuumStaleDefinitionsAndReferences method of the parent MockStore
// instance is invoked.
type StoreVacuumStaleDefinitionsAndReferencesFunc struct {
	defaultHook func(context.Context, string) (int, int, error)
	hooks       []func(context.Context, string) (int, int, error)
	history     []StoreVacuumStaleDefinitionsAndReferencesFuncCall
	mutex       sync.Mutex
}

// VacuumStaleDefinitionsAndReferences delegates to the next hook function
// in the queue and stores the parameter and result values of this
// invocation.
func (m *MockStore) VacuumStaleDefinitionsAndReferences(v0 context.Context, v1 string) (int, int, error) {
	r0, r1, r2 := m.VacuumStaleDefinitionsAndReferencesFunc.nextHook()(v0, v1)
	m.VacuumStaleDefinitionsAndReferencesFunc.appendCall(StoreVacuumStaleDefinitionsAndReferencesFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// VacuumStaleDefinitionsAndReferences method of the parent MockStore
// instance is invoked and the hook queue is empty.
func (f *StoreVacuumStaleDefinitionsAndReferencesFunc) SetDefaultHook(hook func(context.Context, string) (int, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// VacuumStaleDefinitionsAndReferences method of the parent MockStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *StoreVacuumStaleDefinitionsAndReferencesFunc) PushHook(hook func(context.Context, string) (int, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreVacuumStaleDefinitionsAndReferencesFunc) SetDefaultReturn(r0 int, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, string) (int, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreVacuumStaleDefinitionsAndReferencesFunc) PushReturn(r0 int, r1 int, r2 error) {
	f.PushHook(func(context.Context, string) (int, int, error) {
		return r0, r1, r2
	})
}

func (f *StoreVacuumStaleDefinitionsAndReferencesFunc) nextHook() func(context.Context, string) (int, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreVacuumStaleDefinitionsAndReferencesFunc) appendCall(r0 StoreVacuumStaleDefinitionsAndReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// StoreVacuumStaleDefinitionsAndReferencesFuncCall objects describing the
// invocations of this function.
func (f *StoreVacuumStaleDefinitionsAndReferencesFunc) History() []StoreVacuumStaleDefinitionsAndReferencesFuncCall {
	f.mutex.Lock()
	history := make([]StoreVacuumStaleDefinitionsAndReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreVacuumStaleDefinitionsAndReferencesFuncCall is an object that
// describes an invocation of method VacuumStaleDefinitionsAndReferences on
// an instance of MockStore.
type StoreVacuumStaleDefinitionsAndReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreVacuumStaleDefinitionsAndReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreVacuumStaleDefinitionsAndReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreVacuumStaleGraphsFunc describes the behavior when the
// VacuumStaleGraphs method of the parent MockStore instance is invoked.
type StoreVacuumStaleGraphsFunc struct {
	defaultHook func(context.Context, string) (int, int, error)
	hooks       []func(context.Context, string) (int, int, error)
	history     []StoreVacuumStaleGraphsFuncCall
	mutex       sync.Mutex
}

// VacuumStaleGraphs delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) VacuumStaleGraphs(v0 context.Context, v1 string) (int, int, error) {
	r0, r1, r2 := m.VacuumStaleGraphsFunc.nextHook()(v0, v1)
	m.VacuumStaleGraphsFunc.appendCall(StoreVacuumStaleGraphsFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the VacuumStaleGraphs
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreVacuumStaleGraphsFunc) SetDefaultHook(hook func(context.Context, string) (int, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// VacuumStaleGraphs method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreVacuumStaleGraphsFunc) PushHook(hook func(context.Context, string) (int, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreVacuumStaleGraphsFunc) SetDefaultReturn(r0 int, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, string) (int, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreVacuumStaleGraphsFunc) PushReturn(r0 int, r1 int, r2 error) {
	f.PushHook(func(context.Context, string) (int, int, error) {
		return r0, r1, r2
	})
}

func (f *StoreVacuumStaleGraphsFunc) nextHook() func(context.Context, string) (int, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreVacuumStaleGraphsFunc) appendCall(r0 StoreVacuumStaleGraphsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreVacuumStaleGraphsFuncCall objects
// describing the invocations of this function.
func (f *StoreVacuumStaleGraphsFunc) History() []StoreVacuumStaleGraphsFuncCall {
	f.mutex.Lock()
	history := make([]StoreVacuumStaleGraphsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreVacuumStaleGraphsFuncCall is an object that describes an invocation
// of method VacuumStaleGraphs on an instance of MockStore.
type StoreVacuumStaleGraphsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreVacuumStaleGraphsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreVacuumStaleGraphsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreWorkerutilStoreFunc describes the behavior when the WorkerutilStore
// method of the parent MockStore instance is invoked.
type StoreWorkerutilStoreFunc struct {
	defaultHook func(*observation.Context) store1.Store[types.Upload]
	hooks       []func(*observation.Context) store1.Store[types.Upload]
	history     []StoreWorkerutilStoreFuncCall
	mutex       sync.Mutex
}

// WorkerutilStore delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) WorkerutilStore(v0 *observation.Context) store1.Store[types.Upload] {
	r0 := m.WorkerutilStoreFunc.nextHook()(v0)
	m.WorkerutilStoreFunc.appendCall(StoreWorkerutilStoreFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WorkerutilStore
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreWorkerutilStoreFunc) SetDefaultHook(hook func(*observation.Context) store1.Store[types.Upload]) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WorkerutilStore method of the parent MockStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreWorkerutilStoreFunc) PushHook(hook func(*observation.Context) store1.Store[types.Upload]) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreWorkerutilStoreFunc) SetDefaultReturn(r0 store1.Store[types.Upload]) {
	f.SetDefaultHook(func(*observation.Context) store1.Store[types.Upload] {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreWorkerutilStoreFunc) PushReturn(r0 store1.Store[types.Upload]) {
	f.PushHook(func(*observation.Context) store1.Store[types.Upload] {
		return r0
	})
}

func (f *StoreWorkerutilStoreFunc) nextHook() func(*observation.Context) store1.Store[types.Upload] {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreWorkerutilStoreFunc) appendCall(r0 StoreWorkerutilStoreFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreWorkerutilStoreFuncCall objects
// describing the invocations of this function.
func (f *StoreWorkerutilStoreFunc) History() []StoreWorkerutilStoreFuncCall {
	f.mutex.Lock()
	history := make([]StoreWorkerutilStoreFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreWorkerutilStoreFuncCall is an object that describes an invocation of
// method WorkerutilStore on an instance of MockStore.
type StoreWorkerutilStoreFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 *observation.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store1.Store[types.Upload]
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreWorkerutilStoreFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreWorkerutilStoreFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// MockRepoStore is a mock implementation of the RepoStore interface (from
// the package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/uploads/internal/background)
// used for unit testing.
type MockRepoStore struct {
	// GetFunc is an instance of a mock function object controlling the
	// behavior of the method Get.
	GetFunc *RepoStoreGetFunc
	// ResolveRevFunc is an instance of a mock function object controlling
	// the behavior of the method ResolveRev.
	ResolveRevFunc *RepoStoreResolveRevFunc
}

// NewMockRepoStore creates a new mock of the RepoStore interface. All
// methods return zero values for all results, unless overwritten.
func NewMockRepoStore() *MockRepoStore {
	return &MockRepoStore{
		GetFunc: &RepoStoreGetFunc{
			defaultHook: func(context.Context, api.RepoID) (r0 *types1.Repo, r1 error) {
				return
			},
		},
		ResolveRevFunc: &RepoStoreResolveRevFunc{
			defaultHook: func(context.Context, *types1.Repo, string) (r0 api.CommitID, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockRepoStore creates a new mock of the RepoStore interface. All
// methods panic on invocation, unless overwritten.
func NewStrictMockRepoStore() *MockRepoStore {
	return &MockRepoStore{
		GetFunc: &RepoStoreGetFunc{
			defaultHook: func(context.Context, api.RepoID) (*types1.Repo, error) {
				panic("unexpected invocation of MockRepoStore.Get")
			},
		},
		ResolveRevFunc: &RepoStoreResolveRevFunc{
			defaultHook: func(context.Context, *types1.Repo, string) (api.CommitID, error) {
				panic("unexpected invocation of MockRepoStore.ResolveRev")
			},
		},
	}
}

// NewMockRepoStoreFrom creates a new mock of the MockRepoStore interface.
// All methods delegate to the given implementation, unless overwritten.
func NewMockRepoStoreFrom(i RepoStore) *MockRepoStore {
	return &MockRepoStore{
		GetFunc: &RepoStoreGetFunc{
			defaultHook: i.Get,
		},
		ResolveRevFunc: &RepoStoreResolveRevFunc{
			defaultHook: i.ResolveRev,
		},
	}
}

// RepoStoreGetFunc describes the behavior when the Get method of the parent
// MockRepoStore instance is invoked.
type RepoStoreGetFunc struct {
	defaultHook func(context.Context, api.RepoID) (*types1.Repo, error)
	hooks       []func(context.Context, api.RepoID) (*types1.Repo, error)
	history     []RepoStoreGetFuncCall
	mutex       sync.Mutex
}

// Get delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockRepoStore) Get(v0 context.Context, v1 api.RepoID) (*types1.Repo, error) {
	r0, r1 := m.GetFunc.nextHook()(v0, v1)
	m.GetFunc.appendCall(RepoStoreGetFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Get method of the
// parent MockRepoStore instance is invoked and the hook queue is empty.
func (f *RepoStoreGetFunc) SetDefaultHook(hook func(context.Context, api.RepoID) (*types1.Repo, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Get method of the parent MockRepoStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *RepoStoreGetFunc) PushHook(hook func(context.Context, api.RepoID) (*types1.Repo, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *RepoStoreGetFunc) SetDefaultReturn(r0 *types1.Repo, r1 error) {
	f.SetDefaultHook(func(context.Context, api.RepoID) (*types1.Repo, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *RepoStoreGetFunc) PushReturn(r0 *types1.Repo, r1 error) {
	f.PushHook(func(context.Context, api.RepoID) (*types1.Repo, error) {
		return r0, r1
	})
}

func (f *RepoStoreGetFunc) nextHook() func(context.Context, api.RepoID) (*types1.Repo, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *RepoStoreGetFunc) appendCall(r0 RepoStoreGetFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of RepoStoreGetFuncCall objects describing the
// invocations of this function.
func (f *RepoStoreGetFunc) History() []RepoStoreGetFuncCall {
	f.mutex.Lock()
	history := make([]RepoStoreGetFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// RepoStoreGetFuncCall is an object that describes an invocation of method
// Get on an instance of MockRepoStore.
type RepoStoreGetFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 api.RepoID
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *types1.Repo
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c RepoStoreGetFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c RepoStoreGetFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// RepoStoreResolveRevFunc describes the behavior when the ResolveRev method
// of the parent MockRepoStore instance is invoked.
type RepoStoreResolveRevFunc struct {
	defaultHook func(context.Context, *types1.Repo, string) (api.CommitID, error)
	hooks       []func(context.Context, *types1.Repo, string) (api.CommitID, error)
	history     []RepoStoreResolveRevFuncCall
	mutex       sync.Mutex
}

// ResolveRev delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockRepoStore) ResolveRev(v0 context.Context, v1 *types1.Repo, v2 string) (api.CommitID, error) {
	r0, r1 := m.ResolveRevFunc.nextHook()(v0, v1, v2)
	m.ResolveRevFunc.appendCall(RepoStoreResolveRevFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ResolveRev method of
// the parent MockRepoStore instance is invoked and the hook queue is empty.
func (f *RepoStoreResolveRevFunc) SetDefaultHook(hook func(context.Context, *types1.Repo, string) (api.CommitID, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ResolveRev method of the parent MockRepoStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *RepoStoreResolveRevFunc) PushHook(hook func(context.Context, *types1.Repo, string) (api.CommitID, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *RepoStoreResolveRevFunc) SetDefaultReturn(r0 api.CommitID, r1 error) {
	f.SetDefaultHook(func(context.Context, *types1.Repo, string) (api.CommitID, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *RepoStoreResolveRevFunc) PushReturn(r0 api.CommitID, r1 error) {
	f.PushHook(func(context.Context, *types1.Repo, string) (api.CommitID, error) {
		return r0, r1
	})
}

func (f *RepoStoreResolveRevFunc) nextHook() func(context.Context, *types1.Repo, string) (api.CommitID, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *RepoStoreResolveRevFunc) appendCall(r0 RepoStoreResolveRevFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of RepoStoreResolveRevFuncCall objects
// describing the invocations of this function.
func (f *RepoStoreResolveRevFunc) History() []RepoStoreResolveRevFuncCall {
	f.mutex.Lock()
	history := make([]RepoStoreResolveRevFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// RepoStoreResolveRevFuncCall is an object that describes an invocation of
// method ResolveRev on an instance of MockRepoStore.
type RepoStoreResolveRevFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 *types1.Repo
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 api.CommitID
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c RepoStoreResolveRevFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c RepoStoreResolveRevFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockLsifStore is a mock implementation of the LsifStore interface (from
// the package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/uploads/internal/lsifstore)
// used for unit testing.
type MockLsifStore struct {
	// DeleteLsifDataByUploadIdsFunc is an instance of a mock function
	// object controlling the behavior of the method
	// DeleteLsifDataByUploadIds.
	DeleteLsifDataByUploadIdsFunc *LsifStoreDeleteLsifDataByUploadIdsFunc
	// DeleteUnreferencedDocumentsFunc is an instance of a mock function
	// object controlling the behavior of the method
	// DeleteUnreferencedDocuments.
	DeleteUnreferencedDocumentsFunc *LsifStoreDeleteUnreferencedDocumentsFunc
	// DoneFunc is an instance of a mock function object controlling the
	// behavior of the method Done.
	DoneFunc *LsifStoreDoneFunc
	// GetUploadDocumentsForPathFunc is an instance of a mock function
	// object controlling the behavior of the method
	// GetUploadDocumentsForPath.
	GetUploadDocumentsForPathFunc *LsifStoreGetUploadDocumentsForPathFunc
	// IDsWithMetaFunc is an instance of a mock function object controlling
	// the behavior of the method IDsWithMeta.
	IDsWithMetaFunc *LsifStoreIDsWithMetaFunc
	// InsertDefinitionsAndReferencesForDocumentFunc is an instance of a
	// mock function object controlling the behavior of the method
	// InsertDefinitionsAndReferencesForDocument.
	InsertDefinitionsAndReferencesForDocumentFunc *LsifStoreInsertDefinitionsAndReferencesForDocumentFunc
	// InsertMetadataFunc is an instance of a mock function object
	// controlling the behavior of the method InsertMetadata.
	InsertMetadataFunc *LsifStoreInsertMetadataFunc
	// NewSCIPWriterFunc is an instance of a mock function object
	// controlling the behavior of the method NewSCIPWriter.
	NewSCIPWriterFunc *LsifStoreNewSCIPWriterFunc
	// ReconcileCandidatesFunc is an instance of a mock function object
	// controlling the behavior of the method ReconcileCandidates.
	ReconcileCandidatesFunc *LsifStoreReconcileCandidatesFunc
	// ScanDocumentsFunc is an instance of a mock function object
	// controlling the behavior of the method ScanDocuments.
	ScanDocumentsFunc *LsifStoreScanDocumentsFunc
	// TransactFunc is an instance of a mock function object controlling the
	// behavior of the method Transact.
	TransactFunc *LsifStoreTransactFunc
}

// NewMockLsifStore creates a new mock of the LsifStore interface. All
// methods return zero values for all results, unless overwritten.
func NewMockLsifStore() *MockLsifStore {
	return &MockLsifStore{
		DeleteLsifDataByUploadIdsFunc: &LsifStoreDeleteLsifDataByUploadIdsFunc{
			defaultHook: func(context.Context, ...int) (r0 error) {
				return
			},
		},
		DeleteUnreferencedDocumentsFunc: &LsifStoreDeleteUnreferencedDocumentsFunc{
			defaultHook: func(context.Context, int, time.Duration, time.Time) (r0 int, r1 error) {
				return
			},
		},
		DoneFunc: &LsifStoreDoneFunc{
			defaultHook: func(error) (r0 error) {
				return
			},
		},
		GetUploadDocumentsForPathFunc: &LsifStoreGetUploadDocumentsForPathFunc{
			defaultHook: func(context.Context, int, string) (r0 []string, r1 int, r2 error) {
				return
			},
		},
		IDsWithMetaFunc: &LsifStoreIDsWithMetaFunc{
			defaultHook: func(context.Context, []int) (r0 []int, r1 error) {
				return
			},
		},
		InsertDefinitionsAndReferencesForDocumentFunc: &LsifStoreInsertDefinitionsAndReferencesForDocumentFunc{
			defaultHook: func(context.Context, shared1.ExportedUpload, string, int, func(ctx context.Context, upload shared1.ExportedUpload, rankingBatchSize int, rankingGraphKey string, path string, document *scip.Document) error) (r0 error) {
				return
			},
		},
		InsertMetadataFunc: &LsifStoreInsertMetadataFunc{
			defaultHook: func(context.Context, int, lsifstore.ProcessedMetadata) (r0 error) {
				return
			},
		},
		NewSCIPWriterFunc: &LsifStoreNewSCIPWriterFunc{
			defaultHook: func(context.Context, int) (r0 lsifstore.SCIPWriter, r1 error) {
				return
			},
		},
		ReconcileCandidatesFunc: &LsifStoreReconcileCandidatesFunc{
			defaultHook: func(context.Context, int) (r0 []int, r1 error) {
				return
			},
		},
		ScanDocumentsFunc: &LsifStoreScanDocumentsFunc{
			defaultHook: func(context.Context, int, func(path string, document *scip.Document) error) (r0 error) {
				return
			},
		},
		TransactFunc: &LsifStoreTransactFunc{
			defaultHook: func(context.Context) (r0 lsifstore.LsifStore, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockLsifStore creates a new mock of the LsifStore interface. All
// methods panic on invocation, unless overwritten.
func NewStrictMockLsifStore() *MockLsifStore {
	return &MockLsifStore{
		DeleteLsifDataByUploadIdsFunc: &LsifStoreDeleteLsifDataByUploadIdsFunc{
			defaultHook: func(context.Context, ...int) error {
				panic("unexpected invocation of MockLsifStore.DeleteLsifDataByUploadIds")
			},
		},
		DeleteUnreferencedDocumentsFunc: &LsifStoreDeleteUnreferencedDocumentsFunc{
			defaultHook: func(context.Context, int, time.Duration, time.Time) (int, error) {
				panic("unexpected invocation of MockLsifStore.DeleteUnreferencedDocuments")
			},
		},
		DoneFunc: &LsifStoreDoneFunc{
			defaultHook: func(error) error {
				panic("unexpected invocation of MockLsifStore.Done")
			},
		},
		GetUploadDocumentsForPathFunc: &LsifStoreGetUploadDocumentsForPathFunc{
			defaultHook: func(context.Context, int, string) ([]string, int, error) {
				panic("unexpected invocation of MockLsifStore.GetUploadDocumentsForPath")
			},
		},
		IDsWithMetaFunc: &LsifStoreIDsWithMetaFunc{
			defaultHook: func(context.Context, []int) ([]int, error) {
				panic("unexpected invocation of MockLsifStore.IDsWithMeta")
			},
		},
		InsertDefinitionsAndReferencesForDocumentFunc: &LsifStoreInsertDefinitionsAndReferencesForDocumentFunc{
			defaultHook: func(context.Context, shared1.ExportedUpload, string, int, func(ctx context.Context, upload shared1.ExportedUpload, rankingBatchSize int, rankingGraphKey string, path string, document *scip.Document) error) error {
				panic("unexpected invocation of MockLsifStore.InsertDefinitionsAndReferencesForDocument")
			},
		},
		InsertMetadataFunc: &LsifStoreInsertMetadataFunc{
			defaultHook: func(context.Context, int, lsifstore.ProcessedMetadata) error {
				panic("unexpected invocation of MockLsifStore.InsertMetadata")
			},
		},
		NewSCIPWriterFunc: &LsifStoreNewSCIPWriterFunc{
			defaultHook: func(context.Context, int) (lsifstore.SCIPWriter, error) {
				panic("unexpected invocation of MockLsifStore.NewSCIPWriter")
			},
		},
		ReconcileCandidatesFunc: &LsifStoreReconcileCandidatesFunc{
			defaultHook: func(context.Context, int) ([]int, error) {
				panic("unexpected invocation of MockLsifStore.ReconcileCandidates")
			},
		},
		ScanDocumentsFunc: &LsifStoreScanDocumentsFunc{
			defaultHook: func(context.Context, int, func(path string, document *scip.Document) error) error {
				panic("unexpected invocation of MockLsifStore.ScanDocuments")
			},
		},
		TransactFunc: &LsifStoreTransactFunc{
			defaultHook: func(context.Context) (lsifstore.LsifStore, error) {
				panic("unexpected invocation of MockLsifStore.Transact")
			},
		},
	}
}

// NewMockLsifStoreFrom creates a new mock of the MockLsifStore interface.
// All methods delegate to the given implementation, unless overwritten.
func NewMockLsifStoreFrom(i lsifstore.LsifStore) *MockLsifStore {
	return &MockLsifStore{
		DeleteLsifDataByUploadIdsFunc: &LsifStoreDeleteLsifDataByUploadIdsFunc{
			defaultHook: i.DeleteLsifDataByUploadIds,
		},
		DeleteUnreferencedDocumentsFunc: &LsifStoreDeleteUnreferencedDocumentsFunc{
			defaultHook: i.DeleteUnreferencedDocuments,
		},
		DoneFunc: &LsifStoreDoneFunc{
			defaultHook: i.Done,
		},
		GetUploadDocumentsForPathFunc: &LsifStoreGetUploadDocumentsForPathFunc{
			defaultHook: i.GetUploadDocumentsForPath,
		},
		IDsWithMetaFunc: &LsifStoreIDsWithMetaFunc{
			defaultHook: i.IDsWithMeta,
		},
		InsertDefinitionsAndReferencesForDocumentFunc: &LsifStoreInsertDefinitionsAndReferencesForDocumentFunc{
			defaultHook: i.InsertDefinitionsAndReferencesForDocument,
		},
		InsertMetadataFunc: &LsifStoreInsertMetadataFunc{
			defaultHook: i.InsertMetadata,
		},
		NewSCIPWriterFunc: &LsifStoreNewSCIPWriterFunc{
			defaultHook: i.NewSCIPWriter,
		},
		ReconcileCandidatesFunc: &LsifStoreReconcileCandidatesFunc{
			defaultHook: i.ReconcileCandidates,
		},
		ScanDocumentsFunc: &LsifStoreScanDocumentsFunc{
			defaultHook: i.ScanDocuments,
		},
		TransactFunc: &LsifStoreTransactFunc{
			defaultHook: i.Transact,
		},
	}
}

// LsifStoreDeleteLsifDataByUploadIdsFunc describes the behavior when the
// DeleteLsifDataByUploadIds method of the parent MockLsifStore instance is
// invoked.
type LsifStoreDeleteLsifDataByUploadIdsFunc struct {
	defaultHook func(context.Context, ...int) error
	hooks       []func(context.Context, ...int) error
	history     []LsifStoreDeleteLsifDataByUploadIdsFuncCall
	mutex       sync.Mutex
}

// DeleteLsifDataByUploadIds delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockLsifStore) DeleteLsifDataByUploadIds(v0 context.Context, v1 ...int) error {
	r0 := m.DeleteLsifDataByUploadIdsFunc.nextHook()(v0, v1...)
	m.DeleteLsifDataByUploadIdsFunc.appendCall(LsifStoreDeleteLsifDataByUploadIdsFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// DeleteLsifDataByUploadIds method of the parent MockLsifStore instance is
// invoked and the hook queue is empty.
func (f *LsifStoreDeleteLsifDataByUploadIdsFunc) SetDefaultHook(hook func(context.Context, ...int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteLsifDataByUploadIds method of the parent MockLsifStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *LsifStoreDeleteLsifDataByUploadIdsFunc) PushHook(hook func(context.Context, ...int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LsifStoreDeleteLsifDataByUploadIdsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, ...int) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LsifStoreDeleteLsifDataByUploadIdsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, ...int) error {
		return r0
	})
}

func (f *LsifStoreDeleteLsifDataByUploadIdsFunc) nextHook() func(context.Context, ...int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LsifStoreDeleteLsifDataByUploadIdsFunc) appendCall(r0 LsifStoreDeleteLsifDataByUploadIdsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LsifStoreDeleteLsifDataByUploadIdsFuncCall
// objects describing the invocations of this function.
func (f *LsifStoreDeleteLsifDataByUploadIdsFunc) History() []LsifStoreDeleteLsifDataByUploadIdsFuncCall {
	f.mutex.Lock()
	history := make([]LsifStoreDeleteLsifDataByUploadIdsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LsifStoreDeleteLsifDataByUploadIdsFuncCall is an object that describes an
// invocation of method DeleteLsifDataByUploadIds on an instance of
// MockLsifStore.
type LsifStoreDeleteLsifDataByUploadIdsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c LsifStoreDeleteLsifDataByUploadIdsFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LsifStoreDeleteLsifDataByUploadIdsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LsifStoreDeleteUnreferencedDocumentsFunc describes the behavior when the
// DeleteUnreferencedDocuments method of the parent MockLsifStore instance
// is invoked.
type LsifStoreDeleteUnreferencedDocumentsFunc struct {
	defaultHook func(context.Context, int, time.Duration, time.Time) (int, error)
	hooks       []func(context.Context, int, time.Duration, time.Time) (int, error)
	history     []LsifStoreDeleteUnreferencedDocumentsFuncCall
	mutex       sync.Mutex
}

// DeleteUnreferencedDocuments delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockLsifStore) DeleteUnreferencedDocuments(v0 context.Context, v1 int, v2 time.Duration, v3 time.Time) (int, error) {
	r0, r1 := m.DeleteUnreferencedDocumentsFunc.nextHook()(v0, v1, v2, v3)
	m.DeleteUnreferencedDocumentsFunc.appendCall(LsifStoreDeleteUnreferencedDocumentsFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// DeleteUnreferencedDocuments method of the parent MockLsifStore instance
// is invoked and the hook queue is empty.
func (f *LsifStoreDeleteUnreferencedDocumentsFunc) SetDefaultHook(hook func(context.Context, int, time.Duration, time.Time) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteUnreferencedDocuments method of the parent MockLsifStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *LsifStoreDeleteUnreferencedDocumentsFunc) PushHook(hook func(context.Context, int, time.Duration, time.Time) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LsifStoreDeleteUnreferencedDocumentsFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int, time.Duration, time.Time) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LsifStoreDeleteUnreferencedDocumentsFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int, time.Duration, time.Time) (int, error) {
		return r0, r1
	})
}

func (f *LsifStoreDeleteUnreferencedDocumentsFunc) nextHook() func(context.Context, int, time.Duration, time.Time) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LsifStoreDeleteUnreferencedDocumentsFunc) appendCall(r0 LsifStoreDeleteUnreferencedDocumentsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// LsifStoreDeleteUnreferencedDocumentsFuncCall objects describing the
// invocations of this function.
func (f *LsifStoreDeleteUnreferencedDocumentsFunc) History() []LsifStoreDeleteUnreferencedDocumentsFuncCall {
	f.mutex.Lock()
	history := make([]LsifStoreDeleteUnreferencedDocumentsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LsifStoreDeleteUnreferencedDocumentsFuncCall is an object that describes
// an invocation of method DeleteUnreferencedDocuments on an instance of
// MockLsifStore.
type LsifStoreDeleteUnreferencedDocumentsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Duration
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LsifStoreDeleteUnreferencedDocumentsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LsifStoreDeleteUnreferencedDocumentsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LsifStoreDoneFunc describes the behavior when the Done method of the
// parent MockLsifStore instance is invoked.
type LsifStoreDoneFunc struct {
	defaultHook func(error) error
	hooks       []func(error) error
	history     []LsifStoreDoneFuncCall
	mutex       sync.Mutex
}

// Done delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLsifStore) Done(v0 error) error {
	r0 := m.DoneFunc.nextHook()(v0)
	m.DoneFunc.appendCall(LsifStoreDoneFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Done method of the
// parent MockLsifStore instance is invoked and the hook queue is empty.
func (f *LsifStoreDoneFunc) SetDefaultHook(hook func(error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Done method of the parent MockLsifStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *LsifStoreDoneFunc) PushHook(hook func(error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LsifStoreDoneFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(error) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LsifStoreDoneFunc) PushReturn(r0 error) {
	f.PushHook(func(error) error {
		return r0
	})
}

func (f *LsifStoreDoneFunc) nextHook() func(error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LsifStoreDoneFunc) appendCall(r0 LsifStoreDoneFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LsifStoreDoneFuncCall objects describing
// the invocations of this function.
func (f *LsifStoreDoneFunc) History() []LsifStoreDoneFuncCall {
	f.mutex.Lock()
	history := make([]LsifStoreDoneFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LsifStoreDoneFuncCall is an object that describes an invocation of method
// Done on an instance of MockLsifStore.
type LsifStoreDoneFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LsifStoreDoneFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LsifStoreDoneFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LsifStoreGetUploadDocumentsForPathFunc describes the behavior when the
// GetUploadDocumentsForPath method of the parent MockLsifStore instance is
// invoked.
type LsifStoreGetUploadDocumentsForPathFunc struct {
	defaultHook func(context.Context, int, string) ([]string, int, error)
	hooks       []func(context.Context, int, string) ([]string, int, error)
	history     []LsifStoreGetUploadDocumentsForPathFuncCall
	mutex       sync.Mutex
}

// GetUploadDocumentsForPath delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockLsifStore) GetUploadDocumentsForPath(v0 context.Context, v1 int, v2 string) ([]string, int, error) {
	r0, r1, r2 := m.GetUploadDocumentsForPathFunc.nextHook()(v0, v1, v2)
	m.GetUploadDocumentsForPathFunc.appendCall(LsifStoreGetUploadDocumentsForPathFuncCall{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// GetUploadDocumentsForPath method of the parent MockLsifStore instance is
// invoked and the hook queue is empty.
func (f *LsifStoreGetUploadDocumentsForPathFunc) SetDefaultHook(hook func(context.Context, int, string) ([]string, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadDocumentsForPath method of the parent MockLsifStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *LsifStoreGetUploadDocumentsForPathFunc) PushHook(hook func(context.Context, int, string) ([]string, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LsifStoreGetUploadDocumentsForPathFunc) SetDefaultReturn(r0 []string, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string) ([]string, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LsifStoreGetUploadDocumentsForPathFunc) PushReturn(r0 []string, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string) ([]string, int, error) {
		return r0, r1, r2
	})
}

func (f *LsifStoreGetUploadDocumentsForPathFunc) nextHook() func(context.Context, int, string) ([]string, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LsifStoreGetUploadDocumentsForPathFunc) appendCall(r0 LsifStoreGetUploadDocumentsForPathFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LsifStoreGetUploadDocumentsForPathFuncCall
// objects describing the invocations of this function.
func (f *LsifStoreGetUploadDocumentsForPathFunc) History() []LsifStoreGetUploadDocumentsForPathFuncCall {
	f.mutex.Lock()
	history := make([]LsifStoreGetUploadDocumentsForPathFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LsifStoreGetUploadDocumentsForPathFuncCall is an object that describes an
// invocation of method GetUploadDocumentsForPath on an instance of
// MockLsifStore.
type LsifStoreGetUploadDocumentsForPathFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LsifStoreGetUploadDocumentsForPathFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LsifStoreGetUploadDocumentsForPathFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// LsifStoreIDsWithMetaFunc describes the behavior when the IDsWithMeta
// method of the parent MockLsifStore instance is invoked.
type LsifStoreIDsWithMetaFunc struct {
	defaultHook func(context.Context, []int) ([]int, error)
	hooks       []func(context.Context, []int) ([]int, error)
	history     []LsifStoreIDsWithMetaFuncCall
	mutex       sync.Mutex
}

// IDsWithMeta delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockLsifStore) IDsWithMeta(v0 context.Context, v1 []int) ([]int, error) {
	r0, r1 := m.IDsWithMetaFunc.nextHook()(v0, v1)
	m.IDsWithMetaFunc.appendCall(LsifStoreIDsWithMetaFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the IDsWithMeta method
// of the parent MockLsifStore instance is invoked and the hook queue is
// empty.
func (f *LsifStoreIDsWithMetaFunc) SetDefaultHook(hook func(context.Context, []int) ([]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// IDsWithMeta method of the parent MockLsifStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LsifStoreIDsWithMetaFunc) PushHook(hook func(context.Context, []int) ([]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LsifStoreIDsWithMetaFunc) SetDefaultReturn(r0 []int, r1 error) {
	f.SetDefaultHook(func(context.Context, []int) ([]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LsifStoreIDsWithMetaFunc) PushReturn(r0 []int, r1 error) {
	f.PushHook(func(context.Context, []int) ([]int, error) {
		return r0, r1
	})
}

func (f *LsifStoreIDsWithMetaFunc) nextHook() func(context.Context, []int) ([]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LsifStoreIDsWithMetaFunc) appendCall(r0 LsifStoreIDsWithMetaFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LsifStoreIDsWithMetaFuncCall objects
// describing the invocations of this function.
func (f *LsifStoreIDsWithMetaFunc) History() []LsifStoreIDsWithMetaFuncCall {
	f.mutex.Lock()
	history := make([]LsifStoreIDsWithMetaFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LsifStoreIDsWithMetaFuncCall is an object that describes an invocation of
// method IDsWithMeta on an instance of MockLsifStore.
type LsifStoreIDsWithMetaFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LsifStoreIDsWithMetaFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LsifStoreIDsWithMetaFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LsifStoreInsertDefinitionsAndReferencesForDocumentFunc describes the
// behavior when the InsertDefinitionsAndReferencesForDocument method of the
// parent MockLsifStore instance is invoked.
type LsifStoreInsertDefinitionsAndReferencesForDocumentFunc struct {
	defaultHook func(context.Context, shared1.ExportedUpload, string, int, func(ctx context.Context, upload shared1.ExportedUpload, rankingBatchSize int, rankingGraphKey string, path string, document *scip.Document) error) error
	hooks       []func(context.Context, shared1.ExportedUpload, string, int, func(ctx context.Context, upload shared1.ExportedUpload, rankingBatchSize int, rankingGraphKey string, path string, document *scip.Document) error) error
	history     []LsifStoreInsertDefinitionsAndReferencesForDocumentFuncCall
	mutex       sync.Mutex
}

// InsertDefinitionsAndReferencesForDocument delegates to the next hook
// function in the queue and stores the parameter and result values of this
// invocation.
func (m *MockLsifStore) InsertDefinitionsAndReferencesForDocument(v0 context.Context, v1 shared1.ExportedUpload, v2 string, v3 int, v4 func(ctx context.Context, upload shared1.ExportedUpload, rankingBatchSize int, rankingGraphKey string, path string, document *scip.Document) error) error {
	r0 := m.InsertDefinitionsAndReferencesForDocumentFunc.nextHook()(v0, v1, v2, v3, v4)
	m.InsertDefinitionsAndReferencesForDocumentFunc.appendCall(LsifStoreInsertDefinitionsAndReferencesForDocumentFuncCall{v0, v1, v2, v3, v4, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// InsertDefinitionsAndReferencesForDocument method of the parent
// MockLsifStore instance is invoked and the hook queue is empty.
func (f *LsifStoreInsertDefinitionsAndReferencesForDocumentFunc) SetDefaultHook(hook func(context.Context, shared1.ExportedUpload, string, int, func(ctx context.Context, upload shared1.ExportedUpload, rankingBatchSize int, rankingGraphKey string, path string, document *scip.Document) error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertDefinitionsAndReferencesForDocument method of the parent
// MockLsifStore instance invokes the hook at the front of the queue and
// discards it. After the queue is empty, the default hook function is
// invoked for any future action.
func (f *LsifStoreInsertDefinitionsAndReferencesForDocumentFunc) PushHook(hook func(context.Context, shared1.ExportedUpload, string, int, func(ctx context.Context, upload shared1.ExportedUpload, rankingBatchSize int, rankingGraphKey string, path string, document *scip.Document) error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LsifStoreInsertDefinitionsAndReferencesForDocumentFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, shared1.ExportedUpload, string, int, func(ctx context.Context, upload shared1.ExportedUpload, rankingBatchSize int, rankingGraphKey string, path string, document *scip.Document) error) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LsifStoreInsertDefinitionsAndReferencesForDocumentFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, shared1.ExportedUpload, string, int, func(ctx context.Context, upload shared1.ExportedUpload, rankingBatchSize int, rankingGraphKey string, path string, document *scip.Document) error) error {
		return r0
	})
}

func (f *LsifStoreInsertDefinitionsAndReferencesForDocumentFunc) nextHook() func(context.Context, shared1.ExportedUpload, string, int, func(ctx context.Context, upload shared1.ExportedUpload, rankingBatchSize int, rankingGraphKey string, path string, document *scip.Document) error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LsifStoreInsertDefinitionsAndReferencesForDocumentFunc) appendCall(r0 LsifStoreInsertDefinitionsAndReferencesForDocumentFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// LsifStoreInsertDefinitionsAndReferencesForDocumentFuncCall objects
// describing the invocations of this function.
func (f *LsifStoreInsertDefinitionsAndReferencesForDocumentFunc) History() []LsifStoreInsertDefinitionsAndReferencesForDocumentFuncCall {
	f.mutex.Lock()
	history := make([]LsifStoreInsertDefinitionsAndReferencesForDocumentFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LsifStoreInsertDefinitionsAndReferencesForDocumentFuncCall is an object
// that describes an invocation of method
// InsertDefinitionsAndReferencesForDocument on an instance of
// MockLsifStore.
type LsifStoreInsertDefinitionsAndReferencesForDocumentFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 shared1.ExportedUpload
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 func(ctx context.Context, upload shared1.ExportedUpload, rankingBatchSize int, rankingGraphKey string, path string, document *scip.Document) error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LsifStoreInsertDefinitionsAndReferencesForDocumentFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LsifStoreInsertDefinitionsAndReferencesForDocumentFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LsifStoreInsertMetadataFunc describes the behavior when the
// InsertMetadata method of the parent MockLsifStore instance is invoked.
type LsifStoreInsertMetadataFunc struct {
	defaultHook func(context.Context, int, lsifstore.ProcessedMetadata) error
	hooks       []func(context.Context, int, lsifstore.ProcessedMetadata) error
	history     []LsifStoreInsertMetadataFuncCall
	mutex       sync.Mutex
}

// InsertMetadata delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLsifStore) InsertMetadata(v0 context.Context, v1 int, v2 lsifstore.ProcessedMetadata) error {
	r0 := m.InsertMetadataFunc.nextHook()(v0, v1, v2)
	m.InsertMetadataFunc.appendCall(LsifStoreInsertMetadataFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the InsertMetadata
// method of the parent MockLsifStore instance is invoked and the hook queue
// is empty.
func (f *LsifStoreInsertMetadataFunc) SetDefaultHook(hook func(context.Context, int, lsifstore.ProcessedMetadata) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertMetadata method of the parent MockLsifStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LsifStoreInsertMetadataFunc) PushHook(hook func(context.Context, int, lsifstore.ProcessedMetadata) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LsifStoreInsertMetadataFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, lsifstore.ProcessedMetadata) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LsifStoreInsertMetadataFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, lsifstore.ProcessedMetadata) error {
		return r0
	})
}

func (f *LsifStoreInsertMetadataFunc) nextHook() func(context.Context, int, lsifstore.ProcessedMetadata) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LsifStoreInsertMetadataFunc) appendCall(r0 LsifStoreInsertMetadataFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LsifStoreInsertMetadataFuncCall objects
// describing the invocations of this function.
func (f *LsifStoreInsertMetadataFunc) History() []LsifStoreInsertMetadataFuncCall {
	f.mutex.Lock()
	history := make([]LsifStoreInsertMetadataFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LsifStoreInsertMetadataFuncCall is an object that describes an invocation
// of method InsertMetadata on an instance of MockLsifStore.
type LsifStoreInsertMetadataFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 lsifstore.ProcessedMetadata
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LsifStoreInsertMetadataFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LsifStoreInsertMetadataFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LsifStoreNewSCIPWriterFunc describes the behavior when the NewSCIPWriter
// method of the parent MockLsifStore instance is invoked.
type LsifStoreNewSCIPWriterFunc struct {
	defaultHook func(context.Context, int) (lsifstore.SCIPWriter, error)
	hooks       []func(context.Context, int) (lsifstore.SCIPWriter, error)
	history     []LsifStoreNewSCIPWriterFuncCall
	mutex       sync.Mutex
}

// NewSCIPWriter delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockLsifStore) NewSCIPWriter(v0 context.Context, v1 int) (lsifstore.SCIPWriter, error) {
	r0, r1 := m.NewSCIPWriterFunc.nextHook()(v0, v1)
	m.NewSCIPWriterFunc.appendCall(LsifStoreNewSCIPWriterFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the NewSCIPWriter method
// of the parent MockLsifStore instance is invoked and the hook queue is
// empty.
func (f *LsifStoreNewSCIPWriterFunc) SetDefaultHook(hook func(context.Context, int) (lsifstore.SCIPWriter, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// NewSCIPWriter method of the parent MockLsifStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LsifStoreNewSCIPWriterFunc) PushHook(hook func(context.Context, int) (lsifstore.SCIPWriter, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LsifStoreNewSCIPWriterFunc) SetDefaultReturn(r0 lsifstore.SCIPWriter, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (lsifstore.SCIPWriter, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LsifStoreNewSCIPWriterFunc) PushReturn(r0 lsifstore.SCIPWriter, r1 error) {
	f.PushHook(func(context.Context, int) (lsifstore.SCIPWriter, error) {
		return r0, r1
	})
}

func (f *LsifStoreNewSCIPWriterFunc) nextHook() func(context.Context, int) (lsifstore.SCIPWriter, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LsifStoreNewSCIPWriterFunc) appendCall(r0 LsifStoreNewSCIPWriterFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LsifStoreNewSCIPWriterFuncCall objects
// describing the invocations of this function.
func (f *LsifStoreNewSCIPWriterFunc) History() []LsifStoreNewSCIPWriterFuncCall {
	f.mutex.Lock()
	history := make([]LsifStoreNewSCIPWriterFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LsifStoreNewSCIPWriterFuncCall is an object that describes an invocation
// of method NewSCIPWriter on an instance of MockLsifStore.
type LsifStoreNewSCIPWriterFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 lsifstore.SCIPWriter
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LsifStoreNewSCIPWriterFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LsifStoreNewSCIPWriterFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LsifStoreReconcileCandidatesFunc describes the behavior when the
// ReconcileCandidates method of the parent MockLsifStore instance is
// invoked.
type LsifStoreReconcileCandidatesFunc struct {
	defaultHook func(context.Context, int) ([]int, error)
	hooks       []func(context.Context, int) ([]int, error)
	history     []LsifStoreReconcileCandidatesFuncCall
	mutex       sync.Mutex
}

// ReconcileCandidates delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLsifStore) ReconcileCandidates(v0 context.Context, v1 int) ([]int, error) {
	r0, r1 := m.ReconcileCandidatesFunc.nextHook()(v0, v1)
	m.ReconcileCandidatesFunc.appendCall(LsifStoreReconcileCandidatesFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ReconcileCandidates
// method of the parent MockLsifStore instance is invoked and the hook queue
// is empty.
func (f *LsifStoreReconcileCandidatesFunc) SetDefaultHook(hook func(context.Context, int) ([]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReconcileCandidates method of the parent MockLsifStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *LsifStoreReconcileCandidatesFunc) PushHook(hook func(context.Context, int) ([]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LsifStoreReconcileCandidatesFunc) SetDefaultReturn(r0 []int, r1 error) {
	f.SetDefaultHook(func(context.Context, int) ([]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LsifStoreReconcileCandidatesFunc) PushReturn(r0 []int, r1 error) {
	f.PushHook(func(context.Context, int) ([]int, error) {
		return r0, r1
	})
}

func (f *LsifStoreReconcileCandidatesFunc) nextHook() func(context.Context, int) ([]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LsifStoreReconcileCandidatesFunc) appendCall(r0 LsifStoreReconcileCandidatesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LsifStoreReconcileCandidatesFuncCall
// objects describing the invocations of this function.
func (f *LsifStoreReconcileCandidatesFunc) History() []LsifStoreReconcileCandidatesFuncCall {
	f.mutex.Lock()
	history := make([]LsifStoreReconcileCandidatesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LsifStoreReconcileCandidatesFuncCall is an object that describes an
// invocation of method ReconcileCandidates on an instance of MockLsifStore.
type LsifStoreReconcileCandidatesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LsifStoreReconcileCandidatesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LsifStoreReconcileCandidatesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LsifStoreScanDocumentsFunc describes the behavior when the ScanDocuments
// method of the parent MockLsifStore instance is invoked.
type LsifStoreScanDocumentsFunc struct {
	defaultHook func(context.Context, int, func(path string, document *scip.Document) error) error
	hooks       []func(context.Context, int, func(path string, document *scip.Document) error) error
	history     []LsifStoreScanDocumentsFuncCall
	mutex       sync.Mutex
}

// ScanDocuments delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockLsifStore) ScanDocuments(v0 context.Context, v1 int, v2 func(path string, document *scip.Document) error) error {
	r0 := m.ScanDocumentsFunc.nextHook()(v0, v1, v2)
	m.ScanDocumentsFunc.appendCall(LsifStoreScanDocumentsFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the ScanDocuments method
// of the parent MockLsifStore instance is invoked and the hook queue is
// empty.
func (f *LsifStoreScanDocumentsFunc) SetDefaultHook(hook func(context.Context, int, func(path string, document *scip.Document) error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ScanDocuments method of the parent MockLsifStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LsifStoreScanDocumentsFunc) PushHook(hook func(context.Context, int, func(path string, document *scip.Document) error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LsifStoreScanDocumentsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, func(path string, document *scip.Document) error) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LsifStoreScanDocumentsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, func(path string, document *scip.Document) error) error {
		return r0
	})
}

func (f *LsifStoreScanDocumentsFunc) nextHook() func(context.Context, int, func(path string, document *scip.Document) error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LsifStoreScanDocumentsFunc) appendCall(r0 LsifStoreScanDocumentsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LsifStoreScanDocumentsFuncCall objects
// describing the invocations of this function.
func (f *LsifStoreScanDocumentsFunc) History() []LsifStoreScanDocumentsFuncCall {
	f.mutex.Lock()
	history := make([]LsifStoreScanDocumentsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LsifStoreScanDocumentsFuncCall is an object that describes an invocation
// of method ScanDocuments on an instance of MockLsifStore.
type LsifStoreScanDocumentsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 func(path string, document *scip.Document) error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LsifStoreScanDocumentsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LsifStoreScanDocumentsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LsifStoreTransactFunc describes the behavior when the Transact method of
// the parent MockLsifStore instance is invoked.
type LsifStoreTransactFunc struct {
	defaultHook func(context.Context) (lsifstore.LsifStore, error)
	hooks       []func(context.Context) (lsifstore.LsifStore, error)
	history     []LsifStoreTransactFuncCall
	mutex       sync.Mutex
}

// Transact delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLsifStore) Transact(v0 context.Context) (lsifstore.LsifStore, error) {
	r0, r1 := m.TransactFunc.nextHook()(v0)
	m.TransactFunc.appendCall(LsifStoreTransactFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Transact method of
// the parent MockLsifStore instance is invoked and the hook queue is empty.
func (f *LsifStoreTransactFunc) SetDefaultHook(hook func(context.Context) (lsifstore.LsifStore, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Transact method of the parent MockLsifStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LsifStoreTransactFunc) PushHook(hook func(context.Context) (lsifstore.LsifStore, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LsifStoreTransactFunc) SetDefaultReturn(r0 lsifstore.LsifStore, r1 error) {
	f.SetDefaultHook(func(context.Context) (lsifstore.LsifStore, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LsifStoreTransactFunc) PushReturn(r0 lsifstore.LsifStore, r1 error) {
	f.PushHook(func(context.Context) (lsifstore.LsifStore, error) {
		return r0, r1
	})
}

func (f *LsifStoreTransactFunc) nextHook() func(context.Context) (lsifstore.LsifStore, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LsifStoreTransactFunc) appendCall(r0 LsifStoreTransactFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LsifStoreTransactFuncCall objects
// describing the invocations of this function.
func (f *LsifStoreTransactFunc) History() []LsifStoreTransactFuncCall {
	f.mutex.Lock()
	history := make([]LsifStoreTransactFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LsifStoreTransactFuncCall is an object that describes an invocation of
// method Transact on an instance of MockLsifStore.
type LsifStoreTransactFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 lsifstore.LsifStore
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LsifStoreTransactFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LsifStoreTransactFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockSCIPWriter is a mock implementation of the SCIPWriter interface (from
// the package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/uploads/internal/lsifstore)
// used for unit testing.
type MockSCIPWriter struct {
	// FlushFunc is an instance of a mock function object controlling the
	// behavior of the method Flush.
	FlushFunc *SCIPWriterFlushFunc
	// InsertDocumentFunc is an instance of a mock function object
	// controlling the behavior of the method InsertDocument.
	InsertDocumentFunc *SCIPWriterInsertDocumentFunc
}

// NewMockSCIPWriter creates a new mock of the SCIPWriter interface. All
// methods return zero values for all results, unless overwritten.
func NewMockSCIPWriter() *MockSCIPWriter {
	return &MockSCIPWriter{
		FlushFunc: &SCIPWriterFlushFunc{
			defaultHook: func(context.Context) (r0 uint32, r1 error) {
				return
			},
		},
		InsertDocumentFunc: &SCIPWriterInsertDocumentFunc{
			defaultHook: func(context.Context, string, *scip.Document) (r0 error) {
				return
			},
		},
	}
}

// NewStrictMockSCIPWriter creates a new mock of the SCIPWriter interface.
// All methods panic on invocation, unless overwritten.
func NewStrictMockSCIPWriter() *MockSCIPWriter {
	return &MockSCIPWriter{
		FlushFunc: &SCIPWriterFlushFunc{
			defaultHook: func(context.Context) (uint32, error) {
				panic("unexpected invocation of MockSCIPWriter.Flush")
			},
		},
		InsertDocumentFunc: &SCIPWriterInsertDocumentFunc{
			defaultHook: func(context.Context, string, *scip.Document) error {
				panic("unexpected invocation of MockSCIPWriter.InsertDocument")
			},
		},
	}
}

// NewMockSCIPWriterFrom creates a new mock of the MockSCIPWriter interface.
// All methods delegate to the given implementation, unless overwritten.
func NewMockSCIPWriterFrom(i lsifstore.SCIPWriter) *MockSCIPWriter {
	return &MockSCIPWriter{
		FlushFunc: &SCIPWriterFlushFunc{
			defaultHook: i.Flush,
		},
		InsertDocumentFunc: &SCIPWriterInsertDocumentFunc{
			defaultHook: i.InsertDocument,
		},
	}
}

// SCIPWriterFlushFunc describes the behavior when the Flush method of the
// parent MockSCIPWriter instance is invoked.
type SCIPWriterFlushFunc struct {
	defaultHook func(context.Context) (uint32, error)
	hooks       []func(context.Context) (uint32, error)
	history     []SCIPWriterFlushFuncCall
	mutex       sync.Mutex
}

// Flush delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockSCIPWriter) Flush(v0 context.Context) (uint32, error) {
	r0, r1 := m.FlushFunc.nextHook()(v0)
	m.FlushFunc.appendCall(SCIPWriterFlushFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Flush method of the
// parent MockSCIPWriter instance is invoked and the hook queue is empty.
func (f *SCIPWriterFlushFunc) SetDefaultHook(hook func(context.Context) (uint32, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Flush method of the parent MockSCIPWriter instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *SCIPWriterFlushFunc) PushHook(hook func(context.Context) (uint32, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *SCIPWriterFlushFunc) SetDefaultReturn(r0 uint32, r1 error) {
	f.SetDefaultHook(func(context.Context) (uint32, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *SCIPWriterFlushFunc) PushReturn(r0 uint32, r1 error) {
	f.PushHook(func(context.Context) (uint32, error) {
		return r0, r1
	})
}

func (f *SCIPWriterFlushFunc) nextHook() func(context.Context) (uint32, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *SCIPWriterFlushFunc) appendCall(r0 SCIPWriterFlushFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of SCIPWriterFlushFuncCall objects describing
// the invocations of this function.
func (f *SCIPWriterFlushFunc) History() []SCIPWriterFlushFuncCall {
	f.mutex.Lock()
	history := make([]SCIPWriterFlushFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// SCIPWriterFlushFuncCall is an object that describes an invocation of
// method Flush on an instance of MockSCIPWriter.
type SCIPWriterFlushFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 uint32
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c SCIPWriterFlushFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c SCIPWriterFlushFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// SCIPWriterInsertDocumentFunc describes the behavior when the
// InsertDocument method of the parent MockSCIPWriter instance is invoked.
type SCIPWriterInsertDocumentFunc struct {
	defaultHook func(context.Context, string, *scip.Document) error
	hooks       []func(context.Context, string, *scip.Document) error
	history     []SCIPWriterInsertDocumentFuncCall
	mutex       sync.Mutex
}

// InsertDocument delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockSCIPWriter) InsertDocument(v0 context.Context, v1 string, v2 *scip.Document) error {
	r0 := m.InsertDocumentFunc.nextHook()(v0, v1, v2)
	m.InsertDocumentFunc.appendCall(SCIPWriterInsertDocumentFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the InsertDocument
// method of the parent MockSCIPWriter instance is invoked and the hook
// queue is empty.
func (f *SCIPWriterInsertDocumentFunc) SetDefaultHook(hook func(context.Context, string, *scip.Document) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertDocument method of the parent MockSCIPWriter instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *SCIPWriterInsertDocumentFunc) PushHook(hook func(context.Context, string, *scip.Document) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *SCIPWriterInsertDocumentFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, string, *scip.Document) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *SCIPWriterInsertDocumentFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, string, *scip.Document) error {
		return r0
	})
}

func (f *SCIPWriterInsertDocumentFunc) nextHook() func(context.Context, string, *scip.Document) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *SCIPWriterInsertDocumentFunc) appendCall(r0 SCIPWriterInsertDocumentFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of SCIPWriterInsertDocumentFuncCall objects
// describing the invocations of this function.
func (f *SCIPWriterInsertDocumentFunc) History() []SCIPWriterInsertDocumentFuncCall {
	f.mutex.Lock()
	history := make([]SCIPWriterInsertDocumentFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// SCIPWriterInsertDocumentFuncCall is an object that describes an
// invocation of method InsertDocument on an instance of MockSCIPWriter.
type SCIPWriterInsertDocumentFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 *scip.Document
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c SCIPWriterInsertDocumentFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c SCIPWriterInsertDocumentFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// MockWorkerStore is a mock implementation of the Store interface (from the
// package
// github.com/sourcegraph/sourcegraph/internal/workerutil/dbworker/store)
// used for unit testing.
type MockWorkerStore[T workerutil.Record] struct {
	// AddExecutionLogEntryFunc is an instance of a mock function object
	// controlling the behavior of the method AddExecutionLogEntry.
	AddExecutionLogEntryFunc *WorkerStoreAddExecutionLogEntryFunc[T]
	// DequeueFunc is an instance of a mock function object controlling the
	// behavior of the method Dequeue.
	DequeueFunc *WorkerStoreDequeueFunc[T]
	// HandleFunc is an instance of a mock function object controlling the
	// behavior of the method Handle.
	HandleFunc *WorkerStoreHandleFunc[T]
	// HeartbeatFunc is an instance of a mock function object controlling
	// the behavior of the method Heartbeat.
	HeartbeatFunc *WorkerStoreHeartbeatFunc[T]
	// MarkCompleteFunc is an instance of a mock function object controlling
	// the behavior of the method MarkComplete.
	MarkCompleteFunc *WorkerStoreMarkCompleteFunc[T]
	// MarkErroredFunc is an instance of a mock function object controlling
	// the behavior of the method MarkErrored.
	MarkErroredFunc *WorkerStoreMarkErroredFunc[T]
	// MarkFailedFunc is an instance of a mock function object controlling
	// the behavior of the method MarkFailed.
	MarkFailedFunc *WorkerStoreMarkFailedFunc[T]
	// MaxDurationInQueueFunc is an instance of a mock function object
	// controlling the behavior of the method MaxDurationInQueue.
	MaxDurationInQueueFunc *WorkerStoreMaxDurationInQueueFunc[T]
	// QueuedCountFunc is an instance of a mock function object controlling
	// the behavior of the method QueuedCount.
	QueuedCountFunc *WorkerStoreQueuedCountFunc[T]
	// RequeueFunc is an instance of a mock function object controlling the
	// behavior of the method Requeue.
	RequeueFunc *WorkerStoreRequeueFunc[T]
	// ResetStalledFunc is an instance of a mock function object controlling
	// the behavior of the method ResetStalled.
	ResetStalledFunc *WorkerStoreResetStalledFunc[T]
	// UpdateExecutionLogEntryFunc is an instance of a mock function object
	// controlling the behavior of the method UpdateExecutionLogEntry.
	UpdateExecutionLogEntryFunc *WorkerStoreUpdateExecutionLogEntryFunc[T]
	// WithFunc is an instance of a mock function object controlling the
	// behavior of the method With.
	WithFunc *WorkerStoreWithFunc[T]
}

// NewMockWorkerStore creates a new mock of the Store interface. All methods
// return zero values for all results, unless overwritten.
func NewMockWorkerStore[T workerutil.Record]() *MockWorkerStore[T] {
	return &MockWorkerStore[T]{
		AddExecutionLogEntryFunc: &WorkerStoreAddExecutionLogEntryFunc[T]{
			defaultHook: func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (r0 int, r1 error) {
				return
			},
		},
		DequeueFunc: &WorkerStoreDequeueFunc[T]{
			defaultHook: func(context.Context, string, []*sqlf.Query) (r0 T, r1 bool, r2 error) {
				return
			},
		},
		HandleFunc: &WorkerStoreHandleFunc[T]{
			defaultHook: func() (r0 basestore.TransactableHandle) {
				return
			},
		},
		HeartbeatFunc: &WorkerStoreHeartbeatFunc[T]{
			defaultHook: func(context.Context, []int, store1.HeartbeatOptions) (r0 []int, r1 []int, r2 error) {
				return
			},
		},
		MarkCompleteFunc: &WorkerStoreMarkCompleteFunc[T]{
			defaultHook: func(context.Context, int, store1.MarkFinalOptions) (r0 bool, r1 error) {
				return
			},
		},
		MarkErroredFunc: &WorkerStoreMarkErroredFunc[T]{
			defaultHook: func(context.Context, int, string, store1.MarkFinalOptions) (r0 bool, r1 error) {
				return
			},
		},
		MarkFailedFunc: &WorkerStoreMarkFailedFunc[T]{
			defaultHook: func(context.Context, int, string, store1.MarkFinalOptions) (r0 bool, r1 error) {
				return
			},
		},
		MaxDurationInQueueFunc: &WorkerStoreMaxDurationInQueueFunc[T]{
			defaultHook: func(context.Context) (r0 time.Duration, r1 error) {
				return
			},
		},
		QueuedCountFunc: &WorkerStoreQueuedCountFunc[T]{
			defaultHook: func(context.Context, bool) (r0 int, r1 error) {
				return
			},
		},
		RequeueFunc: &WorkerStoreRequeueFunc[T]{
			defaultHook: func(context.Context, int, time.Time) (r0 error) {
				return
			},
		},
		ResetStalledFunc: &WorkerStoreResetStalledFunc[T]{
			defaultHook: func(context.Context) (r0 map[int]time.Duration, r1 map[int]time.Duration, r2 error) {
				return
			},
		},
		UpdateExecutionLogEntryFunc: &WorkerStoreUpdateExecutionLogEntryFunc[T]{
			defaultHook: func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (r0 error) {
				return
			},
		},
		WithFunc: &WorkerStoreWithFunc[T]{
			defaultHook: func(basestore.ShareableStore) (r0 store1.Store[T]) {
				return
			},
		},
	}
}

// NewStrictMockWorkerStore creates a new mock of the Store interface. All
// methods panic on invocation, unless overwritten.
func NewStrictMockWorkerStore[T workerutil.Record]() *MockWorkerStore[T] {
	return &MockWorkerStore[T]{
		AddExecutionLogEntryFunc: &WorkerStoreAddExecutionLogEntryFunc[T]{
			defaultHook: func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (int, error) {
				panic("unexpected invocation of MockWorkerStore.AddExecutionLogEntry")
			},
		},
		DequeueFunc: &WorkerStoreDequeueFunc[T]{
			defaultHook: func(context.Context, string, []*sqlf.Query) (T, bool, error) {
				panic("unexpected invocation of MockWorkerStore.Dequeue")
			},
		},
		HandleFunc: &WorkerStoreHandleFunc[T]{
			defaultHook: func() basestore.TransactableHandle {
				panic("unexpected invocation of MockWorkerStore.Handle")
			},
		},
		HeartbeatFunc: &WorkerStoreHeartbeatFunc[T]{
			defaultHook: func(context.Context, []int, store1.HeartbeatOptions) ([]int, []int, error) {
				panic("unexpected invocation of MockWorkerStore.Heartbeat")
			},
		},
		MarkCompleteFunc: &WorkerStoreMarkCompleteFunc[T]{
			defaultHook: func(context.Context, int, store1.MarkFinalOptions) (bool, error) {
				panic("unexpected invocation of MockWorkerStore.MarkComplete")
			},
		},
		MarkErroredFunc: &WorkerStoreMarkErroredFunc[T]{
			defaultHook: func(context.Context, int, string, store1.MarkFinalOptions) (bool, error) {
				panic("unexpected invocation of MockWorkerStore.MarkErrored")
			},
		},
		MarkFailedFunc: &WorkerStoreMarkFailedFunc[T]{
			defaultHook: func(context.Context, int, string, store1.MarkFinalOptions) (bool, error) {
				panic("unexpected invocation of MockWorkerStore.MarkFailed")
			},
		},
		MaxDurationInQueueFunc: &WorkerStoreMaxDurationInQueueFunc[T]{
			defaultHook: func(context.Context) (time.Duration, error) {
				panic("unexpected invocation of MockWorkerStore.MaxDurationInQueue")
			},
		},
		QueuedCountFunc: &WorkerStoreQueuedCountFunc[T]{
			defaultHook: func(context.Context, bool) (int, error) {
				panic("unexpected invocation of MockWorkerStore.QueuedCount")
			},
		},
		RequeueFunc: &WorkerStoreRequeueFunc[T]{
			defaultHook: func(context.Context, int, time.Time) error {
				panic("unexpected invocation of MockWorkerStore.Requeue")
			},
		},
		ResetStalledFunc: &WorkerStoreResetStalledFunc[T]{
			defaultHook: func(context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
				panic("unexpected invocation of MockWorkerStore.ResetStalled")
			},
		},
		UpdateExecutionLogEntryFunc: &WorkerStoreUpdateExecutionLogEntryFunc[T]{
			defaultHook: func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) error {
				panic("unexpected invocation of MockWorkerStore.UpdateExecutionLogEntry")
			},
		},
		WithFunc: &WorkerStoreWithFunc[T]{
			defaultHook: func(basestore.ShareableStore) store1.Store[T] {
				panic("unexpected invocation of MockWorkerStore.With")
			},
		},
	}
}

// NewMockWorkerStoreFrom creates a new mock of the MockWorkerStore
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockWorkerStoreFrom[T workerutil.Record](i store1.Store[T]) *MockWorkerStore[T] {
	return &MockWorkerStore[T]{
		AddExecutionLogEntryFunc: &WorkerStoreAddExecutionLogEntryFunc[T]{
			defaultHook: i.AddExecutionLogEntry,
		},
		DequeueFunc: &WorkerStoreDequeueFunc[T]{
			defaultHook: i.Dequeue,
		},
		HandleFunc: &WorkerStoreHandleFunc[T]{
			defaultHook: i.Handle,
		},
		HeartbeatFunc: &WorkerStoreHeartbeatFunc[T]{
			defaultHook: i.Heartbeat,
		},
		MarkCompleteFunc: &WorkerStoreMarkCompleteFunc[T]{
			defaultHook: i.MarkComplete,
		},
		MarkErroredFunc: &WorkerStoreMarkErroredFunc[T]{
			defaultHook: i.MarkErrored,
		},
		MarkFailedFunc: &WorkerStoreMarkFailedFunc[T]{
			defaultHook: i.MarkFailed,
		},
		MaxDurationInQueueFunc: &WorkerStoreMaxDurationInQueueFunc[T]{
			defaultHook: i.MaxDurationInQueue,
		},
		QueuedCountFunc: &WorkerStoreQueuedCountFunc[T]{
			defaultHook: i.QueuedCount,
		},
		RequeueFunc: &WorkerStoreRequeueFunc[T]{
			defaultHook: i.Requeue,
		},
		ResetStalledFunc: &WorkerStoreResetStalledFunc[T]{
			defaultHook: i.ResetStalled,
		},
		UpdateExecutionLogEntryFunc: &WorkerStoreUpdateExecutionLogEntryFunc[T]{
			defaultHook: i.UpdateExecutionLogEntry,
		},
		WithFunc: &WorkerStoreWithFunc[T]{
			defaultHook: i.With,
		},
	}
}

// WorkerStoreAddExecutionLogEntryFunc describes the behavior when the
// AddExecutionLogEntry method of the parent MockWorkerStore instance is
// invoked.
type WorkerStoreAddExecutionLogEntryFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (int, error)
	hooks       []func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (int, error)
	history     []WorkerStoreAddExecutionLogEntryFuncCall[T]
	mutex       sync.Mutex
}

// AddExecutionLogEntry delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockWorkerStore[T]) AddExecutionLogEntry(v0 context.Context, v1 int, v2 executor.ExecutionLogEntry, v3 store1.ExecutionLogEntryOptions) (int, error) {
	r0, r1 := m.AddExecutionLogEntryFunc.nextHook()(v0, v1, v2, v3)
	m.AddExecutionLogEntryFunc.appendCall(WorkerStoreAddExecutionLogEntryFuncCall[T]{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the AddExecutionLogEntry
// method of the parent MockWorkerStore instance is invoked and the hook
// queue is empty.
func (f *WorkerStoreAddExecutionLogEntryFunc[T]) SetDefaultHook(hook func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// AddExecutionLogEntry method of the parent MockWorkerStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *WorkerStoreAddExecutionLogEntryFunc[T]) PushHook(hook func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreAddExecutionLogEntryFunc[T]) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreAddExecutionLogEntryFunc[T]) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (int, error) {
		return r0, r1
	})
}

func (f *WorkerStoreAddExecutionLogEntryFunc[T]) nextHook() func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreAddExecutionLogEntryFunc[T]) appendCall(r0 WorkerStoreAddExecutionLogEntryFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreAddExecutionLogEntryFuncCall
// objects describing the invocations of this function.
func (f *WorkerStoreAddExecutionLogEntryFunc[T]) History() []WorkerStoreAddExecutionLogEntryFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreAddExecutionLogEntryFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreAddExecutionLogEntryFuncCall is an object that describes an
// invocation of method AddExecutionLogEntry on an instance of
// MockWorkerStore.
type WorkerStoreAddExecutionLogEntryFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 executor.ExecutionLogEntry
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 store1.ExecutionLogEntryOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreAddExecutionLogEntryFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreAddExecutionLogEntryFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreDequeueFunc describes the behavior when the Dequeue method of
// the parent MockWorkerStore instance is invoked.
type WorkerStoreDequeueFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, string, []*sqlf.Query) (T, bool, error)
	hooks       []func(context.Context, string, []*sqlf.Query) (T, bool, error)
	history     []WorkerStoreDequeueFuncCall[T]
	mutex       sync.Mutex
}

// Dequeue delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore[T]) Dequeue(v0 context.Context, v1 string, v2 []*sqlf.Query) (T, bool, error) {
	r0, r1, r2 := m.DequeueFunc.nextHook()(v0, v1, v2)
	m.DequeueFunc.appendCall(WorkerStoreDequeueFuncCall[T]{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Dequeue method of
// the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreDequeueFunc[T]) SetDefaultHook(hook func(context.Context, string, []*sqlf.Query) (T, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Dequeue method of the parent MockWorkerStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreDequeueFunc[T]) PushHook(hook func(context.Context, string, []*sqlf.Query) (T, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreDequeueFunc[T]) SetDefaultReturn(r0 T, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, string, []*sqlf.Query) (T, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreDequeueFunc[T]) PushReturn(r0 T, r1 bool, r2 error) {
	f.PushHook(func(context.Context, string, []*sqlf.Query) (T, bool, error) {
		return r0, r1, r2
	})
}

func (f *WorkerStoreDequeueFunc[T]) nextHook() func(context.Context, string, []*sqlf.Query) (T, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreDequeueFunc[T]) appendCall(r0 WorkerStoreDequeueFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreDequeueFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreDequeueFunc[T]) History() []WorkerStoreDequeueFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreDequeueFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreDequeueFuncCall is an object that describes an invocation of
// method Dequeue on an instance of MockWorkerStore.
type WorkerStoreDequeueFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []*sqlf.Query
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 T
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreDequeueFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreDequeueFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// WorkerStoreHandleFunc describes the behavior when the Handle method of
// the parent MockWorkerStore instance is invoked.
type WorkerStoreHandleFunc[T workerutil.Record] struct {
	defaultHook func() basestore.TransactableHandle
	hooks       []func() basestore.TransactableHandle
	history     []WorkerStoreHandleFuncCall[T]
	mutex       sync.Mutex
}

// Handle delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore[T]) Handle() basestore.TransactableHandle {
	r0 := m.HandleFunc.nextHook()()
	m.HandleFunc.appendCall(WorkerStoreHandleFuncCall[T]{r0})
	return r0
}

// SetDefaultHook sets function that is called when the Handle method of the
// parent MockWorkerStore instance is invoked and the hook queue is empty.
func (f *WorkerStoreHandleFunc[T]) SetDefaultHook(hook func() basestore.TransactableHandle) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Handle method of the parent MockWorkerStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreHandleFunc[T]) PushHook(hook func() basestore.TransactableHandle) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreHandleFunc[T]) SetDefaultReturn(r0 basestore.TransactableHandle) {
	f.SetDefaultHook(func() basestore.TransactableHandle {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreHandleFunc[T]) PushReturn(r0 basestore.TransactableHandle) {
	f.PushHook(func() basestore.TransactableHandle {
		return r0
	})
}

func (f *WorkerStoreHandleFunc[T]) nextHook() func() basestore.TransactableHandle {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreHandleFunc[T]) appendCall(r0 WorkerStoreHandleFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreHandleFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreHandleFunc[T]) History() []WorkerStoreHandleFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreHandleFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreHandleFuncCall is an object that describes an invocation of
// method Handle on an instance of MockWorkerStore.
type WorkerStoreHandleFuncCall[T workerutil.Record] struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 basestore.TransactableHandle
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreHandleFuncCall[T]) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreHandleFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0}
}

// WorkerStoreHeartbeatFunc describes the behavior when the Heartbeat method
// of the parent MockWorkerStore instance is invoked.
type WorkerStoreHeartbeatFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, []int, store1.HeartbeatOptions) ([]int, []int, error)
	hooks       []func(context.Context, []int, store1.HeartbeatOptions) ([]int, []int, error)
	history     []WorkerStoreHeartbeatFuncCall[T]
	mutex       sync.Mutex
}

// Heartbeat delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore[T]) Heartbeat(v0 context.Context, v1 []int, v2 store1.HeartbeatOptions) ([]int, []int, error) {
	r0, r1, r2 := m.HeartbeatFunc.nextHook()(v0, v1, v2)
	m.HeartbeatFunc.appendCall(WorkerStoreHeartbeatFuncCall[T]{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Heartbeat method of
// the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreHeartbeatFunc[T]) SetDefaultHook(hook func(context.Context, []int, store1.HeartbeatOptions) ([]int, []int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Heartbeat method of the parent MockWorkerStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreHeartbeatFunc[T]) PushHook(hook func(context.Context, []int, store1.HeartbeatOptions) ([]int, []int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreHeartbeatFunc[T]) SetDefaultReturn(r0 []int, r1 []int, r2 error) {
	f.SetDefaultHook(func(context.Context, []int, store1.HeartbeatOptions) ([]int, []int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreHeartbeatFunc[T]) PushReturn(r0 []int, r1 []int, r2 error) {
	f.PushHook(func(context.Context, []int, store1.HeartbeatOptions) ([]int, []int, error) {
		return r0, r1, r2
	})
}

func (f *WorkerStoreHeartbeatFunc[T]) nextHook() func(context.Context, []int, store1.HeartbeatOptions) ([]int, []int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreHeartbeatFunc[T]) appendCall(r0 WorkerStoreHeartbeatFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreHeartbeatFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreHeartbeatFunc[T]) History() []WorkerStoreHeartbeatFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreHeartbeatFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreHeartbeatFuncCall is an object that describes an invocation of
// method Heartbeat on an instance of MockWorkerStore.
type WorkerStoreHeartbeatFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 store1.HeartbeatOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 []int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreHeartbeatFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreHeartbeatFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// WorkerStoreMarkCompleteFunc describes the behavior when the MarkComplete
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreMarkCompleteFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, int, store1.MarkFinalOptions) (bool, error)
	hooks       []func(context.Context, int, store1.MarkFinalOptions) (bool, error)
	history     []WorkerStoreMarkCompleteFuncCall[T]
	mutex       sync.Mutex
}

// MarkComplete delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore[T]) MarkComplete(v0 context.Context, v1 int, v2 store1.MarkFinalOptions) (bool, error) {
	r0, r1 := m.MarkCompleteFunc.nextHook()(v0, v1, v2)
	m.MarkCompleteFunc.appendCall(WorkerStoreMarkCompleteFuncCall[T]{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MarkComplete method
// of the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreMarkCompleteFunc[T]) SetDefaultHook(hook func(context.Context, int, store1.MarkFinalOptions) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkComplete method of the parent MockWorkerStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *WorkerStoreMarkCompleteFunc[T]) PushHook(hook func(context.Context, int, store1.MarkFinalOptions) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreMarkCompleteFunc[T]) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, store1.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreMarkCompleteFunc[T]) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, store1.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

func (f *WorkerStoreMarkCompleteFunc[T]) nextHook() func(context.Context, int, store1.MarkFinalOptions) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreMarkCompleteFunc[T]) appendCall(r0 WorkerStoreMarkCompleteFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreMarkCompleteFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreMarkCompleteFunc[T]) History() []WorkerStoreMarkCompleteFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreMarkCompleteFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreMarkCompleteFuncCall is an object that describes an invocation
// of method MarkComplete on an instance of MockWorkerStore.
type WorkerStoreMarkCompleteFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 store1.MarkFinalOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreMarkCompleteFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreMarkCompleteFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreMarkErroredFunc describes the behavior when the MarkErrored
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreMarkErroredFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, int, string, store1.MarkFinalOptions) (bool, error)
	hooks       []func(context.Context, int, string, store1.MarkFinalOptions) (bool, error)
	history     []WorkerStoreMarkErroredFuncCall[T]
	mutex       sync.Mutex
}

// MarkErrored delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore[T]) MarkErrored(v0 context.Context, v1 int, v2 string, v3 store1.MarkFinalOptions) (bool, error) {
	r0, r1 := m.MarkErroredFunc.nextHook()(v0, v1, v2, v3)
	m.MarkErroredFunc.appendCall(WorkerStoreMarkErroredFuncCall[T]{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MarkErrored method
// of the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreMarkErroredFunc[T]) SetDefaultHook(hook func(context.Context, int, string, store1.MarkFinalOptions) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkErrored method of the parent MockWorkerStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *WorkerStoreMarkErroredFunc[T]) PushHook(hook func(context.Context, int, string, store1.MarkFinalOptions) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreMarkErroredFunc[T]) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, store1.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreMarkErroredFunc[T]) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string, store1.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

func (f *WorkerStoreMarkErroredFunc[T]) nextHook() func(context.Context, int, string, store1.MarkFinalOptions) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreMarkErroredFunc[T]) appendCall(r0 WorkerStoreMarkErroredFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreMarkErroredFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreMarkErroredFunc[T]) History() []WorkerStoreMarkErroredFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreMarkErroredFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreMarkErroredFuncCall is an object that describes an invocation
// of method MarkErrored on an instance of MockWorkerStore.
type WorkerStoreMarkErroredFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 store1.MarkFinalOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreMarkErroredFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreMarkErroredFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreMarkFailedFunc describes the behavior when the MarkFailed
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreMarkFailedFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, int, string, store1.MarkFinalOptions) (bool, error)
	hooks       []func(context.Context, int, string, store1.MarkFinalOptions) (bool, error)
	history     []WorkerStoreMarkFailedFuncCall[T]
	mutex       sync.Mutex
}

// MarkFailed delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore[T]) MarkFailed(v0 context.Context, v1 int, v2 string, v3 store1.MarkFinalOptions) (bool, error) {
	r0, r1 := m.MarkFailedFunc.nextHook()(v0, v1, v2, v3)
	m.MarkFailedFunc.appendCall(WorkerStoreMarkFailedFuncCall[T]{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MarkFailed method of
// the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreMarkFailedFunc[T]) SetDefaultHook(hook func(context.Context, int, string, store1.MarkFinalOptions) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkFailed method of the parent MockWorkerStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreMarkFailedFunc[T]) PushHook(hook func(context.Context, int, string, store1.MarkFinalOptions) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreMarkFailedFunc[T]) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, store1.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreMarkFailedFunc[T]) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string, store1.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

func (f *WorkerStoreMarkFailedFunc[T]) nextHook() func(context.Context, int, string, store1.MarkFinalOptions) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreMarkFailedFunc[T]) appendCall(r0 WorkerStoreMarkFailedFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreMarkFailedFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreMarkFailedFunc[T]) History() []WorkerStoreMarkFailedFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreMarkFailedFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreMarkFailedFuncCall is an object that describes an invocation
// of method MarkFailed on an instance of MockWorkerStore.
type WorkerStoreMarkFailedFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 store1.MarkFinalOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreMarkFailedFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreMarkFailedFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreMaxDurationInQueueFunc describes the behavior when the
// MaxDurationInQueue method of the parent MockWorkerStore instance is
// invoked.
type WorkerStoreMaxDurationInQueueFunc[T workerutil.Record] struct {
	defaultHook func(context.Context) (time.Duration, error)
	hooks       []func(context.Context) (time.Duration, error)
	history     []WorkerStoreMaxDurationInQueueFuncCall[T]
	mutex       sync.Mutex
}

// MaxDurationInQueue delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockWorkerStore[T]) MaxDurationInQueue(v0 context.Context) (time.Duration, error) {
	r0, r1 := m.MaxDurationInQueueFunc.nextHook()(v0)
	m.MaxDurationInQueueFunc.appendCall(WorkerStoreMaxDurationInQueueFuncCall[T]{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MaxDurationInQueue
// method of the parent MockWorkerStore instance is invoked and the hook
// queue is empty.
func (f *WorkerStoreMaxDurationInQueueFunc[T]) SetDefaultHook(hook func(context.Context) (time.Duration, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MaxDurationInQueue method of the parent MockWorkerStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *WorkerStoreMaxDurationInQueueFunc[T]) PushHook(hook func(context.Context) (time.Duration, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreMaxDurationInQueueFunc[T]) SetDefaultReturn(r0 time.Duration, r1 error) {
	f.SetDefaultHook(func(context.Context) (time.Duration, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreMaxDurationInQueueFunc[T]) PushReturn(r0 time.Duration, r1 error) {
	f.PushHook(func(context.Context) (time.Duration, error) {
		return r0, r1
	})
}

func (f *WorkerStoreMaxDurationInQueueFunc[T]) nextHook() func(context.Context) (time.Duration, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreMaxDurationInQueueFunc[T]) appendCall(r0 WorkerStoreMaxDurationInQueueFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreMaxDurationInQueueFuncCall
// objects describing the invocations of this function.
func (f *WorkerStoreMaxDurationInQueueFunc[T]) History() []WorkerStoreMaxDurationInQueueFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreMaxDurationInQueueFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreMaxDurationInQueueFuncCall is an object that describes an
// invocation of method MaxDurationInQueue on an instance of
// MockWorkerStore.
type WorkerStoreMaxDurationInQueueFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 time.Duration
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreMaxDurationInQueueFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreMaxDurationInQueueFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreQueuedCountFunc describes the behavior when the QueuedCount
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreQueuedCountFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, bool) (int, error)
	hooks       []func(context.Context, bool) (int, error)
	history     []WorkerStoreQueuedCountFuncCall[T]
	mutex       sync.Mutex
}

// QueuedCount delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore[T]) QueuedCount(v0 context.Context, v1 bool) (int, error) {
	r0, r1 := m.QueuedCountFunc.nextHook()(v0, v1)
	m.QueuedCountFunc.appendCall(WorkerStoreQueuedCountFuncCall[T]{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the QueuedCount method
// of the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreQueuedCountFunc[T]) SetDefaultHook(hook func(context.Context, bool) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// QueuedCount method of the parent MockWorkerStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *WorkerStoreQueuedCountFunc[T]) PushHook(hook func(context.Context, bool) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreQueuedCountFunc[T]) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, bool) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreQueuedCountFunc[T]) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, bool) (int, error) {
		return r0, r1
	})
}

func (f *WorkerStoreQueuedCountFunc[T]) nextHook() func(context.Context, bool) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreQueuedCountFunc[T]) appendCall(r0 WorkerStoreQueuedCountFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreQueuedCountFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreQueuedCountFunc[T]) History() []WorkerStoreQueuedCountFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreQueuedCountFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreQueuedCountFuncCall is an object that describes an invocation
// of method QueuedCount on an instance of MockWorkerStore.
type WorkerStoreQueuedCountFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 bool
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreQueuedCountFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreQueuedCountFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreRequeueFunc describes the behavior when the Requeue method of
// the parent MockWorkerStore instance is invoked.
type WorkerStoreRequeueFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, int, time.Time) error
	hooks       []func(context.Context, int, time.Time) error
	history     []WorkerStoreRequeueFuncCall[T]
	mutex       sync.Mutex
}

// Requeue delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore[T]) Requeue(v0 context.Context, v1 int, v2 time.Time) error {
	r0 := m.RequeueFunc.nextHook()(v0, v1, v2)
	m.RequeueFunc.appendCall(WorkerStoreRequeueFuncCall[T]{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Requeue method of
// the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreRequeueFunc[T]) SetDefaultHook(hook func(context.Context, int, time.Time) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Requeue method of the parent MockWorkerStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreRequeueFunc[T]) PushHook(hook func(context.Context, int, time.Time) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreRequeueFunc[T]) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreRequeueFunc[T]) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

func (f *WorkerStoreRequeueFunc[T]) nextHook() func(context.Context, int, time.Time) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreRequeueFunc[T]) appendCall(r0 WorkerStoreRequeueFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreRequeueFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreRequeueFunc[T]) History() []WorkerStoreRequeueFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreRequeueFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreRequeueFuncCall is an object that describes an invocation of
// method Requeue on an instance of MockWorkerStore.
type WorkerStoreRequeueFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreRequeueFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreRequeueFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0}
}

// WorkerStoreResetStalledFunc describes the behavior when the ResetStalled
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreResetStalledFunc[T workerutil.Record] struct {
	defaultHook func(context.Context) (map[int]time.Duration, map[int]time.Duration, error)
	hooks       []func(context.Context) (map[int]time.Duration, map[int]time.Duration, error)
	history     []WorkerStoreResetStalledFuncCall[T]
	mutex       sync.Mutex
}

// ResetStalled delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore[T]) ResetStalled(v0 context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
	r0, r1, r2 := m.ResetStalledFunc.nextHook()(v0)
	m.ResetStalledFunc.appendCall(WorkerStoreResetStalledFuncCall[T]{v0, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the ResetStalled method
// of the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreResetStalledFunc[T]) SetDefaultHook(hook func(context.Context) (map[int]time.Duration, map[int]time.Duration, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ResetStalled method of the parent MockWorkerStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *WorkerStoreResetStalledFunc[T]) PushHook(hook func(context.Context) (map[int]time.Duration, map[int]time.Duration, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreResetStalledFunc[T]) SetDefaultReturn(r0 map[int]time.Duration, r1 map[int]time.Duration, r2 error) {
	f.SetDefaultHook(func(context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreResetStalledFunc[T]) PushReturn(r0 map[int]time.Duration, r1 map[int]time.Duration, r2 error) {
	f.PushHook(func(context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
		return r0, r1, r2
	})
}

func (f *WorkerStoreResetStalledFunc[T]) nextHook() func(context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreResetStalledFunc[T]) appendCall(r0 WorkerStoreResetStalledFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreResetStalledFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreResetStalledFunc[T]) History() []WorkerStoreResetStalledFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreResetStalledFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreResetStalledFuncCall is an object that describes an invocation
// of method ResetStalled on an instance of MockWorkerStore.
type WorkerStoreResetStalledFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[int]time.Duration
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 map[int]time.Duration
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreResetStalledFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreResetStalledFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// WorkerStoreUpdateExecutionLogEntryFunc describes the behavior when the
// UpdateExecutionLogEntry method of the parent MockWorkerStore instance is
// invoked.
type WorkerStoreUpdateExecutionLogEntryFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) error
	hooks       []func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) error
	history     []WorkerStoreUpdateExecutionLogEntryFuncCall[T]
	mutex       sync.Mutex
}

// UpdateExecutionLogEntry delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockWorkerStore[T]) UpdateExecutionLogEntry(v0 context.Context, v1 int, v2 int, v3 executor.ExecutionLogEntry, v4 store1.ExecutionLogEntryOptions) error {
	r0 := m.UpdateExecutionLogEntryFunc.nextHook()(v0, v1, v2, v3, v4)
	m.UpdateExecutionLogEntryFunc.appendCall(WorkerStoreUpdateExecutionLogEntryFuncCall[T]{v0, v1, v2, v3, v4, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdateExecutionLogEntry method of the parent MockWorkerStore instance is
// invoked and the hook queue is empty.
func (f *WorkerStoreUpdateExecutionLogEntryFunc[T]) SetDefaultHook(hook func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateExecutionLogEntry method of the parent MockWorkerStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *WorkerStoreUpdateExecutionLogEntryFunc[T]) PushHook(hook func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreUpdateExecutionLogEntryFunc[T]) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreUpdateExecutionLogEntryFunc[T]) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) error {
		return r0
	})
}

func (f *WorkerStoreUpdateExecutionLogEntryFunc[T]) nextHook() func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreUpdateExecutionLogEntryFunc[T]) appendCall(r0 WorkerStoreUpdateExecutionLogEntryFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreUpdateExecutionLogEntryFuncCall
// objects describing the invocations of this function.
func (f *WorkerStoreUpdateExecutionLogEntryFunc[T]) History() []WorkerStoreUpdateExecutionLogEntryFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreUpdateExecutionLogEntryFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreUpdateExecutionLogEntryFuncCall is an object that describes an
// invocation of method UpdateExecutionLogEntry on an instance of
// MockWorkerStore.
type WorkerStoreUpdateExecutionLogEntryFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 executor.ExecutionLogEntry
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 store1.ExecutionLogEntryOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreUpdateExecutionLogEntryFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreUpdateExecutionLogEntryFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0}
}

// WorkerStoreWithFunc describes the behavior when the With method of the
// parent MockWorkerStore instance is invoked.
type WorkerStoreWithFunc[T workerutil.Record] struct {
	defaultHook func(basestore.ShareableStore) store1.Store[T]
	hooks       []func(basestore.ShareableStore) store1.Store[T]
	history     []WorkerStoreWithFuncCall[T]
	mutex       sync.Mutex
}

// With delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore[T]) With(v0 basestore.ShareableStore) store1.Store[T] {
	r0 := m.WithFunc.nextHook()(v0)
	m.WithFunc.appendCall(WorkerStoreWithFuncCall[T]{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the With method of the
// parent MockWorkerStore instance is invoked and the hook queue is empty.
func (f *WorkerStoreWithFunc[T]) SetDefaultHook(hook func(basestore.ShareableStore) store1.Store[T]) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// With method of the parent MockWorkerStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreWithFunc[T]) PushHook(hook func(basestore.ShareableStore) store1.Store[T]) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreWithFunc[T]) SetDefaultReturn(r0 store1.Store[T]) {
	f.SetDefaultHook(func(basestore.ShareableStore) store1.Store[T] {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreWithFunc[T]) PushReturn(r0 store1.Store[T]) {
	f.PushHook(func(basestore.ShareableStore) store1.Store[T] {
		return r0
	})
}

func (f *WorkerStoreWithFunc[T]) nextHook() func(basestore.ShareableStore) store1.Store[T] {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreWithFunc[T]) appendCall(r0 WorkerStoreWithFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreWithFuncCall objects describing
// the invocations of this function.
func (f *WorkerStoreWithFunc[T]) History() []WorkerStoreWithFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreWithFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreWithFuncCall is an object that describes an invocation of
// method With on an instance of MockWorkerStore.
type WorkerStoreWithFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 basestore.ShareableStore
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store1.Store[T]
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreWithFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreWithFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0}
}
