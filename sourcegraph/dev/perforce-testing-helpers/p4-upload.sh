#!/usr/bin/env bash

SCRIPT_ROOT="$(dirname "${BASH_SOURCE[0]}")"
cd "${SCRIPT_ROOT}"

export TEMPLATES="${SCRIPT_ROOT}/templates"

set -euo pipefail

export P4USER="${P4USER:-"admin"}"                         # the name of the Perforce superuser that the script will use to create the depot
export P4PORT="${P4PORT:-"perforce-tests.sgdev.org:1666"}" # the address of the Perforce server to connect to

export DEPOT_NAME="${DEPOT_NAME:-"integration-test-depot"}" # the name of the depot that the script will create on the server
export P4CLIENT="${P4CLIENT:-"integration-test-client"}"    # the name of the temporary client that the script will use while it creates the depot

# ensure that user has all necessary binaries installed
{
  # dictionary of binary name -> installation instructions
  declare -A dependencies=(
    ["p4"]="$(
      cat <<'END'
Please install 'p4' by:
  - (macOS): running brew install p4
  - (Linux): installing it via your distribution's package manager
See https://www.perforce.com/downloads/helix-command-line-client-p4 for more information.
END
    )"

    ["parallel"]="$(
      cat <<'END'
Please install 'GNU parallel' by:
  - (macOS): running brew install parallel
  - (Linux): installing it via your distribution's package manager
See https://www.gnu.org/software/parallel/ for more information.
END
    )"
  )

  # test to see if each dependency is installed - if not, print installation instructions and exit
  for d in "${!dependencies[@]}"; do
    if ! command -v "$d" &>/dev/null; then
      instructions="${dependencies[$d]}"
      printf "command %s is not installed.\n%s" "$d" "$instructions"
      exit 1
    fi
  done
}

# my_chronic supresses output from the specified command iff the command returns
# successfully.
#
## See https://unix.stackexchange.com/a/256201.
my_chronic() {
  # this will be the temp file w/ the output
  tmp="$(mktemp)" || return # this will be the temp file w/ the output

  set +e
  # this should run the command, respecting all arguments
  "$@" >"$tmp"
  ret=$?
  set -e

  # if $? (the return of the last run command) is not zero, cat the temp file
  [ "$ret" -eq 0 ] || (echo && cat "$tmp")

  return "$ret"
}
export -f my_chronic

# push_file_to_perforce deletes the client specified by "$P4CLIENT"
# if it exists on the Perforce server.
#
## P4 CLI reference(s):
push_file_to_perforce() {
  local file="$1"

  local changelist_number

  printf "pushing '%s' to server..." "$file"

  # create changelist object and extract the autogenerated number
  # https://www.perforce.com/manuals/cmdref/Content/CmdRef/p4_change.html
  changelist_number=$(
    envsubst <"${TEMPLATES}/changelist.tmpl" |
      p4 change -i |
      awk '{print $2}'
  )

  # add given file to changelist, then submit it
  my_chronic p4 add -c "$changelist_number" "$file"
  my_chronic p4 submit -c "$changelist_number"

  printf "done\n"
}
export -f push_file_to_perforce

# delete_perforce_client deletes the client specified by "$P4CLIENT"
# if it exists on the Perforce server.
#
## P4 CLI reference(s):
##
## https://www.perforce.com/manuals/cmdref/Content/CmdRef/p4_client.html
delete_perforce_client() {
  if p4 clients | awk '{print $2}' | grep -Fxq "${P4CLIENT}"; then
    # delete the client

    my_chronic p4 client -f -Fs -d "${P4CLIENT}"
  fi
}

# ensure that user is logged into the Perforce server
if ! p4 login -s &>/dev/null; then
  handbook_link="https://handbook.sourcegraph.com/departments/ce-support/support/process/p4-enablement/#generate-a-session-ticket"
  address="${P4USER}:${P4PORT}"

  cat <<END
'p4 login -s' command failed. This indicates that you might not be logged into '$address'.
Try using 'p4 -u ${P4USER} login -a' to generate a session ticket.
See '${handbook_link}' for more information.
END

  exit 1
fi

# (re)create test depot
#
## P4 CLI reference(s):
##
## https://www.perforce.com/manuals/cmdref/Content/CmdRef/p4_obliterate.html
## https://www.perforce.com/manuals/cmdref/Content/CmdRef/p4_depot.html
{
  printf "(re)creating test depot '%s'..." "$DEPOT_NAME"

  # delete older copy of depot if it exists
  if p4 depots | awk '{print $2}' | grep -Fxq "$DEPOT_NAME"; then

    # first, delete all files associated with depot
    my_chronic p4 obliterate -y "//${DEPOT_NAME}/..."

    # then, delete the depot itself
    my_chronic p4 depot -df "$DEPOT_NAME"
  fi

  # create new depot
  DESCRIPTION="Created by ${P4USER} for testing purposes." \
    envsubst <"${TEMPLATES}/depot.tmpl" |
    my_chronic p4 depot -i

  printf "done\n"
}

# (re)create temporary perforce client that we'll use to upload the depot contents
#
## P4 CLI reference(s):
##
## https://www.perforce.com/manuals/cmdref/Content/CmdRef/p4_client.html
{
  printf "(re)creating temporary client '%s'..." "$P4CLIENT"

  # delete older copy of client (if it exists)
  delete_perforce_client

  # create new client
  DEPOT_DIR="${SCRIPT_ROOT}/base" P4_CLIENT_HOST="$(hostname)" envsubst <"${TEMPLATES}/client.tmpl" |
    my_chronic p4 client -i

  # ensure that we don't leave a client behind (using up one of our licenses)
  trap delete_perforce_client EXIT

  printf "done\n"
}

# upload the depot contents
{
  printf "uploading contents of '%s'..." "$DEPOT_NAME"

  # remove parallel citation log spam.
  echo 'will cite' | parallel --citation &>/dev/null

  # change to depot source directory
  cd "${SCRIPT_ROOT}/base"

  # discover all file names in test depot
  find . -type f -print0 |
    # push files to the Perforce server in parallel
    parallel -0 --keep-order --line-buffer my_chronic push_file_to_perforce

  printf "done\n"
}
