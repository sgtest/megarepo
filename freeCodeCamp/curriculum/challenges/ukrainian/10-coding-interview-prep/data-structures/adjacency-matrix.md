---
id: 587d8256367417b2b2512c78
title: Матриця суміжності
challengeType: 1
forumTopicId: 301621
dashedName: adjacency-matrix
---

# --description--

Ще один спосіб представити граф — у вигляді <dfn>матриці суміжності</dfn>. <dfn>Матриця суміжності</dfn> — це двовимірний (2D) масив, де кожен вкладений масив має таку ж кількість елементів, як і зовнішній. Іншими словами, це матриця або таблиця чисел, де числа являють собою ребра.

**Примітка**: числа зверху і зліва від матриці — це лише мітки для вершин. Одиниці всередині матриці означають, що між вершинами, які представляють ряд та стовпець, існує ребро. Нулі означають, що ребра чи зв’язку немає.

<pre>
    1 2 3
  \------
1 | 0 1 1
2 | 1 0 0
3 | 1 0 0
</pre>

Приклад вище — це дуже простий, неорієнтований граф з трьома вершинами, де перша вершина з’єднана з другою та третьою вершинами. Нижче подана реалізація цього прикладу за допомогою JavaScript.

```js
var adjMat = [
  [0, 1, 1],
  [1, 0, 0],
  [1, 0, 0]
];
```

На відміну від списку суміжності, кількість елементів у кожному ряді матриці має збігатись з кількістю вершин графа. Нам дано матрицю 3×3, тобто в нашому графі є три вершини. Подібно виглядає й орієнтований граф. Нижче наведено граф, де перша вершина має ребро, спрямоване до другої вершини, а друга вершина має ребро, спрямоване до третьої вершини.

```js
var adjMatDirected = [
  [0, 1, 0],
  [0, 0, 1],
  [0, 0, 0]
];
```

Графи також можуть мати <dfn>ваги</dfn> своїх ребер. Поки що ми маємо <dfn>незважені</dfn> ребра, де присутність і відсутність ребра є бінарним елементом (`0` або `1`). Ваги можуть бути різними в залежності від сфери застосування.

# --instructions--

Створіть матрицю суміжності для неорієнтованого графа з п’ятьма вершинами. Ця матриця повинна бути у багатовимірному масиві. Ці п’ять вершин мають такі зв’язки: між першою і четвертою вершинами, першою і третьою вершинами, третьою і п’ятою вершинами, четвертою і п’ятою вершинами. Вага кожного ребра дорівнює 1.

# --hints--

`undirectedAdjList` має містити лише п’ять вершин.

```js
assert(
  adjMatUndirected.length === 5 &&
    adjMatUndirected
      .map(function (x) {
        return x.length === 5;
      })
      .reduce(function (a, b) {
        return a && b;
      })
);
```

Між першою і четвертою вершинами має бути ребро.

```js
assert(adjMatUndirected[0][3] === 1 && adjMatUndirected[3][0] === 1);
```

Між першою і третьою вершинами має бути ребро.

```js
assert(adjMatUndirected[0][2] === 1 && adjMatUndirected[2][0] === 1);
```

Між третьою і п’ятою вершинами має бути ребро.

```js
assert(adjMatUndirected[2][4] === 1 && adjMatUndirected[4][2] === 1);
```

Між четвертою і п’ятою вершинами має бути ребро.

```js
assert(adjMatUndirected[3][4] === 1 && adjMatUndirected[4][3] === 1);
```

# --seed--

## --seed-contents--

```js
var adjMatUndirected = [];
```

# --solutions--

```js
var adjMatUndirected = [
  [0, 0, 1, 1, 0],
  [0, 0, 0, 0, 0],
  [1, 0, 0, 0, 1],
  [1, 0, 0, 0, 1],
  [0, 0, 1, 1, 0]
];
```
